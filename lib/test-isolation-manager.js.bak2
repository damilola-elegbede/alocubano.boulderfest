/**
 * Test Isolation Manager
 *
 * Provides complete test isolation by creating scoped database instances
 * that are fully isolated from each other. Solves CLIENT_CLOSED errors
 * by ensuring each test scope gets a fresh database connection that
 * cannot interfere with other tests.
 *
 * Key Features:
 * - Creates isolated test scopes with unique identifiers
 * - Clears Node.js module cache to force fresh database instances
 * - Tracks all database connections per scope for cleanup
 * - Provides scoped database clients with zero cross-contamination
 * - Automatic cleanup that destroys scopes and closes connections
 * - Compatible with existing database.js implementation
 */

import { logger } from './logger.js';
import { randomUUID } from 'crypto';

class TestIsolationManager {
  constructor() {
    // Track all active test scopes with enhanced metadata
    this.activeScopes = new Map();
    // Global connection registry for emergency cleanup
    this.globalConnectionRegistry = new Set();
    // Track module cache keys for cleanup
    this.moduleCache = new Map();
    // Performance tracking
    this.performanceMetrics = {
      scopesCreated: 0,
      scopesDestroyed: 0,
      connectionsCreated: 0,
      connectionsClosed: 0,
      modulesCached: 0,
      modulesCleared: 0,
      averageCleanupTime: 0,
      emergencyCleanups: 0,
      lastCleanupTime: null
    };
    // Legacy compatibility
    this.testScopes = this.activeScopes; // Backward compatibility
    this.activeConnections = this.globalConnectionRegistry; // Backward compatibility
    this.isTestMode = false;
    this.currentTestId = null;
  }

  /**
   * Initialize test isolation for integration tests
   * Must be called in test setup
   */
  async initializeTestMode() {
    this.isTestMode = true;
    logger.debug('üî¨ Test Isolation Manager initialized');

    // Clear any existing state
    await this.emergencyCleanup();
  }

  /**
   * Create an isolated test scope with unique ID
   * @param {string} testName - Name of the test for debugging
   * @param {Object} options - Configuration options
   * @returns {Promise<string>} Scope ID
   */
  async createScope(testName, options = {}) {
    const startTime = Date.now();
    const scopeId = `test_${Date.now()}_${randomUUID().substring(0, 8)}`;

    try {
      logger.debug(`üî¨ Creating test scope: ${scopeId} for test: ${testName}`);

      // Clear module cache before creating scope to ensure fresh imports
      await this.clearModuleCache();

      // Create scope metadata
      const scope = {
        id: scopeId,
        testName,
        createdAt: new Date().toISOString(),
        connections: new Set(),
        moduleSnapshots: new Map(),
        migrationCompleted: false,
        databaseClient: null, // Cache for database client within this scope
        options: {
          // Default options
          isolateModules: true,
          trackConnections: true,
          autoCleanup: true,
          connectionTimeout: 5000,
          ...options
        }
      };

      // Store snapshot of current module cache state
      if (scope.options.isolateModules) {
        scope.moduleSnapshots = this.captureModuleSnapshot();
      }

      // Register scope
      this.activeScopes.set(scopeId, scope);

      // Update metrics
      this.performanceMetrics.scopesCreated++;

      const duration = Date.now() - startTime;
      logger.debug(`‚úÖ Test scope created: ${scopeId} (${duration}ms)`);

      return scopeId;
    } catch (error) {
      logger.error(`‚ùå Failed to create test scope for ${testName}:`, error.message);
      throw new Error(`Test scope creation failed: ${error.message}`);
    }
  }

  /**
   * Legacy method for backward compatibility
   * Create a new isolated scope for a test
   * Each test gets its own scope with fresh connections
   */
  async createTestScope(testId) {
    if (!this.isTestMode) {
      await this.initializeTestMode();
    }

    // Clean up any previous scope
    if (this.currentTestId) {
      await this.destroyScope(this.currentTestId);
    }

    this.currentTestId = testId || `test-${Date.now()}`;

    // Use the new createScope method internally
    const scopeId = await this.createScope(this.currentTestId, {
      isolateModules: true,
      trackConnections: true,
      autoCleanup: true
    });

    // Update current test ID to the actual scope ID
    this.currentTestId = scopeId;

    const scope = this.activeScopes.get(scopeId);
    logger.debug(`üìã Created legacy test scope: ${this.currentTestId}`);

    return scope;
  }

  /**
   * Destroy a test scope and clean up all resources
   * @param {string} scopeId - Scope ID to destroy
   * @returns {Promise<boolean>} True if cleanup was successful
   */
  async destroyScope(scopeId) {
    const startTime = Date.now();

    if (!scopeId) {
      logger.warn('‚ö†Ô∏è  Attempted to destroy scope with no ID');
      return false;
    }

    const scope = this.activeScopes.get(scopeId);
    if (!scope) {
      logger.warn(`‚ö†Ô∏è  Scope ${scopeId} not found for destruction`);
      return false;
    }

    logger.debug(`üßπ Destroying test scope: ${scopeId} (test: ${scope.testName})`);

    let cleanupSuccess = true;

    try {
      // 1. Close all database connections for this scope
      const connectionCleanup = await this.closeConnections(scope);
      if (!connectionCleanup) {
        cleanupSuccess = false;
        logger.warn(`‚ö†Ô∏è  Some connections failed to close in scope ${scopeId}`);
      }

      // 2. Clear module cache to force fresh instances for next test
      if (scope.options.isolateModules) {
        await this.clearModuleCache();
      }

      // 3. Remove scope from registry
      this.activeScopes.delete(scopeId);

      // Update metrics
      this.performanceMetrics.scopesDestroyed++;
      const duration = Date.now() - startTime;
      this.updateAverageCleanupTime(duration);

      logger.debug(`‚úÖ Test scope destroyed: ${scopeId} (${duration}ms)`);

      return cleanupSuccess;
    } catch (error) {
      logger.error(`‚ùå Error destroying scope ${scopeId}:`, error.message);

      // Force cleanup even if there were errors
      this.activeScopes.delete(scopeId);

      return false;
    }
  }


  /**
   * Legacy method - Get fresh database client for current test scope
   * This ensures complete isolation from other tests
   *
   * This method supports both the new API with scopeId parameter
   * and the legacy API without parameters (uses currentTestId)
   */
  async getScopedDatabaseClient(scopeId) {
    // If scopeId is provided, use the new API
    if (scopeId) {
      const scope = this.activeScopes.get(scopeId);
      if (!scope) {
        throw new Error(`Test scope ${scopeId} not found`);
      }

      try {
        // Clear module cache to ensure fresh database instance
        await this.clearModuleCache();

        // Import fresh database module - this will create a new singleton instance
        const databaseModule = await import('./database.js?' + Date.now());

        // Get fresh client from the new module instance
        const client = await databaseModule.getDatabaseClient();

        // Verify client is valid
        if (!client || typeof client.execute !== 'function') {
          throw new Error('Invalid database client returned from fresh import');
        }

        // Track this connection in the scope
        scope.connections.add(client);
        this.globalConnectionRegistry.add(client);
        this.performanceMetrics.connectionsCreated++;

        logger.debug(`üîó Created scoped database client for scope ${scopeId}`);

        return client;
      } catch (error) {
        logger.error(`‚ùå Failed to create scoped database client for ${scopeId}:`, error.message);
        throw new Error(`Scoped database client creation failed: ${error.message}`);
      }
    }

    // Legacy API - use currentTestId
    if (!this.currentTestId) {
      // Auto-create a test scope if none exists
      logger.debug('üîß No active test scope - auto-creating one');
      await this.createTestScope(`auto-${Date.now()}`);
    }

    const scope = this.activeScopes.get(this.currentTestId);
    if (!scope) {
      throw new Error(`Test scope not found: ${this.currentTestId}`);
    }

    // CRITICAL: Clear module cache to force fresh singleton
    await this.clearDatabaseModuleCache();

    // Import fresh database module
    const { getDatabaseClient, resetDatabaseInstance } = await this.getFreshDatabaseModule();

    // Reset the singleton first to ensure clean state
    await resetDatabaseInstance();

    // Get fresh client
    const client = await getDatabaseClient();

    // Run migrations on the fresh client if not done for this scope
    if (!scope.migrationCompleted) {
      try {
        // Import migration system
        const { MigrationSystem } = await import('../scripts/migrate.js');
        const migrationSystem = new MigrationSystem();

        // Override the migration system to use our client
        migrationSystem.getClient = async () => client;

        // Run migrations
        logger.debug(`üîÑ Running migrations for test scope: ${this.currentTestId}`);
        await migrationSystem.runMigrations();

        // Mark as completed for this scope
        scope.migrationCompleted = true;
        logger.debug(`‚úÖ Migrations completed for test scope: ${this.currentTestId}`);
      } catch (migrationError) {
        logger.warn(`‚ö†Ô∏è Migration failed for scope ${this.currentTestId}:`, migrationError.message);
        // Don't fail the test, but log the warning
      }
    }

    // Track this connection in the scope
    scope.connections.add(client);
    this.globalConnectionRegistry.add(client);
    this.performanceMetrics.connectionsCreated++;

    logger.debug(`üîó Created legacy scoped database client for test: ${this.currentTestId}`);
    return client;
  }

  /**
   * Clear Node.js module cache for database-related modules
   * This forces fresh imports and prevents singleton sharing
   * @returns {Promise<void>}
   */
  async clearModuleCache() {
    try {
      const moduleKeysToDelete = [];

      // Check if we're in a CommonJS environment with require.cache
      if (typeof require !== 'undefined' && require.cache) {
        // Find all database-related modules in the cache
        for (const key of Object.keys(require.cache)) {
          if (this.isDatabaseModule(key)) {
            moduleKeysToDelete.push(key);
          }
        }

        // Delete modules from cache
        for (const key of moduleKeysToDelete) {
          delete require.cache[key];
          this.performanceMetrics.modulesCleared++;
        }

        logger.debug(`üßΩ Cleared ${moduleKeysToDelete.length} database modules from CommonJS cache`);
      } else {
        // In ES module environment, we rely on cache busting via query parameters
        // when importing modules in getScopedDatabaseClient
        logger.debug(`üßΩ ES module environment - using cache busting via query parameters`);
        this.performanceMetrics.modulesCleared++;
      }
    } catch (error) {
      logger.warn('‚ö†Ô∏è  Error clearing module cache:', error.message);
      // Non-fatal error, continue execution
    }
  }

  /**
   * Legacy method for backward compatibility
   * Clear Node.js module cache for database-related modules
   * This is CRITICAL for test isolation
   */
  async clearDatabaseModuleCache() {
    const modulesToClear = [
      '../lib/database.js',
      '../lib/connection-manager.js',
      '../lib/enterprise-database-integration.js',
      '../scripts/migrate.js'
    ];

    for (const modulePath of modulesToClear) {
      try {
        // Convert relative path to absolute
        const absolutePath = new URL(modulePath, import.meta.url).href;

        // Delete from Node's require cache if it exists
        if (typeof require !== 'undefined' && require.cache) {
          try {
            const resolved = require.resolve(absolutePath);
            delete require.cache[resolved];
          } catch (resolveError) {
            // Module may not be resolvable, which is fine
            logger.debug(`Module not resolvable: ${modulePath}`);
          }
        }

        // Clear from ES module cache
        // Note: ES modules don't have a standard way to clear cache,
        // but we can track our own imports
        this.moduleCache.delete(absolutePath);

        logger.debug(`üì¶ Cleared legacy module cache for: ${modulePath}`);
      } catch (error) {
        // Module may not be loaded yet, which is fine
        logger.debug(`üì¶ Module not in cache: ${modulePath}`);
      }
    }

    // Also call the new method for comprehensive clearing
    await this.clearModuleCache();
  }

  /**
   * Check if a module path is database-related
   * @private
   */
  isDatabaseModule(modulePath) {
    const dbModulePatterns = [
      /\/lib\/database\.js$/,
      /\/lib\/logger\.js$/,
      /\/lib\/connection-manager\.js$/,
      /\/lib\/enterprise-database-integration\.js$/,
      /\/scripts\/migrate\.js$/,
      /@libsql\/client/,
      /database/i
    ];

    return dbModulePatterns.some(pattern => pattern.test(modulePath));
  }

  /**
   * Capture snapshot of current module cache state
   * @private
   */
  captureModuleSnapshot() {
    const snapshot = new Map();

    try {
      // Check if we're in a CommonJS environment with require.cache
      if (typeof require !== 'undefined' && require.cache) {
        for (const [key, module] of Object.entries(require.cache)) {
          if (this.isDatabaseModule(key)) {
            snapshot.set(key, {
              filename: module.filename,
              loaded: module.loaded,
              timestamp: Date.now()
            });
          }
        }

        this.performanceMetrics.modulesCached += snapshot.size;

        logger.debug(`üì∏ Captured module snapshot: ${snapshot.size} modules`);
      } else {
        // In ES module environment, we can't snapshot the cache in the same way
        logger.debug(`üì∏ ES module environment - snapshot not available`);
      }
    } catch (error) {
      logger.warn('‚ö†Ô∏è  Error capturing module snapshot:', error.message);
    }

    return snapshot;
  }

  /**
   * Close all database connections for a scope
   * @private
   */
  async closeConnections(scope) {
    if (!scope.connections.size) {
      return true;
    }

    logger.debug(`üîå Closing ${scope.connections.size} connections for scope ${scope.id}`);

    const closePromises = Array.from(scope.connections).map(async (connection) => {
      try {
        if (connection && typeof connection.close === 'function') {
          await Promise.race([
            connection.close(),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Connection close timeout')),
                        scope.options.connectionTimeout)
            )
          ]);

          // Remove from global registry
          this.globalConnectionRegistry.delete(connection);
          this.performanceMetrics.connectionsClosed++;

          return true;
        }

        return false;
      } catch (error) {
        logger.warn(`‚ö†Ô∏è  Error closing connection in scope ${scope.id}:`, error.message);
        return false;
      }
    });

    const results = await Promise.allSettled(closePromises);
    scope.connections.clear();

    const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
    const totalCount = results.length;

    logger.debug(`üîå Closed ${successCount}/${totalCount} connections for scope ${scope.id}`);

    return successCount === totalCount;
  }

  /**
   * Update average cleanup time metric
   * @private
   */
  updateAverageCleanupTime(newTime) {
    const currentAvg = this.performanceMetrics.averageCleanupTime;
    const count = this.performanceMetrics.scopesDestroyed;

    if (count === 1) {
      this.performanceMetrics.averageCleanupTime = newTime;
    } else {
      this.performanceMetrics.averageCleanupTime =
        ((currentAvg * (count - 1)) + newTime) / count;
    }
  }

  /**
   * Emergency cleanup - destroy all active scopes
   * @returns {Promise<boolean>} True if all scopes were cleaned up
   */
  async emergencyCleanup() {
    logger.warn('üö® Performing emergency cleanup of all test scopes');

    const scopeIds = Array.from(this.activeScopes.keys());
    const cleanupPromises = scopeIds.map(scopeId => this.destroyScope(scopeId));

    const results = await Promise.allSettled(cleanupPromises);
    const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;

    // Force clear any remaining global connections
    for (const connection of this.globalConnectionRegistry) {
      try {
        if (connection && typeof connection.close === 'function') {
          await connection.close();
        }
      } catch (error) {
        logger.warn('‚ö†Ô∏è  Error in emergency connection cleanup:', error.message);
      }
    }

    this.globalConnectionRegistry.clear();
    this.activeScopes.clear();
    this.currentTestId = null;

    // Update metrics
    this.performanceMetrics.emergencyCleanups++;
    this.performanceMetrics.lastCleanupTime = new Date().toISOString();

    logger.warn(`üö® Emergency cleanup complete: ${successCount}/${scopeIds.length} scopes cleaned`);

    return successCount === scopeIds.length;
  }

  /**
   * Get current isolation manager status and metrics
   * @returns {Object} Status and performance metrics
   */
  getStatus() {
    return {
      activeScopes: this.activeScopes.size,
      activeScopeIds: Array.from(this.activeScopes.keys()),
      globalConnections: this.globalConnectionRegistry.size,
      performanceMetrics: { ...this.performanceMetrics },
      scopeDetails: Array.from(this.activeScopes.entries()).map(([id, scope]) => ({
        id,
        testName: scope.testName,
        createdAt: scope.createdAt,
        connections: scope.connections.size,
        options: scope.options
      })),
      isTestMode: this.isTestMode,
      currentTestId: this.currentTestId,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Validate that a scope is properly isolated
   * @param {string} scopeId - Scope ID to validate
   * @returns {Promise<Object>} Validation results
   */
  async validateScopeIsolation(scopeId) {
    const scope = this.activeScopes.get(scopeId);
    if (!scope) {
      return { valid: false, error: 'Scope not found' };
    }

    try {
      // Test that we can get a fresh database client
      const client = await this.getScopedDatabaseClient(scopeId);

      // Test basic database operation
      const result = await client.execute('SELECT 1 as test');

      const validation = {
        valid: true,
        scopeId,
        testName: scope.testName,
        connectionCount: scope.connections.size,
        canExecuteQueries: !!(result && result.rows && result.rows.length > 0),
        modulesClearedCount: this.performanceMetrics.modulesCleared,
        timestamp: new Date().toISOString()
      };

      logger.debug(`‚úÖ Scope isolation validated for ${scopeId}:`, validation);

      return validation;
    } catch (error) {
      const validation = {
        valid: false,
        scopeId,
        error: error.message,
        timestamp: new Date().toISOString()
      };

      logger.error(`‚ùå Scope isolation validation failed for ${scopeId}:`, validation);

      return validation;
    }
  }

  /**
   * Get fresh database module by dynamic import
   * Bypasses module cache when possible
   */
  async getFreshDatabaseModule() {
    // Add timestamp to force fresh import in development/test
    const timestamp = this.isTestMode ? `?t=${Date.now()}` : '';
    const moduleUrl = new URL('../lib/database.js', import.meta.url).href;

    try {
      // Dynamic import with cache busting
      const module = await import(`${moduleUrl}${timestamp}`);
      return module;
    } catch (error) {
      // Fallback to regular import if cache busting fails
      logger.debug('Cache busting import failed, using regular import');
      return await import('../lib/database.js');
    }
  }

  /**
   * Legacy method - Clean up a specific test scope
   */
  async cleanupTestScope(testId) {
    logger.debug(`üìã Legacy cleanup for test scope: ${testId}`);

    // Use the new destroyScope method
    const result = await this.destroyScope(testId);

    // Reset singleton if this was the current scope
    if (testId === this.currentTestId) {
      try {
        const { resetDatabaseInstance } = await import('../lib/database.js');
        await resetDatabaseInstance();
      } catch (error) {
        logger.debug(`Error resetting database instance: ${error.message}`);
      }
      this.currentTestId = null;
    }

    logger.debug(`üìã Legacy test scope cleaned up: ${testId}`);
    return result;
  }

  /**
   * Legacy method - Clean up all test scopes
   */
  async cleanupAllScopes() {
    logger.debug('üìã Legacy cleanup of all test scopes');

    // Use the new emergency cleanup method
    const result = await this.emergencyCleanup();

    // Clear module cache one more time
    await this.clearDatabaseModuleCache();

    logger.debug('üìã Legacy cleanup complete');
    return result;
  }

  /**
   * Legacy method - Get statistics for debugging
   */
  getStats() {
    const status = this.getStatus();

    // Convert to legacy format for backward compatibility
    return {
      isTestMode: status.isTestMode,
      currentTestId: status.currentTestId,
      activeScopeCount: status.activeScopes,
      activeConnectionCount: status.globalConnections,
      scopes: status.scopeDetails.map(scope => ({
        id: scope.id,
        connectionCount: scope.connections,
        duration: scope.createdAt ? Date.now() - new Date(scope.createdAt).getTime() : 0,
        migrationCompleted: false // Legacy field
      }))
    };
  }

  /**
   * Ensure complete isolation for integration tests
   * This is the main entry point for test setup
   */
  async ensureTestIsolation(testName) {
    // Create new scope for this test
    const scope = await this.createTestScope(testName);

    // Clear all module caches
    await this.clearDatabaseModuleCache();

    // Force garbage collection if available (V8 only)
    if (global.gc) {
      global.gc();
    }

    return scope;
  }

  /**
   * Complete test and clean up
   * This is the main entry point for test teardown
   */
  async completeTest() {
    if (!this.currentTestId) {
      return; // No active test
    }

    const testId = this.currentTestId;
    await this.cleanupTestScope(testId);

    // Clear module cache after test
    await this.clearDatabaseModuleCache();

    logger.debug(`üìã Test completed and cleaned up: ${testId}`);
  }
}

// Export singleton instance for test use
let testIsolationManagerInstance = null;

/**
 * Get test isolation manager singleton instance
 * @returns {TestIsolationManager} Test isolation manager instance
 */
export function getTestIsolationManager() {
  if (!testIsolationManagerInstance) {
    testIsolationManagerInstance = new TestIsolationManager();
  }
  return testIsolationManagerInstance;
}

/**
 * Reset test isolation manager for testing
 * @returns {Promise<void>}
 */
export async function resetTestIsolationManager() {
  if (testIsolationManagerInstance) {
    await testIsolationManagerInstance.emergencyCleanup();
  }
  testIsolationManagerInstance = null;
}

// Convenience exports for common operations
export { TestIsolationManager };

/**
 * Create a new isolated test scope
 * @param {string} testName - Name of the test
 * @param {Object} options - Configuration options
 * @returns {Promise<string>} Scope ID
 */
export async function createTestScope(testName, options = {}) {
  const manager = getTestIsolationManager();
  return manager.createScope(testName, options);
}

/**
 * Destroy a test scope and clean up resources
 * @param {string} scopeId - Scope ID to destroy
 * @returns {Promise<boolean>} True if cleanup was successful
 */
export async function destroyTestScope(scopeId) {
  const manager = getTestIsolationManager();
  return manager.destroyScope(scopeId);
}

/**
 * Get a database client for a specific test scope (supports both new and legacy API)
 * @param {string} scopeId - Scope ID (optional for legacy API)
 * @returns {Promise<Object>} Isolated database client
 */
export async function getScopedDatabaseClient(scopeId) {
  const manager = getTestIsolationManager();
  return manager.getScopedDatabaseClient(scopeId);
}

/**
 * Validate that a test scope is properly isolated
 * @param {string} scopeId - Scope ID to validate
 * @returns {Promise<Object>} Validation results
 */
export async function validateTestScopeIsolation(scopeId) {
  const manager = getTestIsolationManager();
  return manager.validateScopeIsolation(scopeId);
}

/**
 * Get test isolation manager status and metrics
 * @returns {Object} Status and performance metrics
 */
export function getTestIsolationStatus() {
  const manager = getTestIsolationManager();
  return manager.getStatus();
}

/**
 * Perform emergency cleanup of all test scopes
 * @returns {Promise<boolean>} True if all scopes were cleaned up
 */
export async function emergencyCleanupTestScopes() {
  const manager = getTestIsolationManager();
  return manager.emergencyCleanup();
}