import { sheets } from "@googleapis/sheets";
import { JWT } from "google-auth-library";
import { getDatabaseClient } from "./database.js";
import { processDatabaseResult } from "./bigint-serializer.js";

/**
 * Google Sheets Sync Service
 *
 * WALLET PASS TRACKING CLARIFICATION:
 * -----------------------------------
 * This service tracks WALLET PASS GENERATION, not scan source.
 *
 * What we CAN track:
 * - apple_pass_serial: Set when user adds ticket to Apple Wallet
 * - google_pass_id: Set when user adds ticket to Google Wallet
 * â†’ This shows adoption of digital wallet passes vs email QR codes
 *
 * What we CANNOT track:
 * - Whether a QR code was scanned from wallet vs email vs screenshot
 * - The device/app used to display the QR code during scanning
 * - The "source" of a scan (all QR codes look identical to scanner)
 *
 * Why qr_access_method is NOT used:
 * - It tracks JWT token format, not wallet adoption
 * - Same JWT is used in both email QR codes and wallet passes
 * - Scanner cannot distinguish between email and wallet display
 *
 * Therefore:
 * - "Digital Wallet Adoption" sheet shows pass generation statistics
 * - Higher adoption = more users added passes to Apple/Google Wallet
 * - This is useful for measuring digital engagement, not scan source
 *
 * For accurate wallet adoption metrics, see:
 * - api/admin/dashboard.js (uses apple_pass_serial/google_pass_id)
 * - lib/analytics-service.js getWalletAnalytics() method
 */

export class GoogleSheetsService {
  constructor() {
    this.sheets = null;
    this.auth = null;
    this.sheetId = process.env.GOOGLE_SHEET_ID;

    if (!this.sheetId) {
      throw new Error("GOOGLE_SHEET_ID environment variable is required");
    }
  }

  /**
   * Initialize Google Sheets client
   */
  async initialize() {
    if (this.sheets) return;

    try {
      // Validate required credentials
      if (!process.env.GOOGLE_SHEETS_SERVICE_ACCOUNT_EMAIL) {
        throw new Error("GOOGLE_SHEETS_SERVICE_ACCOUNT_EMAIL environment variable is required");
      }
      if (!process.env.GOOGLE_SHEETS_PRIVATE_KEY) {
        throw new Error("GOOGLE_SHEETS_PRIVATE_KEY environment variable is required");
      }

      // Create auth client using JWT (new recommended approach)
      // Using Sheets-specific env vars to avoid conflicts with Drive
      this.auth = new JWT({
        email: process.env.GOOGLE_SHEETS_SERVICE_ACCOUNT_EMAIL,
        key: process.env.GOOGLE_SHEETS_PRIVATE_KEY.replace(
          /\\n/g,
          "\n",
        ),
        scopes: ["https://www.googleapis.com/auth/spreadsheets"],
      });

      // Create sheets client
      this.sheets = sheets({ version: "v4", auth: this.auth });

      console.log("Google Sheets client initialized");
    } catch (error) {
      console.error("Failed to initialize Google Sheets:", error);
      throw error;
    }
  }

  /**
   * Create or update sheet structure
   */
  async setupSheets() {
    await this.initialize();

    const sheets = [
      {
        name: "Overview",
        headers: ["Metric", "Value", "Last Updated"],
      },
      {
        name: "All Registrations",
        headers: [
          "Ticket ID",
          "Order Number",
          "First Name",
          "Last Name",
          "Email",
          "Phone",
          "Ticket Type",
          "Event Date",
          "Status",
          "Checked In",
          "Check-in Time",
          "Purchase Date",
          "Price",
          "Purchaser Email",
          "Wallet Pass Type",
          "Has Wallet Pass",
          "Payment Method",
        ],
      },
      {
        name: "Check-in Status",
        headers: [
          "Ticket ID",
          "Name",
          "Email",
          "Ticket Type",
          "Checked In?",
          "Check-in Time",
          "Checked By",
          "Pass Delivery",
        ],
      },
      {
        name: "Summary by Type",
        headers: ["Ticket Type", "Total Sold", "Checked In", "Revenue"],
      },
      {
        name: "Daily Sales",
        headers: ["Date", "Tickets Sold", "Revenue", "Running Total"],
      },
      {
        name: "Digital Wallet Adoption",
        headers: [
          "Metric",
          "Apple Wallet",
          "Google Wallet",
          "Total Wallets",
          "Email/QR Only",
          "Total Tickets",
          "Wallet Adoption %",
        ],
      },
      {
        name: "Pivot: Revenue Analysis",
        headers: ["Generated by pivot tables - do not edit directly"],
      },
      {
        name: "Pivot: Attendance Tracking",
        headers: ["Generated by pivot tables - do not edit directly"],
      },
      {
        name: "Pivot: Wallet Adoption",
        headers: ["Generated by pivot tables - do not edit directly"],
      },
      {
        name: "Pivot: Customer Behavior",
        headers: ["Generated by pivot tables - do not edit directly"],
      },
    ];

    // Get existing sheets
    const spreadsheet = await this.sheets.spreadsheets.get({
      spreadsheetId: this.sheetId,
    });

    const existingSheets = spreadsheet.data.sheets.map(
      (s) => s.properties.title,
    );

    // Create missing sheets
    const requests = [];
    for (const sheet of sheets) {
      if (!existingSheets.includes(sheet.name)) {
        requests.push({
          addSheet: {
            properties: {
              title: sheet.name,
              gridProperties: {
                frozenRowCount: 1,
              },
            },
          },
        });
      }
    }

    if (requests.length > 0) {
      await this.sheets.spreadsheets.batchUpdate({
        spreadsheetId: this.sheetId,
        requestBody: { requests },
      });
    }

    // Set headers for each sheet
    for (const sheet of sheets) {
      await this.updateSheetData(sheet.name, [sheet.headers], "A1");
    }

    return true;
  }

  /**
   * Update sheet data
   */
  async updateSheetData(sheetName, values, range = "A1") {
    await this.initialize();

    const fullRange = `${sheetName}!${range}`;

    await this.sheets.spreadsheets.values.update({
      spreadsheetId: this.sheetId,
      range: fullRange,
      valueInputOption: "RAW",
      requestBody: { values },
    });
  }

  /**
   * Clear and update entire sheet
   */
  async replaceSheetData(sheetName, values) {
    await this.initialize();

    // Clear existing data (keep headers)
    await this.sheets.spreadsheets.values.clear({
      spreadsheetId: this.sheetId,
      range: `${sheetName}!A2:Z`,
    });

    // Update with new data
    if (values.length > 0) {
      await this.updateSheetData(sheetName, values, "A2");
    }
  }

  /**
   * Sync all data from database to sheets
   */
  async syncAllData() {
    const db = await getDatabaseClient();
    const timestamp = new Date().toLocaleString("en-US", {
      timeZone: process.env.SHEETS_TIMEZONE || "America/Denver",
    });

    try {
      console.log("Starting Google Sheets sync...");

      // 1. Update Overview
      await this.syncOverview(db, timestamp);

      // 2. Update All Registrations
      await this.syncRegistrations(db);

      // 3. Update Check-in Status
      await this.syncCheckinStatus(db);

      // 4. Update Summary by Type
      await this.syncSummaryByType(db);

      // 5. Update Daily Sales
      await this.syncDailySales(db);

      // 6. Update Digital Wallet Adoption
      await this.syncDigitalWalletAdoption(db);

      // 7. Setup filters and sorting
      await this.setupFiltersAndSorting();

      // 8. Setup pivot table data
      await this.setupPivotTables();

      console.log("Google Sheets sync completed");
      return { success: true, timestamp };
    } catch (error) {
      console.error("Google Sheets sync failed:", error);
      throw error;
    }
  }

  /**
   * Sync overview statistics
   */
  async syncOverview(db, timestamp) {
    const stats = await db.execute(`
      SELECT
        (SELECT COUNT(*) FROM tickets WHERE status = 'valid') as total_tickets,
        (SELECT COUNT(*) FROM tickets WHERE checked_in_at IS NOT NULL) as checked_in,
        (SELECT COUNT(DISTINCT transaction_id) FROM tickets) as total_orders,
        (SELECT SUM(total_amount) / 100.0 FROM transactions WHERE status = 'completed') as total_revenue,
        (SELECT COUNT(*) FROM tickets WHERE ticket_type LIKE '%workshop%') as workshop_tickets,
        (SELECT COUNT(*) FROM tickets WHERE ticket_type LIKE '%vip%') as vip_tickets
    `);

    const processedStats = processDatabaseResult(stats);
    const data = processedStats.rows[0];

    // Get wallet statistics (columns may not exist yet)
    let walletStats;
    try {
      walletStats = await db.execute(`
        SELECT
          COUNT(CASE WHEN wallet_source IS NOT NULL THEN 1 END) as wallet_checkins,
          COUNT(CASE WHEN qr_access_method = 'wallet' THEN 1 END) as wallet_access,
          COUNT(CASE WHEN qr_access_method = 'qr_code' THEN 1 END) as qr_access
        FROM tickets WHERE checked_in_at IS NOT NULL
      `);
      walletStats = processDatabaseResult(walletStats);
    } catch (e) {
      // Columns don't exist yet - use default values
      walletStats = {
        rows: [{ wallet_checkins: 0, wallet_access: 0, qr_access: 0 }],
      };
    }

    const walletData = walletStats.rows[0];
    const walletAdoption =
      data.checked_in > 0
        ? Math.round((walletData.wallet_checkins / data.checked_in) * 100)
        : 0;

    const overviewData = [
      ["Total Tickets Sold", data.total_tickets || 0, timestamp],
      ["Tickets Checked In", data.checked_in || 0, timestamp],
      [
        "Check-in Percentage",
        data.total_tickets > 0
          ? `${Math.round((data.checked_in / data.total_tickets) * 100)}%`
          : "0%",
        timestamp,
      ],
      ["Total Orders", data.total_orders || 0, timestamp],
      ["Total Revenue", `$${(data.total_revenue || 0).toFixed(2)}`, timestamp],
      ["Workshop Tickets", data.workshop_tickets || 0, timestamp],
      ["VIP Tickets", data.vip_tickets || 0, timestamp],
      ["Wallet Check-ins", walletData.wallet_checkins || 0, timestamp],
      ["Wallet Adoption Rate", `${walletAdoption}%`, timestamp],
      ["Last Sync", timestamp, ""],
    ];

    await this.replaceSheetData("Overview", overviewData);
  }

  /**
   * Sync all registrations
   */
  async syncRegistrations(db) {
    const registrations = await db.execute(`
      SELECT
        t.ticket_id,
        tr.uuid as order_number,
        t.attendee_first_name,
        t.attendee_last_name,
        t.attendee_email,
        t.attendee_phone,
        t.ticket_type,
        t.event_date,
        t.status,
        CASE WHEN t.checked_in_at IS NOT NULL THEN 'Yes' ELSE 'No' END as checked_in,
        t.checked_in_at,
        t.created_at as purchase_date,
        t.price_cents / 100.0 as price,
        tr.customer_email as purchaser_email,
        CASE
          WHEN t.apple_pass_serial IS NOT NULL THEN 'apple_wallet'
          WHEN t.google_pass_id IS NOT NULL THEN 'google_wallet'
          ELSE NULL
        END as wallet_pass_added,
        CASE
          WHEN t.apple_pass_serial IS NOT NULL OR t.google_pass_id IS NOT NULL THEN 'Yes'
          ELSE 'No'
        END as has_wallet_pass,
        tr.payment_processor
      FROM tickets t
      JOIN transactions tr ON t.transaction_id = tr.id
      ORDER BY t.created_at DESC
    `);

    const processedRegistrations = processDatabaseResult(registrations);
    const data = processedRegistrations.rows.map((row) => [
      row.ticket_id,
      row.order_number,
      row.attendee_first_name || "",
      row.attendee_last_name || "",
      row.attendee_email || "",
      row.attendee_phone || "",
      this.formatTicketType(row.ticket_type),
      this.formatDate(row.event_date),
      row.status,
      row.checked_in,
      this.formatDateTime(row.checked_in_at),
      this.formatDateTime(row.purchase_date),
      `$${(row.price || 0).toFixed(2)}`,
      row.purchaser_email || "",
      row.wallet_pass_added === 'apple_wallet' ? 'Apple Wallet' :
        row.wallet_pass_added === 'google_wallet' ? 'Google Wallet' : 'None',
      row.has_wallet_pass || "No",
      this.formatPaymentMethod(row.payment_processor),
    ]);

    await this.replaceSheetData("All Registrations", data);
  }

  /**
   * Sync check-in status
   */
  async syncCheckinStatus(db) {
    const checkins = await db.execute(`
      SELECT
        ticket_id,
        attendee_first_name || ' ' || attendee_last_name as name,
        attendee_email,
        ticket_type,
        CASE WHEN checked_in_at IS NOT NULL THEN 'Yes' ELSE 'No' END as checked_in,
        checked_in_at,
        checked_in_by,
        CASE
          WHEN apple_pass_serial IS NOT NULL THEN 'Apple Wallet'
          WHEN google_pass_id IS NOT NULL THEN 'Google Wallet'
          ELSE 'Email/QR Code'
        END as pass_delivery_method
      FROM tickets
      WHERE status = 'valid'
      ORDER BY checked_in_at DESC NULLS LAST, ticket_id
    `);

    const processedCheckins = processDatabaseResult(checkins);
    const data = processedCheckins.rows.map((row) => [
      row.ticket_id,
      row.name?.trim() || "N/A", // Use optional chaining to handle null names
      row.attendee_email || "",
      this.formatTicketType(row.ticket_type),
      row.checked_in,
      this.formatDateTime(row.checked_in_at),
      row.checked_in_by || "",
      row.pass_delivery_method || "Email/QR Code",
    ]);

    await this.replaceSheetData("Check-in Status", data);
  }

  /**
   * Sync summary by ticket type
   */
  async syncSummaryByType(db) {
    const summary = await db.execute(`
      SELECT
        ticket_type,
        COUNT(*) as total_sold,
        COUNT(CASE WHEN checked_in_at IS NOT NULL THEN 1 END) as checked_in,
        SUM(price_cents) / 100.0 as revenue
      FROM tickets
      WHERE status = 'valid'
      GROUP BY ticket_type
      ORDER BY total_sold DESC
    `);

    const processedSummary = processDatabaseResult(summary);
    const data = processedSummary.rows.map((row) => [
      this.formatTicketType(row.ticket_type),
      row.total_sold,
      row.checked_in,
      `$${(row.revenue || 0).toFixed(2)}`,
    ]);

    await this.replaceSheetData("Summary by Type", data);
  }

  /**
   * Sync daily sales
   */
  async syncDailySales(db) {
    const sales = await db.execute(`
      SELECT
        date(created_at) as sale_date,
        COUNT(*) as tickets_sold,
        SUM(price_cents) / 100.0 as revenue
      FROM tickets
      WHERE status = 'valid'
      GROUP BY date(created_at)
      ORDER BY sale_date DESC
    `);

    const processedSales = processDatabaseResult(sales);
    let runningTotal = 0;
    const data = processedSales.rows
      .reverse()  // Reverse to oldest-first for chronological running totals
      .map((row) => {
        runningTotal += row.revenue || 0;
        return [
          this.formatDate(row.sale_date),
          row.tickets_sold,
          `$${(row.revenue || 0).toFixed(2)}`,
          `$${runningTotal.toFixed(2)}`,
        ];
      });
      // Keep in oldest-first order for running totals to make sense

    await this.replaceSheetData("Daily Sales", data);
  }

  /**
   * Sync digital wallet adoption statistics
   *
   * Tracks how many users added tickets to Apple Wallet or Google Wallet.
   * This is measured by checking for apple_pass_serial and google_pass_id.
   *
   * Note: This does NOT track scan source (email vs wallet display).
   * See documentation at top of file for clarification.
   */
  async syncDigitalWalletAdoption(db) {
    const adoption = await db.execute(`
      SELECT
        COUNT(*) as total_tickets,
        COUNT(CASE WHEN apple_pass_serial IS NOT NULL THEN 1 END) as apple_wallet,
        COUNT(CASE WHEN google_pass_id IS NOT NULL THEN 1 END) as google_wallet,
        COUNT(CASE WHEN apple_pass_serial IS NOT NULL OR google_pass_id IS NOT NULL THEN 1 END) as total_wallets,
        COUNT(CASE WHEN apple_pass_serial IS NULL AND google_pass_id IS NULL THEN 1 END) as email_qr_only
      FROM tickets
      WHERE status = 'valid'
    `);

    const processedAdoption = processDatabaseResult(adoption);
    const stats = processedAdoption.rows[0];

    const walletAdoptionRate = stats.total_tickets > 0
      ? Math.round((stats.total_wallets / stats.total_tickets) * 100)
      : 0;

    const data = [
      [
        "Pass Distribution",
        stats.apple_wallet || 0,
        stats.google_wallet || 0,
        stats.total_wallets || 0,
        stats.email_qr_only || 0,
        stats.total_tickets || 0,
        `${walletAdoptionRate}%`,
      ],
    ];

    await this.replaceSheetData("Digital Wallet Adoption", data);
  }

  /**
   * Format ticket type for display
   */
  formatTicketType(type) {
    const typeMap = {
      "vip-pass": "VIP Pass",
      "weekend-pass": "Weekend Pass",
      "friday-pass": "Friday Pass",
      "saturday-pass": "Saturday Pass",
      "sunday-pass": "Sunday Pass",
      "workshop-beginner": "Beginner Workshop",
      "workshop-intermediate": "Intermediate Workshop",
      "workshop-advanced": "Advanced Workshop",
      workshop: "Workshop",
      "social-dance": "Social Dance",
      "general-admission": "General Admission",
    };

    return typeMap[type] || type || "Unknown";
  }

  /**
   * Format date for display
   */
  formatDate(dateStr) {
    if (!dateStr) return "";

    try {
      // Parse the date string and create a date at noon to avoid timezone shifts
      const date = new Date(dateStr + "T12:00:00");
      return date.toLocaleDateString("en-US", {
        timeZone: process.env.SHEETS_TIMEZONE || "America/Denver",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
      });
    } catch (error) {
      return dateStr;
    }
  }

  /**
   * Format datetime for display
   */
  formatDateTime(dateTimeStr) {
    if (!dateTimeStr) return "";

    try {
      const date = new Date(dateTimeStr);
      return date.toLocaleString("en-US", {
        timeZone: process.env.SHEETS_TIMEZONE || "America/Denver",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
      });
    } catch (error) {
      return dateTimeStr;
    }
  }

  /**
   * Format payment method for display
   */
  formatPaymentMethod(method) {
    const methodMap = {
      stripe: "Stripe",
      paypal: "PayPal",
      venmo: "Venmo",
      cash: "Cash",
      card_terminal: "Card Terminal",
      comp: "Comp",
    };

    return methodMap[method] || method || "Unknown";
  }

  /**
   * Get sheet ID by name
   */
  async getSheetId(sheetName) {
    const spreadsheet = await this.sheets.spreadsheets.get({
      spreadsheetId: this.sheetId,
    });

    const sheet = spreadsheet.data.sheets.find(
      (s) => s.properties.title === sheetName
    );

    return sheet ? sheet.properties.sheetId : null;
  }

  /**
   * Setup filters and sorting for data sheets
   */
  async setupFiltersAndSorting() {
    await this.initialize();

    console.log("Setting up filters and sorting...");

    try {
      // Define sheet configurations
      const sheetConfigs = [
        {
          name: "All Registrations",
          columns: 17, // A-Q (Ticket ID through Payment Method)
          sortColumn: 11, // Column L (Purchase Date) - 0-indexed
          sortOrder: "DESCENDING",
          dataValidations: [
            { column: 8, values: ["valid", "cancelled", "transferred"] }, // Status
            { column: 9, values: ["Yes", "No"] }, // Checked In
            { column: 14, values: ["Apple Wallet", "Google Wallet", "None"] }, // Wallet Pass Type
            { column: 15, values: ["Yes", "No"] }, // Has Wallet Pass
            { column: 16, values: ["Stripe", "PayPal", "Venmo", "Cash", "Card Terminal", "Comp"] }, // Payment Method
          ],
        },
        {
          name: "Check-in Status",
          columns: 8, // A-H
          sortColumn: 5, // Column F (Check-in Time) - 0-indexed
          sortOrder: "DESCENDING",
          dataValidations: [
            { column: 4, values: ["Yes", "No"] }, // Checked In?
            { column: 7, values: ["Apple Wallet", "Google Wallet", "Email/QR Code"] }, // Pass Delivery
          ],
        },
        {
          name: "Daily Sales",
          columns: 4, // A-D
          sortColumn: 0, // Column A (Date) - 0-indexed
          sortOrder: "ASCENDING",
          dataValidations: [],
        },
      ];

      const requests = [];

      // Process each sheet
      for (const config of sheetConfigs) {
        const sheetId = await this.getSheetId(config.name);
        if (!sheetId && sheetId !== 0) {
          console.warn(`Sheet "${config.name}" not found, skipping...`);
          continue;
        }

        // 1. Set basic filter on all columns
        requests.push({
          setBasicFilter: {
            filter: {
              range: {
                sheetId: sheetId,
                startRowIndex: 0,
                startColumnIndex: 0,
                endColumnIndex: config.columns,
              },
            },
          },
        });

        // 2. Add data validation dropdowns for categorical columns
        for (const validation of config.dataValidations) {
          requests.push({
            setDataValidation: {
              range: {
                sheetId: sheetId,
                startRowIndex: 1, // Start from row 2 (after header)
                startColumnIndex: validation.column,
                endColumnIndex: validation.column + 1,
              },
              rule: {
                condition: {
                  type: "ONE_OF_LIST",
                  values: validation.values.map((v) => ({ userEnteredValue: v })),
                },
                showCustomUi: true,
                strict: false, // Allow values not in list (for flexibility)
              },
            },
          });
        }

        // 3. Set default sort order
        requests.push({
          sortRange: {
            range: {
              sheetId: sheetId,
              startRowIndex: 1, // Start from row 2 (after header)
              startColumnIndex: 0,
              endColumnIndex: config.columns,
            },
            sortSpecs: [
              {
                dimensionIndex: config.sortColumn,
                sortOrder: config.sortOrder,
              },
            ],
          },
        });

        // 4. Freeze header row and first column (Ticket ID / Date)
        requests.push({
          updateSheetProperties: {
            properties: {
              sheetId: sheetId,
              gridProperties: {
                frozenRowCount: 1,
                frozenColumnCount: 1,
              },
            },
            fields: "gridProperties.frozenRowCount,gridProperties.frozenColumnCount",
          },
        });
      }

      // Execute all requests in batch
      if (requests.length > 0) {
        await this.sheets.spreadsheets.batchUpdate({
          spreadsheetId: this.sheetId,
          requestBody: { requests },
        });
        console.log(`Applied filters and sorting to ${sheetConfigs.length} sheets`);
      }

      return true;
    } catch (error) {
      console.error("Error setting up filters and sorting:", error);
      throw error;
    }
  }

  /**
   * Setup pivot tables for analytics
   *
   * Note: Due to complexity of Google Sheets API pivot tables,
   * we create pre-computed aggregate data sheets that provide
   * the same analytical insights as pivot tables would.
   */
  async setupPivotTables() {
    await this.initialize();

    console.log("Setting up pivot table data...");

    try {
      const db = await getDatabaseClient();

      // Setup each pivot analysis sheet
      await this.setupRevenuePivots(db);
      await this.setupAttendancePivots(db);
      await this.setupWalletPivots(db);
      await this.setupCustomerBehaviorPivots(db);

      console.log("Pivot table data setup completed");
      return true;
    } catch (error) {
      console.error("Error setting up pivot tables:", error);
      throw error;
    }
  }

  /**
   * Setup Revenue Analysis pivot data
   */
  async setupRevenuePivots(db) {
    const data = [];

    // Table 1: Revenue by Ticket Type
    data.push(["=== REVENUE BY TICKET TYPE ==="]);
    data.push(["Ticket Type", "Total Revenue", "Tickets Sold", "Avg Price"]);

    const revenueByType = await db.execute(`
      SELECT
        ticket_type,
        SUM(price_cents) / 100.0 as total_revenue,
        COUNT(*) as tickets_sold,
        AVG(price_cents) / 100.0 as avg_price
      FROM tickets
      WHERE status = 'valid'
      GROUP BY ticket_type
      ORDER BY total_revenue DESC
    `);

    const processedRevByType = processDatabaseResult(revenueByType);
    processedRevByType.rows.forEach((row) => {
      data.push([
        this.formatTicketType(row.ticket_type),
        `$${(row.total_revenue || 0).toFixed(2)}`,
        row.tickets_sold,
        `$${(row.avg_price || 0).toFixed(2)}`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 2: Revenue by Payment Method
    data.push(["=== REVENUE BY PAYMENT METHOD ==="]);
    data.push(["Payment Method", "Total Revenue", "Transactions", "% of Total"]);

    const revenueByPayment = await db.execute(`
      SELECT
        tr.payment_processor,
        SUM(tr.total_amount) / 100.0 as total_revenue,
        COUNT(DISTINCT tr.id) as transactions
      FROM transactions tr
      WHERE tr.status = 'completed'
      GROUP BY tr.payment_processor
      ORDER BY total_revenue DESC
    `);

    const processedRevByPayment = processDatabaseResult(revenueByPayment);
    const totalRevenue = processedRevByPayment.rows.reduce(
      (sum, row) => sum + (row.total_revenue || 0),
      0
    );

    processedRevByPayment.rows.forEach((row) => {
      const percentage = totalRevenue > 0
        ? ((row.total_revenue / totalRevenue) * 100).toFixed(1)
        : 0;
      data.push([
        this.formatPaymentMethod(row.payment_processor),
        `$${(row.total_revenue || 0).toFixed(2)}`,
        row.transactions,
        `${percentage}%`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 3: Revenue Over Time (Monthly)
    data.push(["=== REVENUE OVER TIME (MONTHLY) ==="]);
    data.push(["Month", "Revenue", "Tickets Sold"]);

    const revenueOverTime = await db.execute(`
      SELECT
        strftime('%Y-%m', created_at) as month,
        SUM(price_cents) / 100.0 as revenue,
        COUNT(*) as tickets_sold
      FROM tickets
      WHERE status = 'valid'
      GROUP BY strftime('%Y-%m', created_at)
      ORDER BY month DESC
    `);

    const processedRevOverTime = processDatabaseResult(revenueOverTime);
    processedRevOverTime.rows.forEach((row) => {
      data.push([
        row.month,
        `$${(row.revenue || 0).toFixed(2)}`,
        row.tickets_sold,
      ]);
    });

    await this.replaceSheetData("Pivot: Revenue Analysis", data);
  }

  /**
   * Setup Attendance Tracking pivot data
   */
  async setupAttendancePivots(db) {
    const data = [];

    // Table 1: Check-ins by Ticket Type
    data.push(["=== CHECK-INS BY TICKET TYPE ==="]);
    data.push(["Ticket Type", "Total Sold", "Checked In", "Not Checked In", "Check-in %"]);

    const checkinsByType = await db.execute(`
      SELECT
        ticket_type,
        COUNT(*) as total_sold,
        COUNT(CASE WHEN checked_in_at IS NOT NULL THEN 1 END) as checked_in,
        COUNT(CASE WHEN checked_in_at IS NULL THEN 1 END) as not_checked_in
      FROM tickets
      WHERE status = 'valid'
      GROUP BY ticket_type
      ORDER BY total_sold DESC
    `);

    const processedCheckins = processDatabaseResult(checkinsByType);
    processedCheckins.rows.forEach((row) => {
      const checkinPct = row.total_sold > 0
        ? ((row.checked_in / row.total_sold) * 100).toFixed(1)
        : 0;
      data.push([
        this.formatTicketType(row.ticket_type),
        row.total_sold,
        row.checked_in,
        row.not_checked_in,
        `${checkinPct}%`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 2: Check-ins by Event Date
    data.push(["=== CHECK-INS BY EVENT DATE ==="]);
    data.push(["Event Date", "Total Tickets", "Checked In", "Check-in %"]);

    const checkinsByDate = await db.execute(`
      SELECT
        date(event_date) as event_date,
        COUNT(*) as total_tickets,
        COUNT(CASE WHEN checked_in_at IS NOT NULL THEN 1 END) as checked_in
      FROM tickets
      WHERE status = 'valid'
      GROUP BY date(event_date)
      ORDER BY event_date
    `);

    const processedByDate = processDatabaseResult(checkinsByDate);
    processedByDate.rows.forEach((row) => {
      const checkinPct = row.total_tickets > 0
        ? ((row.checked_in / row.total_tickets) * 100).toFixed(1)
        : 0;
      data.push([
        this.formatDate(row.event_date),
        row.total_tickets,
        row.checked_in,
        `${checkinPct}%`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 3: Check-in Timeline (by hour)
    data.push(["=== CHECK-IN TIMELINE (BY HOUR) ==="]);
    data.push(["Hour", "Check-ins"]);

    const checkinTimeline = await db.execute(`
      SELECT
        strftime('%H:00', checked_in_at) as hour,
        COUNT(*) as checkins
      FROM tickets
      WHERE checked_in_at IS NOT NULL
      GROUP BY strftime('%H:00', checked_in_at)
      ORDER BY hour
    `);

    const processedTimeline = processDatabaseResult(checkinTimeline);
    processedTimeline.rows.forEach((row) => {
      data.push([row.hour || "Unknown", row.checkins]);
    });

    await this.replaceSheetData("Pivot: Attendance Tracking", data);
  }

  /**
   * Setup Wallet Adoption pivot data
   */
  async setupWalletPivots(db) {
    const data = [];

    // Table 1: Wallet Type Distribution
    data.push(["=== WALLET TYPE DISTRIBUTION ==="]);
    data.push(["Wallet Type", "Count", "% of Total"]);

    const walletDistribution = await db.execute(`
      SELECT
        CASE
          WHEN apple_pass_serial IS NOT NULL THEN 'Apple Wallet'
          WHEN google_pass_id IS NOT NULL THEN 'Google Wallet'
          ELSE 'No Wallet'
        END as wallet_type,
        COUNT(*) as count
      FROM tickets
      WHERE status = 'valid'
      GROUP BY wallet_type
      ORDER BY count DESC
    `);

    const processedDist = processDatabaseResult(walletDistribution);
    const totalTickets = processedDist.rows.reduce(
      (sum, row) => sum + row.count,
      0
    );

    processedDist.rows.forEach((row) => {
      const percentage = totalTickets > 0
        ? ((row.count / totalTickets) * 100).toFixed(1)
        : 0;
      data.push([row.wallet_type, row.count, `${percentage}%`]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 2: Wallet Adoption Over Time (Weekly)
    data.push(["=== WALLET ADOPTION OVER TIME (WEEKLY) ==="]);
    data.push(["Week", "Total Tickets", "With Wallet", "Adoption %"]);

    const adoptionOverTime = await db.execute(`
      SELECT
        strftime('%Y-W%W', created_at) as week,
        COUNT(*) as total_tickets,
        COUNT(CASE WHEN apple_pass_serial IS NOT NULL OR google_pass_id IS NOT NULL THEN 1 END) as with_wallet
      FROM tickets
      WHERE status = 'valid'
      GROUP BY strftime('%Y-W%W', created_at)
      ORDER BY week DESC
      LIMIT 12
    `);

    const processedAdoption = processDatabaseResult(adoptionOverTime);
    processedAdoption.rows.forEach((row) => {
      const adoptionPct = row.total_tickets > 0
        ? ((row.with_wallet / row.total_tickets) * 100).toFixed(1)
        : 0;
      data.push([
        row.week,
        row.total_tickets,
        row.with_wallet,
        `${adoptionPct}%`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 3: Wallet Adoption by Ticket Type
    data.push(["=== WALLET ADOPTION BY TICKET TYPE ==="]);
    data.push(["Ticket Type", "Total Tickets", "With Wallet", "Adoption %"]);

    const adoptionByType = await db.execute(`
      SELECT
        ticket_type,
        COUNT(*) as total_tickets,
        COUNT(CASE WHEN apple_pass_serial IS NOT NULL OR google_pass_id IS NOT NULL THEN 1 END) as with_wallet
      FROM tickets
      WHERE status = 'valid'
      GROUP BY ticket_type
      ORDER BY total_tickets DESC
    `);

    const processedByType = processDatabaseResult(adoptionByType);
    processedByType.rows.forEach((row) => {
      const adoptionPct = row.total_tickets > 0
        ? ((row.with_wallet / row.total_tickets) * 100).toFixed(1)
        : 0;
      data.push([
        this.formatTicketType(row.ticket_type),
        row.total_tickets,
        row.with_wallet,
        `${adoptionPct}%`,
      ]);
    });

    await this.replaceSheetData("Pivot: Wallet Adoption", data);
  }

  /**
   * Setup Customer Behavior pivot data
   */
  async setupCustomerBehaviorPivots(db) {
    const data = [];

    // Table 1: Tickets per Order
    data.push(["=== TICKETS PER ORDER ==="]);
    data.push(["Tickets per Order", "Number of Orders", "Avg Order Value"]);

    const ticketsPerOrder = await db.execute(`
      SELECT
        ticket_count,
        COUNT(*) as order_count,
        AVG(total_amount) / 100.0 as avg_order_value
      FROM (
        SELECT
          tr.id,
          tr.total_amount,
          COUNT(t.id) as ticket_count
        FROM transactions tr
        LEFT JOIN tickets t ON t.transaction_id = tr.id
        WHERE tr.status = 'completed'
        GROUP BY tr.id
      )
      GROUP BY ticket_count
      ORDER BY ticket_count
    `);

    const processedTicketsPerOrder = processDatabaseResult(ticketsPerOrder);
    processedTicketsPerOrder.rows.forEach((row) => {
      const ticketLabel = row.ticket_count === 1
        ? "1 ticket"
        : row.ticket_count >= 5
        ? "5+ tickets"
        : `${row.ticket_count} tickets`;
      data.push([
        ticketLabel,
        row.order_count,
        `$${(row.avg_order_value || 0).toFixed(2)}`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 2: Purchase Day Patterns
    data.push(["=== PURCHASE DAY PATTERNS ==="]);
    data.push(["Day of Week", "Orders", "Avg Order Value", "Total Revenue"]);

    const purchasePatterns = await db.execute(`
      SELECT
        CASE cast(strftime('%w', created_at) as integer)
          WHEN 0 THEN 'Sunday'
          WHEN 1 THEN 'Monday'
          WHEN 2 THEN 'Tuesday'
          WHEN 3 THEN 'Wednesday'
          WHEN 4 THEN 'Thursday'
          WHEN 5 THEN 'Friday'
          WHEN 6 THEN 'Saturday'
        END as day_of_week,
        COUNT(*) as orders,
        AVG(total_amount) / 100.0 as avg_order_value,
        SUM(total_amount) / 100.0 as total_revenue
      FROM transactions
      WHERE status = 'completed'
      GROUP BY strftime('%w', created_at)
      ORDER BY strftime('%w', created_at)
    `);

    const processedPatterns = processDatabaseResult(purchasePatterns);
    processedPatterns.rows.forEach((row) => {
      data.push([
        row.day_of_week,
        row.orders,
        `$${(row.avg_order_value || 0).toFixed(2)}`,
        `$${(row.total_revenue || 0).toFixed(2)}`,
      ]);
    });

    // Add spacing
    data.push([]);
    data.push([]);

    // Table 3: Popular Ticket Type Combinations (Top 10 orders with multiple tickets)
    data.push(["=== TOP TICKET TYPE COMBINATIONS (MULTI-TICKET ORDERS) ==="]);
    data.push(["Order Number", "Ticket Types", "Total Tickets", "Order Value"]);

    const combinations = await db.execute(`
      SELECT
        tr.uuid as order_number,
        GROUP_CONCAT(DISTINCT t.ticket_type) as ticket_types,
        COUNT(t.id) as ticket_count,
        tr.total_amount / 100.0 as order_value
      FROM transactions tr
      JOIN tickets t ON t.transaction_id = tr.id
      WHERE tr.status = 'completed'
      GROUP BY tr.id
      HAVING ticket_count > 1
      ORDER BY order_value DESC
      LIMIT 10
    `);

    const processedCombinations = processDatabaseResult(combinations);
    processedCombinations.rows.forEach((row) => {
      const types = row.ticket_types
        ? row.ticket_types.split(',')
            .map((t) => this.formatTicketType(t))
            .join(', ')
        : 'N/A';
      data.push([
        row.order_number,
        types,
        row.ticket_count,
        `$${(row.order_value || 0).toFixed(2)}`,
      ]);
    });

    await this.replaceSheetData("Pivot: Customer Behavior", data);
  }

  /**
   * Apply formatting to sheet
   */
  async applyFormatting() {
    await this.initialize();

    const requests = [
      // Bold headers
      {
        repeatCell: {
          range: {
            sheetId: 0,
            startRowIndex: 0,
            endRowIndex: 1,
          },
          cell: {
            userEnteredFormat: {
              textFormat: { bold: true },
              backgroundColor: { red: 0.9, green: 0.9, blue: 0.9 },
            },
          },
          fields: "userEnteredFormat(textFormat,backgroundColor)",
        },
      },
      // Auto-resize columns
      {
        autoResizeDimensions: {
          dimensions: {
            sheetId: 0,
            dimension: "COLUMNS",
            startIndex: 0,
            endIndex: 20,
          },
        },
      },
    ];

    await this.sheets.spreadsheets.batchUpdate({
      spreadsheetId: this.sheetId,
      requestBody: { requests },
    });
  }
}

export default new GoogleSheetsService();
