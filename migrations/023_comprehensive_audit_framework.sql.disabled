-- Migration: Comprehensive Audit Framework
-- Description: Implements a complete audit trail system for data change tracking, admin access monitoring,
--              GDPR compliance, financial reconciliation, and configuration management across all
--              system operations with performance-optimized indexes and automatic triggers
-- Author: Database Administrator
-- Date: 2025-01-17

-- ============================================================================
-- STEP 1: Create Master Audit Log Table
-- ============================================================================

-- Comprehensive data change tracking table for all database modifications
CREATE TABLE IF NOT EXISTS audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- Event Identification
    audit_id TEXT UNIQUE NOT NULL,                    -- UUID for unique audit event identification
    event_id INTEGER,                                 -- Reference to events.id for multi-event support

    -- Change Tracking
    table_name TEXT NOT NULL,                         -- Table being audited
    record_id TEXT NOT NULL,                          -- Primary key of affected record
    operation TEXT NOT NULL CHECK(operation IN ('INSERT', 'UPDATE', 'DELETE')), -- DML operation type

    -- Data Changes
    old_values TEXT,                                  -- JSON: Previous values before change
    new_values TEXT,                                  -- JSON: New values after change
    changed_fields TEXT,                              -- JSON array: List of fields that changed

    -- User Context
    user_id TEXT,                                     -- User performing the operation
    user_email TEXT,                                  -- Email of user performing operation
    user_role TEXT,                                   -- Role/permission level of user
    session_id TEXT,                                  -- Session identifier for tracking

    -- Request Context
    ip_address TEXT,                                  -- Client IP address
    user_agent TEXT,                                  -- Browser/client information
    request_method TEXT,                              -- HTTP method (GET, POST, etc.)
    request_url TEXT,                                 -- API endpoint accessed

    -- Business Context
    transaction_reference TEXT,                       -- Reference to business transaction
    business_process TEXT,                            -- High-level business process (e.g., 'ticket_purchase', 'registration')
    risk_level TEXT DEFAULT 'low' CHECK(risk_level IN ('low', 'medium', 'high', 'critical')), -- Risk assessment

    -- Compliance & Metadata
    data_classification TEXT DEFAULT 'internal' CHECK(data_classification IN ('public', 'internal', 'confidential', 'restricted')),
    retention_period_days INTEGER DEFAULT 2555,       -- 7 years default retention for financial compliance
    gdpr_lawful_basis TEXT,                           -- GDPR article 6 lawful basis
    data_subject_email TEXT,                          -- Data subject for GDPR tracking

    -- Timing
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME,                              -- Auto-calculated based on retention_period_days

    -- Integrity
    checksum TEXT,                                    -- Data integrity verification
    source_system TEXT DEFAULT 'festival_platform'   -- System generating the audit entry
);

-- ============================================================================
-- STEP 2: Create Admin Access Log Table
-- ============================================================================

-- Enhanced admin endpoint access monitoring for security and compliance
CREATE TABLE IF NOT EXISTS admin_access_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- Access Event Identification
    access_id TEXT UNIQUE NOT NULL,                   -- UUID for unique access event
    session_id TEXT,                                  -- Admin session identifier

    -- Admin Context
    admin_email TEXT NOT NULL,                        -- Admin user email
    admin_role TEXT,                                  -- Admin role/permission level
    authentication_method TEXT,                       -- How admin authenticated (password, MFA, etc.)

    -- Access Details
    endpoint TEXT NOT NULL,                           -- API endpoint or page accessed
    http_method TEXT NOT NULL,                        -- HTTP method used
    request_payload_hash TEXT,                        -- Hash of request payload for security
    response_status INTEGER,                          -- HTTP response status
    response_size_bytes INTEGER,                      -- Response payload size

    -- Security Context
    ip_address TEXT NOT NULL,                         -- Client IP address
    user_agent TEXT,                                  -- Browser/client information
    geo_location TEXT,                                -- Geographic location of access
    risk_score INTEGER DEFAULT 0,                     -- Calculated risk score (0-100)
    security_flags TEXT,                              -- JSON: Security-related flags

    -- Timing & Performance
    access_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    response_time_ms INTEGER,                         -- Response time in milliseconds

    -- Business Context
    affected_resources TEXT,                          -- JSON: List of resources accessed/modified
    business_justification TEXT,                      -- Reason for access (for sensitive operations)
    approval_reference TEXT,                          -- Reference to approval workflow (if required)

    -- Event Classification
    access_type TEXT DEFAULT 'read' CHECK(access_type IN ('read', 'write', 'delete', 'admin', 'system')),
    sensitivity_level TEXT DEFAULT 'normal' CHECK(sensitivity_level IN ('low', 'normal', 'high', 'critical')),

    -- Compliance
    retention_period_days INTEGER DEFAULT 2555,       -- 7 years retention for security logs
    archived_at DATETIME                              -- When record was archived
);

-- ============================================================================
-- STEP 3: Create Data Processing Log Table (GDPR Compliance)
-- ============================================================================

-- GDPR and privacy compliance tracking for personal data processing
CREATE TABLE IF NOT EXISTS data_processing_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- Processing Event Identification
    processing_id TEXT UNIQUE NOT NULL,               -- UUID for unique processing event
    data_subject_email TEXT NOT NULL,                 -- Email of the data subject

    -- Legal Basis
    lawful_basis TEXT NOT NULL CHECK(lawful_basis IN (
        'consent',                                     -- Article 6(1)(a) - Consent
        'contract',                                    -- Article 6(1)(b) - Contract performance
        'legal_obligation',                            -- Article 6(1)(c) - Legal obligation
        'vital_interests',                             -- Article 6(1)(d) - Vital interests
        'public_task',                                 -- Article 6(1)(e) - Public task
        'legitimate_interests'                         -- Article 6(1)(f) - Legitimate interests
    )),

    -- Processing Details
    processing_purpose TEXT NOT NULL,                 -- Purpose of data processing
    data_categories TEXT NOT NULL,                    -- JSON: Categories of personal data processed
    processing_activity TEXT NOT NULL,                -- Specific processing activity

    -- Data Source & Recipients
    data_source TEXT NOT NULL,                        -- Where the data came from
    data_recipients TEXT,                             -- JSON: Who data was shared with
    third_country_transfers TEXT,                     -- JSON: Any transfers outside EU/UK

    -- Consent Management
    consent_obtained BOOLEAN DEFAULT FALSE,           -- Whether explicit consent was obtained
    consent_method TEXT,                              -- How consent was obtained
    consent_timestamp DATETIME,                       -- When consent was given
    consent_withdrawn_at DATETIME,                    -- When consent was withdrawn (if applicable)

    -- Data Subject Rights
    subject_request_type TEXT CHECK(subject_request_type IN (
        'access', 'rectification', 'erasure', 'restrict', 'portability', 'object', 'automated_decision'
    )),
    request_fulfilled BOOLEAN DEFAULT FALSE,          -- Whether data subject request was fulfilled
    fulfillment_date DATETIME,                        -- When request was fulfilled

    -- Technical Measures
    encryption_used BOOLEAN DEFAULT FALSE,            -- Whether data was encrypted
    pseudonymization_used BOOLEAN DEFAULT FALSE,      -- Whether data was pseudonymized
    anonymization_used BOOLEAN DEFAULT FALSE,         -- Whether data was anonymized

    -- Retention
    retention_period_days INTEGER NOT NULL,           -- How long data will be retained
    deletion_scheduled_date DATETIME,                 -- When data is scheduled for deletion
    actual_deletion_date DATETIME,                    -- When data was actually deleted

    -- Metadata
    processing_system TEXT DEFAULT 'festival_platform', -- System performing processing
    processor_name TEXT,                              -- Name of data processor (if different from controller)
    dpo_notified BOOLEAN DEFAULT FALSE,               -- Whether DPO was notified (if required)

    -- Timing
    processing_start DATETIME DEFAULT CURRENT_TIMESTAMP,
    processing_end DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- STEP 4: Create Financial Audit Log Table
-- ============================================================================

-- Enhanced financial reconciliation and audit trail for all monetary transactions
CREATE TABLE IF NOT EXISTS financial_audit_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- Financial Event Identification
    financial_audit_id TEXT UNIQUE NOT NULL,          -- UUID for unique financial event
    transaction_reference TEXT NOT NULL,              -- Reference to original transaction

    -- Transaction Details
    transaction_type TEXT NOT NULL CHECK(transaction_type IN (
        'sale', 'refund', 'partial_refund', 'chargeback', 'fee', 'adjustment', 'transfer'
    )),
    original_amount_cents INTEGER NOT NULL,           -- Original transaction amount
    processed_amount_cents INTEGER NOT NULL,          -- Actually processed amount
    currency TEXT NOT NULL DEFAULT 'USD',             -- Transaction currency

    -- Financial Status Tracking
    previous_status TEXT,                             -- Previous financial status
    new_status TEXT NOT NULL,                         -- New financial status
    status_reason TEXT,                               -- Reason for status change

    -- Payment Processing
    payment_processor TEXT NOT NULL,                  -- Stripe, PayPal, etc.
    processor_transaction_id TEXT,                    -- External processor transaction ID
    processor_fee_cents INTEGER DEFAULT 0,            -- Processing fees charged
    net_amount_cents INTEGER,                         -- Net amount after fees

    -- Reconciliation
    reconciliation_status TEXT DEFAULT 'pending' CHECK(reconciliation_status IN (
        'pending', 'matched', 'discrepancy', 'resolved', 'investigation'
    )),
    bank_statement_date DATE,                         -- Date transaction appears on bank statement
    bank_reference TEXT,                              -- Bank reference number
    reconciled_at DATETIME,                           -- When reconciliation was completed
    reconciled_by TEXT,                               -- Who performed reconciliation

    -- Risk & Fraud
    fraud_score INTEGER DEFAULT 0,                    -- Fraud risk score (0-100)
    risk_flags TEXT,                                  -- JSON: Risk and fraud flags
    manual_review_required BOOLEAN DEFAULT FALSE,     -- Whether manual review is needed
    review_completed BOOLEAN DEFAULT FALSE,           -- Whether review was completed
    reviewer_email TEXT,                              -- Who completed the review

    -- Tax & Compliance
    tax_amount_cents INTEGER DEFAULT 0,               -- Tax amount
    tax_rate DECIMAL(5,4),                            -- Tax rate applied
    tax_jurisdiction TEXT,                            -- Tax jurisdiction
    vat_number TEXT,                                  -- VAT registration number (if applicable)

    -- Customer Information
    customer_email TEXT NOT NULL,                     -- Customer email
    customer_name TEXT,                               -- Customer name
    billing_country TEXT,                             -- Billing country for tax purposes

    -- Audit Trail
    initiated_by TEXT,                                -- Who initiated the transaction
    approved_by TEXT,                                 -- Who approved the transaction (if required)
    ip_address TEXT,                                  -- IP address of transaction initiation

    -- Timing
    transaction_date DATETIME NOT NULL,               -- When transaction occurred
    settlement_date DATETIME,                         -- When funds were settled
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    -- Compliance Retention
    retention_period_days INTEGER DEFAULT 2555        -- 7 years for financial records
);

-- ============================================================================
-- STEP 5: Create Configuration Change Log Table
-- ============================================================================

-- System configuration changes tracking for operational auditing
CREATE TABLE IF NOT EXISTS config_change_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,

    -- Configuration Change Identification
    change_id TEXT UNIQUE NOT NULL,                   -- UUID for unique configuration change
    change_request_id TEXT,                           -- Reference to change request (if applicable)

    -- Configuration Context
    config_category TEXT NOT NULL CHECK(config_category IN (
        'system', 'security', 'payment', 'email', 'database', 'api', 'ui', 'feature_flags', 'environment'
    )),
    config_subcategory TEXT,                          -- More specific categorization
    config_key TEXT NOT NULL,                         -- Configuration key/setting name

    -- Change Details
    old_value TEXT,                                   -- Previous configuration value
    new_value TEXT,                                   -- New configuration value
    value_type TEXT DEFAULT 'string' CHECK(value_type IN ('string', 'number', 'boolean', 'json', 'encrypted')),

    -- Change Management
    change_type TEXT NOT NULL CHECK(change_type IN ('create', 'update', 'delete', 'rotate')),
    change_reason TEXT NOT NULL,                      -- Business justification for change
    change_impact TEXT,                               -- Expected impact of the change
    rollback_plan TEXT,                               -- How to rollback if needed

    -- Authorization
    requested_by TEXT NOT NULL,                       -- Who requested the change
    approved_by TEXT,                                 -- Who approved the change
    implemented_by TEXT NOT NULL,                     -- Who implemented the change
    approval_workflow_id TEXT,                        -- Reference to approval workflow

    -- Environment & Deployment
    environment TEXT NOT NULL DEFAULT 'production' CHECK(environment IN ('development', 'staging', 'production')),
    deployment_method TEXT,                           -- How change was deployed
    deployment_reference TEXT,                        -- Reference to deployment (commit, release, etc.)

    -- Validation & Testing
    pre_change_validation TEXT,                       -- Pre-change validation results
    post_change_validation TEXT,                      -- Post-change validation results
    testing_status TEXT DEFAULT 'not_tested' CHECK(testing_status IN ('not_tested', 'passed', 'failed', 'partial')),

    -- Impact Assessment
    systems_affected TEXT,                            -- JSON: List of systems affected
    users_affected_count INTEGER DEFAULT 0,           -- Number of users potentially affected
    downtime_minutes INTEGER DEFAULT 0,               -- Planned/actual downtime

    -- Security Context
    security_review_required BOOLEAN DEFAULT FALSE,   -- Whether security review was required
    security_approved BOOLEAN DEFAULT FALSE,          -- Whether security team approved
    security_reviewer TEXT,                           -- Who performed security review

    -- Timing
    scheduled_at DATETIME,                            -- When change was scheduled
    implemented_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- When change was implemented
    verified_at DATETIME,                             -- When change was verified successful

    -- Rollback Information
    rollback_available BOOLEAN DEFAULT TRUE,          -- Whether rollback is possible
    rollback_window_hours INTEGER DEFAULT 24,         -- How long rollback is available
    rollback_executed BOOLEAN DEFAULT FALSE,          -- Whether rollback was executed
    rollback_reason TEXT,                             -- Reason for rollback (if executed)

    -- Compliance
    compliance_requirement TEXT,                       -- Compliance requirement driving change
    retention_period_days INTEGER DEFAULT 2555        -- 7 years retention for audit purposes
);

-- ============================================================================
-- STEP 6: Create Performance-Optimized Indexes
-- ============================================================================

-- Audit Log Indexes (optimized for common queries)
CREATE INDEX IF NOT EXISTS idx_audit_log_table_record ON audit_log(table_name, record_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_user_email ON audit_log(user_email);
CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_log_operation ON audit_log(operation);
CREATE INDEX IF NOT EXISTS idx_audit_log_event_id ON audit_log(event_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_business_process ON audit_log(business_process);
CREATE INDEX IF NOT EXISTS idx_audit_log_risk_level ON audit_log(risk_level);
CREATE INDEX IF NOT EXISTS idx_audit_log_data_subject ON audit_log(data_subject_email);
CREATE INDEX IF NOT EXISTS idx_audit_log_retention ON audit_log(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_audit_log_composite_tracking ON audit_log(table_name, operation, created_at DESC);

-- Admin Access Log Indexes
CREATE INDEX IF NOT EXISTS idx_admin_access_log_admin_email ON admin_access_log(admin_email);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_endpoint ON admin_access_log(endpoint);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_access_time ON admin_access_log(access_time DESC);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_ip_address ON admin_access_log(ip_address);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_risk_score ON admin_access_log(risk_score DESC);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_sensitivity ON admin_access_log(sensitivity_level);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_session ON admin_access_log(session_id);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_status ON admin_access_log(response_status);
CREATE INDEX IF NOT EXISTS idx_admin_access_log_composite_security ON admin_access_log(admin_email, access_time DESC, risk_score DESC);

-- Data Processing Log Indexes (GDPR compliance queries)
CREATE INDEX IF NOT EXISTS idx_data_processing_log_subject ON data_processing_log(data_subject_email);
CREATE INDEX IF NOT EXISTS idx_data_processing_log_lawful_basis ON data_processing_log(lawful_basis);
CREATE INDEX IF NOT EXISTS idx_data_processing_log_purpose ON data_processing_log(processing_purpose);
CREATE INDEX IF NOT EXISTS idx_data_processing_log_consent ON data_processing_log(consent_obtained, consent_timestamp);
CREATE INDEX IF NOT EXISTS idx_data_processing_log_retention ON data_processing_log(deletion_scheduled_date) WHERE deletion_scheduled_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_data_processing_log_subject_request ON data_processing_log(subject_request_type, request_fulfilled);
CREATE INDEX IF NOT EXISTS idx_data_processing_log_processing_dates ON data_processing_log(processing_start, processing_end);

-- Financial Audit Log Indexes (financial reconciliation queries)
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_transaction_ref ON financial_audit_log(transaction_reference);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_customer ON financial_audit_log(customer_email);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_processor ON financial_audit_log(payment_processor, processor_transaction_id);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_reconciliation ON financial_audit_log(reconciliation_status, bank_statement_date);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_transaction_date ON financial_audit_log(transaction_date DESC);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_amounts ON financial_audit_log(original_amount_cents, processed_amount_cents);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_fraud ON financial_audit_log(fraud_score DESC, manual_review_required);
CREATE INDEX IF NOT EXISTS idx_financial_audit_log_settlement ON financial_audit_log(settlement_date) WHERE settlement_date IS NOT NULL;

-- Config Change Log Indexes
CREATE INDEX IF NOT EXISTS idx_config_change_log_category ON config_change_log(config_category, config_subcategory);
CREATE INDEX IF NOT EXISTS idx_config_change_log_key ON config_change_log(config_key);
CREATE INDEX IF NOT EXISTS idx_config_change_log_implemented_at ON config_change_log(implemented_at DESC);
CREATE INDEX IF NOT EXISTS idx_config_change_log_environment ON config_change_log(environment);
CREATE INDEX IF NOT EXISTS idx_config_change_log_implementer ON config_change_log(implemented_by);
CREATE INDEX IF NOT EXISTS idx_config_change_log_approver ON config_change_log(approved_by);
CREATE INDEX IF NOT EXISTS idx_config_change_log_rollback ON config_change_log(rollback_executed, rollback_available);
CREATE INDEX IF NOT EXISTS idx_config_change_log_security ON config_change_log(security_review_required, security_approved);

-- ============================================================================
-- STEP 7: Create Automatic Database Triggers for Change Tracking
-- ============================================================================

-- Trigger for automatic audit logging on tickets table changes
CREATE TRIGGER IF NOT EXISTS audit_tickets_insert
    AFTER INSERT ON tickets
    BEGIN
        INSERT INTO audit_log (
            audit_id,
            event_id,
            table_name,
            record_id,
            operation,
            new_values,
            changed_fields,
            business_process,
            data_subject_email,
            source_system,
            checksum
        ) VALUES (
            'aud_' || hex(randomblob(16)),
            NEW.event_id,
            'tickets',
            NEW.id,
            'INSERT',
            json_object(
                'ticket_id', NEW.ticket_id,
                'transaction_id', NEW.transaction_id,
                'ticket_type', NEW.ticket_type,
                'price_cents', NEW.price_cents,
                'attendee_email', NEW.attendee_email,
                'status', NEW.status,
                'registration_status', NEW.registration_status
            ),
            json_array('ticket_id', 'transaction_id', 'ticket_type', 'price_cents', 'attendee_email', 'status', 'registration_status'),
            'ticket_creation',
            NEW.attendee_email,
            'festival_platform',
            substr(hex(randomblob(16)), 1, 16)
        );
    END;

CREATE TRIGGER IF NOT EXISTS audit_tickets_update
    AFTER UPDATE ON tickets
    WHEN OLD.status != NEW.status
      OR OLD.registration_status != NEW.registration_status
      OR OLD.checked_in_at != NEW.checked_in_at
      OR OLD.attendee_email != NEW.attendee_email
      OR OLD.attendee_first_name != NEW.attendee_first_name
      OR OLD.attendee_last_name != NEW.attendee_last_name
    BEGIN
        INSERT INTO audit_log (
            audit_id,
            event_id,
            table_name,
            record_id,
            operation,
            old_values,
            new_values,
            changed_fields,
            business_process,
            data_subject_email,
            risk_level,
            source_system,
            checksum
        ) VALUES (
            'aud_' || hex(randomblob(16)),
            NEW.event_id,
            'tickets',
            NEW.id,
            'UPDATE',
            json_object(
                'status', OLD.status,
                'registration_status', OLD.registration_status,
                'checked_in_at', OLD.checked_in_at,
                'attendee_email', OLD.attendee_email,
                'attendee_first_name', OLD.attendee_first_name,
                'attendee_last_name', OLD.attendee_last_name
            ),
            json_object(
                'status', NEW.status,
                'registration_status', NEW.registration_status,
                'checked_in_at', NEW.checked_in_at,
                'attendee_email', NEW.attendee_email,
                'attendee_first_name', NEW.attendee_first_name,
                'attendee_last_name', NEW.attendee_last_name
            ),
            json_array(
                CASE WHEN OLD.status != NEW.status THEN 'status' END,
                CASE WHEN OLD.registration_status != NEW.registration_status THEN 'registration_status' END,
                CASE WHEN OLD.checked_in_at != NEW.checked_in_at THEN 'checked_in_at' END,
                CASE WHEN OLD.attendee_email != NEW.attendee_email THEN 'attendee_email' END,
                CASE WHEN OLD.attendee_first_name != NEW.attendee_first_name THEN 'attendee_first_name' END,
                CASE WHEN OLD.attendee_last_name != NEW.attendee_last_name THEN 'attendee_last_name' END
            ),
            CASE
                WHEN OLD.status != NEW.status THEN 'ticket_status_change'
                WHEN OLD.registration_status != NEW.registration_status THEN 'registration_update'
                WHEN OLD.checked_in_at != NEW.checked_in_at THEN 'check_in'
                ELSE 'attendee_update'
            END,
            COALESCE(NEW.attendee_email, OLD.attendee_email),
            CASE
                WHEN OLD.status = 'valid' AND NEW.status = 'cancelled' THEN 'high'
                WHEN OLD.checked_in_at IS NULL AND NEW.checked_in_at IS NOT NULL THEN 'medium'
                ELSE 'low'
            END,
            'festival_platform',
            substr(hex(randomblob(16)), 1, 16)
        );
    END;

-- Trigger for automatic audit logging on transactions table changes
CREATE TRIGGER IF NOT EXISTS audit_transactions_insert
    AFTER INSERT ON transactions
    BEGIN
        INSERT INTO audit_log (
            audit_id,
            event_id,
            table_name,
            record_id,
            operation,
            new_values,
            changed_fields,
            business_process,
            data_subject_email,
            transaction_reference,
            risk_level,
            source_system,
            checksum
        ) VALUES (
            'aud_' || hex(randomblob(16)),
            NEW.event_id,
            'transactions',
            NEW.id,
            'INSERT',
            json_object(
                'transaction_id', NEW.transaction_id,
                'type', NEW.type,
                'status', NEW.status,
                'amount_cents', NEW.amount_cents,
                'customer_email', NEW.customer_email,
                'stripe_session_id', NEW.stripe_session_id
            ),
            json_array('transaction_id', 'type', 'status', 'amount_cents', 'customer_email', 'stripe_session_id'),
            'payment_processing',
            NEW.customer_email,
            NEW.transaction_id,
            CASE
                WHEN NEW.amount_cents > 50000 THEN 'high'    -- Transactions over $500
                WHEN NEW.amount_cents > 10000 THEN 'medium'  -- Transactions over $100
                ELSE 'low'
            END,
            'festival_platform',
            substr(hex(randomblob(16)), 1, 16)
        );
    END;

CREATE TRIGGER IF NOT EXISTS audit_transactions_update
    AFTER UPDATE ON transactions
    WHEN OLD.status != NEW.status
      OR OLD.amount_cents != NEW.amount_cents
      OR OLD.customer_email != NEW.customer_email
    BEGIN
        INSERT INTO audit_log (
            audit_id,
            event_id,
            table_name,
            record_id,
            operation,
            old_values,
            new_values,
            changed_fields,
            business_process,
            data_subject_email,
            transaction_reference,
            risk_level,
            source_system,
            checksum
        ) VALUES (
            'aud_' || hex(randomblob(16)),
            NEW.event_id,
            'transactions',
            NEW.id,
            'UPDATE',
            json_object(
                'status', OLD.status,
                'amount_cents', OLD.amount_cents,
                'customer_email', OLD.customer_email
            ),
            json_object(
                'status', NEW.status,
                'amount_cents', NEW.amount_cents,
                'customer_email', NEW.customer_email
            ),
            json_array(
                CASE WHEN OLD.status != NEW.status THEN 'status' END,
                CASE WHEN OLD.amount_cents != NEW.amount_cents THEN 'amount_cents' END,
                CASE WHEN OLD.customer_email != NEW.customer_email THEN 'customer_email' END
            ),
            'payment_processing',
            COALESCE(NEW.customer_email, OLD.customer_email),
            NEW.transaction_id,
            CASE
                WHEN OLD.status = 'completed' AND NEW.status = 'refunded' THEN 'critical'
                WHEN OLD.amount_cents != NEW.amount_cents THEN 'high'
                WHEN OLD.status != NEW.status THEN 'medium'
                ELSE 'low'
            END,
            'festival_platform',
            substr(hex(randomblob(16)), 1, 16)
        );
    END;

-- ============================================================================
-- STEP 8: Create Triggers for Automatic Retention Period Calculation
-- ============================================================================

-- Trigger to automatically calculate expires_at for audit_log entries
CREATE TRIGGER IF NOT EXISTS audit_log_set_expiry
    AFTER INSERT ON audit_log
    WHEN NEW.expires_at IS NULL AND NEW.retention_period_days IS NOT NULL
    BEGIN
        UPDATE audit_log
        SET expires_at = datetime(NEW.created_at, '+' || NEW.retention_period_days || ' days')
        WHERE id = NEW.id;
    END;

-- Trigger to automatically calculate expires_at for financial_audit_log entries
CREATE TRIGGER IF NOT EXISTS financial_audit_set_expiry
    AFTER INSERT ON financial_audit_log
    WHEN NEW.retention_period_days IS NOT NULL
    BEGIN
        UPDATE financial_audit_log
        SET retention_period_days = CASE
            WHEN NEW.transaction_type IN ('sale', 'refund', 'chargeback') THEN 2555  -- 7 years for financial records
            ELSE 1825  -- 5 years for other financial events
        END
        WHERE id = NEW.id AND NEW.retention_period_days = 2555;  -- Only update if using default
    END;

-- ============================================================================
-- STEP 9: Create Views for Common Audit Queries
-- ============================================================================

-- View for recent high-risk activities across all audit tables
CREATE VIEW IF NOT EXISTS high_risk_audit_activities AS
SELECT
    'audit_log' as source_table,
    audit_id as event_id,
    user_email as actor,
    table_name || '.' || operation as activity,
    risk_level,
    created_at,
    business_process as context
FROM audit_log
WHERE risk_level IN ('high', 'critical')
  AND created_at >= datetime('now', '-30 days')

UNION ALL

SELECT
    'admin_access_log' as source_table,
    access_id as event_id,
    admin_email as actor,
    endpoint || ' (' || http_method || ')' as activity,
    CASE
        WHEN risk_score >= 80 THEN 'critical'
        WHEN risk_score >= 60 THEN 'high'
        ELSE 'medium'
    END as risk_level,
    access_time as created_at,
    'admin_access' as context
FROM admin_access_log
WHERE risk_score >= 60
  AND access_time >= datetime('now', '-30 days')

ORDER BY created_at DESC;

-- View for GDPR data subject audit trail
CREATE VIEW IF NOT EXISTS gdpr_data_subject_audit AS
SELECT
    d.data_subject_email,
    d.processing_purpose,
    d.lawful_basis,
    d.consent_obtained,
    d.consent_timestamp,
    d.consent_withdrawn_at,
    d.subject_request_type,
    d.request_fulfilled,
    a.table_name,
    a.operation,
    a.created_at as activity_timestamp,
    a.business_process
FROM data_processing_log d
LEFT JOIN audit_log a ON d.data_subject_email = a.data_subject_email
WHERE d.processing_start >= datetime('now', '-90 days')
ORDER BY d.data_subject_email, a.created_at DESC;

-- View for financial audit summary by day
CREATE VIEW IF NOT EXISTS daily_financial_audit_summary AS
SELECT
    date(transaction_date) as audit_date,
    transaction_type,
    currency,
    COUNT(*) as transaction_count,
    SUM(original_amount_cents) / 100.0 as total_amount,
    SUM(processor_fee_cents) / 100.0 as total_fees,
    SUM(net_amount_cents) / 100.0 as net_amount,
    COUNT(CASE WHEN reconciliation_status = 'pending' THEN 1 END) as pending_reconciliation,
    COUNT(CASE WHEN manual_review_required = 1 THEN 1 END) as requiring_review,
    AVG(fraud_score) as avg_fraud_score
FROM financial_audit_log
WHERE transaction_date >= date('now', '-90 days')
GROUP BY date(transaction_date), transaction_type, currency
ORDER BY audit_date DESC, transaction_type;

-- ============================================================================
-- STEP 10: Insert Initial Configuration Audit Entry
-- ============================================================================

-- Log this migration as a configuration change
INSERT INTO config_change_log (
    change_id,
    config_category,
    config_subcategory,
    config_key,
    new_value,
    value_type,
    change_type,
    change_reason,
    change_impact,
    requested_by,
    implemented_by,
    environment,
    deployment_method,
    systems_affected,
    security_review_required,
    testing_status
) VALUES (
    'cfg_' || hex(randomblob(16)),
    'database',
    'audit_framework',
    'comprehensive_audit_tables',
    'enabled',
    'boolean',
    'create',
    'Implement comprehensive audit framework for data change tracking, GDPR compliance, financial reconciliation, and security monitoring',
    'Enables full audit trail for all database changes and admin activities with automatic triggers and performance-optimized indexes',
    'database_administrator',
    'migration_system',
    'production',
    'database_migration',
    json_array('audit_log', 'admin_access_log', 'data_processing_log', 'financial_audit_log', 'config_change_log'),
    TRUE,
    'passed'
);

-- ============================================================================
-- Migration Complete
-- ============================================================================
-- This migration implements a comprehensive audit framework providing:
--
-- 1. Complete data change tracking with automatic triggers
-- 2. Admin access monitoring and security logging
-- 3. GDPR compliance tracking for personal data processing
-- 4. Enhanced financial audit trail for reconciliation
-- 5. Configuration change management and approval workflow
-- 6. Performance-optimized indexes for efficient querying
-- 7. Automatic retention period management
-- 8. Audit views for common compliance and security queries
--
-- The framework supports multi-event architecture and provides the foundation
-- for regulatory compliance, security monitoring, and operational auditing.