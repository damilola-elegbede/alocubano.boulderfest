<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <!-- Inline theme detection to prevent FOUC -->
    <script>
      (function() {
        // Detect admin pages
        const path = window.location.pathname.toLowerCase();
        const isAdmin = path.includes('/admin') || path.includes('pages/admin');

        if (isAdmin) {
          // Admin pages always use dark theme
          document.documentElement.setAttribute('data-theme', 'dark');
        } else {
          // Main site: check user preference
          let stored = null;
          try {
            stored = localStorage.getItem('theme-preference');
          } catch {
            // localStorage might be disabled
          }

          const preference = stored || 'system';
          let theme = preference;

          if (preference === 'system') {
            // Detect system preference
            theme = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches)
              ? 'dark'
              : 'light';
          }

          document.documentElement.setAttribute('data-theme', theme);
        }
      })();
    </script>

    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#5b6bb5" />
    <title>Check-in Scanner - A Lo Cubano</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/images/icons/icon-192x192.png" />

    <!-- Admin Auth Guard - loaded early for security -->
    <script src="/js/admin-auth-guard.js"></script>

    <!-- Theme Manager - loaded early to prevent FOUC -->
    <script type="module" src="/js/theme-manager.js"></script>
    <script type="module" src="/js/time-manager.js"></script>

    <!-- CSS System -->
    <link rel="stylesheet" href="/css/base.css" />
    <link rel="stylesheet" href="/css/typography.css" />
    <link rel="stylesheet" href="/css/components.css" />
    <link rel="stylesheet" href="/css/forms.css" />
    <link rel="stylesheet" href="/css/mobile-overrides.css" />
    <link rel="stylesheet" href="/css/admin-overrides.css" />
    <!-- Scanner-specific styles -->
    <style>
      /* QR Scanner specific overrides */
      body {
        height: 100vh;
        overflow: hidden;
        background: var(--color-background);
        color: var(--color-text-primary);
      }

      .scanner-app {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .app-header {
        background: linear-gradient(
          135deg,
          var(--color-blue) 0%,
          var(--color-red) 100%
        );
        padding: var(--space-lg) var(--space-xl);
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: var(--shadow-lg);
        position: sticky;
        top: 0;
        z-index: 1000;
        min-height: 80px;
      }

      .app-title-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        margin: 0 60px;
      }

      .app-portal-label {
        font-family: var(--font-sans);
        font-size: var(--font-size-xs);
        color: rgba(255, 255, 255, 0.8);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 4px;
      }

      .app-title {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        color: var(--color-white);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wider);
        margin: 0;
        text-align: center;
      }

      .menu-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        width: 44px;
        height: 44px;
        min-height: 44px !important;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--color-white) !important;
        font-size: var(--font-size-xl);
        padding: 0 !important;
      }

      .menu-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      .menu-btn:active {
        transform: scale(0.95);
      }

      .scanner-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .stats-bar {
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
        padding: var(--space-xs) var(--space-sm);
        display: flex;
        gap: var(--space-xs);
        font-size: var(--font-size-xs);
        min-height: 45px;
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
      }

      .stats-bar .admin-stat-card {
        padding: var(--space-xs) !important;
        margin: 0 !important;
        min-width: auto !important;
        flex: 1;
        cursor: default;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .stats-bar .stat-number {
        font-size: var(--font-size-lg);
        font-weight: 700;
        line-height: 1;
        margin-bottom: 2px;
      }

      .stats-bar .stat-label {
        font-size: var(--font-size-xs);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.8;
      }

      .stats-bar .admin-stat-card:hover {
        transform: none;
        box-shadow: var(--shadow-md);
      }

      .scanner-viewport {
        flex: 1;
        position: relative;
        background: var(--color-black);
        overflow: hidden;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #reader {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }

      .scanner-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .scan-region {
        width: 280px;
        height: 280px;
        border: 3px solid var(--color-red);
        border-radius: var(--radius-xl);
        position: relative;
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.3);
        transition: all 0.3s ease;
      }

      /* Scanner state: actively scanning (default - red border) */
      .scan-region.scanning {
        border-color: var(--color-red);
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.3);
      }

      /* Scanner state: QR code locked on (green border) */
      .scan-region.locked {
        border-color: #10b981;
        box-shadow: 0 0 40px rgba(16, 185, 129, 0.5);
      }

      /* Scan corners removed for cleaner appearance - full-screen scanner uses simple borders */

      /* Stats Bar */
      .stats-bar {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: var(--space-md);
        padding: var(--space-lg);
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: var(--space-md);
        background: var(--color-surface);
        border-radius: var(--radius-md);
        border: 1px solid var(--color-border);
        transition: all 0.2s ease;
        flex: 0 0 auto;
        min-width: 80px;
      }

      .stat-item:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .stat-item-clickable {
        cursor: pointer;
      }

      .stat-item-clickable:hover {
        border-color: var(--color-blue);
        box-shadow: var(--shadow-lg);
      }

      .stat-item-clickable:active {
        transform: translateY(0);
      }

      .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: var(--color-blue);
        font-family: var(--font-mono);
        line-height: 1;
        margin-bottom: var(--space-xs);
      }

      .stat-label {
        font-size: 12px;
        font-weight: 600;
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        text-align: center;
      }

      /* Highlight new stats */
      #statFailed { color: var(--color-red); }
      #statInvalid { color: var(--color-warning); }
      #statAvgTime { color: var(--color-success); }

      /* Mobile responsive stats */
      @media (max-width: 768px) {
        .stats-bar {
          grid-template-columns: repeat(4, 1fr);
          gap: var(--space-sm);
          padding: var(--space-md);
        }

        .stat-item {
          padding: var(--space-sm);
        }

        .stat-value {
          font-size: 18px;
        }

        .stat-label {
          font-size: 10px;
        }
      }

      @media (max-width: 480px) {
        .stat-item {
          min-width: 70px;
          padding: var(--space-sm);
        }
      }

      .controls {
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
        padding: var(--space-lg) var(--space-xl);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: var(--space-xl);
        box-shadow: var(--shadow-lg);
        position: sticky;
        bottom: 0;
        z-index: 50;
      }

      .controls::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .control-btn {
        width: 60px !important;
        height: 60px !important;
        min-height: 60px !important;
        border-radius: 50% !important;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        padding: 0 !important;
        box-shadow: var(--shadow-md);
      }

      .control-btn:active {
        transform: scale(0.95);
      }

      /* Recent Activity Feed */
      .recent-activity {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: var(--space-lg);
        background: linear-gradient(180deg,
          rgba(91, 107, 181, 0.03) 0%,
          rgba(204, 41, 54, 0.03) 100%);
        -webkit-overflow-scrolling: touch;
      }

      .activity-header {
        font-family: var(--font-display);
        font-size: var(--font-size-lg);
        font-weight: 700;
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin: 0 0 var(--space-lg) 0;
        padding-bottom: var(--space-sm);
        border-bottom: 2px solid var(--color-border);
        position: relative;
      }

      .activity-header::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 60px;
        height: 2px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .activity-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
      }

      .activity-empty {
        text-align: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
        font-family: var(--font-accent);
        font-style: italic;
        font-size: var(--font-size-base);
      }

      .activity-item {
        display: flex;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-md);
        background: var(--color-surface);
        border-left: 4px solid;
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
        animation: slideInRight 0.3s ease-out;
        transition: all 0.2s ease;
      }

      .activity-item:hover {
        transform: translateX(-2px);
        box-shadow: var(--shadow-md);
      }

      .activity-item.success {
        border-color: var(--color-success);
      }

      .activity-item.error {
        border-color: var(--color-error);
      }

      .activity-item.pending {
        border-color: var(--color-warning);
      }

      .activity-icon {
        font-size: 24px;
        line-height: 1;
        flex-shrink: 0;
      }

      .activity-details {
        flex: 1;
        min-width: 0;
      }

      .activity-ticket {
        font-family: var(--font-mono);
        font-size: var(--font-size-sm);
        font-weight: 600;
        color: var(--color-text-primary);
        margin-bottom: var(--space-xs);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .activity-info {
        font-size: var(--font-size-xs);
        color: var(--color-text-secondary);
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }

      .activity-timestamp {
        font-family: var(--font-mono);
        font-size: var(--font-size-xs);
        color: var(--color-text-muted);
        flex-shrink: 0;
      }

      .activity-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: var(--radius-sm);
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .activity-badge.type {
        background: rgba(91, 107, 181, 0.1);
        color: var(--color-blue);
      }

      @keyframes slideInRight {
        from {
          opacity: 0;
          transform: translateX(30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      /* Pulsing animation on active stats */
      .stat-value.pulsing {
        animation: pulse 1s ease-in-out 2;
      }

      /* Mobile responsive activity feed */
      @media (max-width: 768px) {
        .recent-activity {
          padding: var(--space-md);
        }

        .activity-item {
          padding: var(--space-sm);
          gap: var(--space-sm);
        }

        .activity-icon {
          font-size: 20px;
        }

        .activity-ticket {
          font-size: var(--font-size-xs);
        }

        .activity-info {
          font-size: 10px;
        }
      }

      .control-btn.manual {
        background: var(--color-red) !important;
        border-color: var(--color-red) !important;
        color: var(--color-white) !important;
      }

      .control-btn.manual:hover {
        background: var(--color-secondary-hover) !important;
        border-color: var(--color-secondary-hover) !important;
      }

      .result-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: var(--z-modal);
        animation: fadeIn 0.3s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .result-modal.show {
        display: flex;
      }

      .result-content {
        background: var(--color-white);
        border-radius: var(--radius-xl);
        padding: var(--space-3xl);
        max-width: 90%;
        width: 350px;
        text-align: center;
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
      }

      @keyframes slideUp {
        from {
          transform: translateY(50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .result-content.success {
        background: var(--color-success);
        color: var(--color-white);
      }

      .result-content.error {
        background: var(--color-error);
        color: var(--color-white);
      }

      .result-icon {
        font-size: 60px;
        margin-bottom: var(--space-xl);
      }

      .result-title {
        font-family: var(--font-display);
        font-size: var(--font-size-2xl);
        font-weight: 700;
        margin-bottom: var(--space-md);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .result-details {
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        opacity: 0.9;
        margin-bottom: var(--space-xl);
        white-space: pre-line;
        line-height: var(--line-height-relaxed);
      }

      .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: currentColor !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        padding: var(--space-md) var(--space-xl);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 44px;
      }

      .result-content.success .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .result-content.success .result-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      .result-content.error .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .result-content.error .result-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      /* Checked-In Tickets Overlay */
      .tickets-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.2s ease-out;
      }

      .tickets-overlay.show {
        display: flex;
      }

      .tickets-overlay-content {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        width: 90%;
        max-width: 900px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow-2xl);
        overflow: hidden;
      }

      .tickets-overlay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-lg);
        border-bottom: 2px solid var(--color-border);
        background: linear-gradient(90deg, rgba(91,107,181,0.1), rgba(204,41,54,0.1));
        position: relative;
      }

      .tickets-overlay-header::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 100px;
        height: 2px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .tickets-overlay-header h3 {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        color: var(--color-text-primary);
        margin: 0;
      }

      .tickets-overlay-close {
        background: transparent;
        border: none;
        color: var(--color-text-primary);
        font-size: var(--font-size-2xl);
        cursor: pointer;
        padding: var(--space-xs);
        line-height: 1;
        transition: all 0.2s ease;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: var(--radius-md);
      }

      .tickets-overlay-close:hover {
        background: rgba(0, 0, 0, 0.05);
        transform: scale(1.1);
      }

      .tickets-overlay-body {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
      }

      .tickets-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
      }

      .tickets-loading .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid var(--color-border);
        border-top-color: var(--color-blue);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-bottom: var(--space-md);
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .tickets-error {
        padding: var(--space-lg);
        background: rgba(204, 41, 54, 0.1);
        border: 1px solid var(--color-error);
        border-radius: var(--radius-md);
        color: var(--color-error);
        text-align: center;
        margin: var(--space-lg);
      }

      .tickets-empty {
        text-align: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
        font-family: var(--font-accent);
        font-style: italic;
      }

      .tickets-table-container {
        overflow-x: auto;
        overflow-y: auto;
        flex: 1;
      }

      .tickets-table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--font-size-base);
      }

      .tickets-table thead {
        position: sticky;
        top: 0;
        background: var(--color-surface-elevated);
        z-index: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tickets-table th {
        text-align: left;
        padding: var(--space-md);
        font-family: var(--font-display);
        text-transform: uppercase;
        font-size: var(--font-size-sm);
        font-weight: 700;
        letter-spacing: var(--letter-spacing-wide);
        border-bottom: 2px solid var(--color-border);
        color: var(--color-text-primary);
      }

      .tickets-table td {
        padding: var(--space-md);
        border-bottom: 1px solid var(--color-border);
        font-family: var(--font-sans);
      }

      .tickets-table tbody tr {
        transition: background-color 0.2s ease, transform 0.1s ease;
        cursor: pointer;
      }

      .tickets-table tbody tr:hover {
        background: rgba(91, 107, 181, 0.08);
        transform: translateX(2px);
      }

      .tickets-table tbody tr:active {
        background: rgba(91, 107, 181, 0.12);
      }

      .tickets-table tbody tr:last-child td {
        border-bottom: none;
      }

      /* Mobile responsive */
      @media (max-width: 768px) {
        .tickets-overlay-content {
          width: 95%;
          max-height: 90vh;
        }

        .tickets-overlay-header {
          padding: var(--space-md);
        }

        .tickets-overlay-header h3 {
          font-size: var(--font-size-lg);
        }

        .tickets-overlay-body {
          padding: var(--space-md);
        }

        .tickets-table {
          font-size: var(--font-size-sm);
        }

        .tickets-table th,
        .tickets-table td {
          padding: var(--space-sm);
        }

        /* Stack table columns more compactly on small screens */
        .tickets-table th:first-child,
        .tickets-table td:first-child {
          min-width: 100px;
        }
      }

      .tickets-pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-lg);
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
      }

      .pagination-btn {
        padding: var(--space-sm) var(--space-md);
        background: var(--color-blue);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        cursor: pointer;
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        font-weight: 600;
        transition: all 0.2s ease;
        min-width: 100px;
      }

      .pagination-btn:hover:not(:disabled) {
        background: var(--color-blue-dark);
        transform: translateY(-1px);
      }

      .pagination-btn:disabled {
        background: var(--color-border);
        color: var(--color-text-muted);
        cursor: not-allowed;
        opacity: 0.5;
      }

      .pagination-info {
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
        min-width: 100px;
        text-align: center;
      }

      .manual-input-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: calc(var(--z-modal) - 1);
      }

      .manual-input-backdrop.show {
        display: block;
      }

      .manual-input {
        position: fixed;
        bottom: -100%;
        left: 0;
        right: 0;
        background: var(--color-surface);
        color: var(--color-text-primary);
        padding: var(--space-xl);
        border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        transition: bottom 0.3s ease-out;
        z-index: var(--z-modal);
        box-shadow: var(--shadow-2xl);
      }

      .manual-input.show {
        bottom: 0;
      }

      .manual-input h3 {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        margin-bottom: var(--space-lg);
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .manual-input-buttons {
        display: flex;
        gap: var(--space-md);
        margin-top: var(--space-lg);
      }

      /* Hide HTML5 QR Code default UI elements */
      #reader__dashboard_section_csr,
      #reader__dashboard_section_fsr {
        display: none !important;
      }

      #reader__scan_region {
        border: none !important;
      }

      #reader video {
        object-fit: cover !important;
      }

      .offline-indicator {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: var(--z-modal);
        margin: 0;
        width: auto;
        max-width: 90%;
        display: none;
      }

      /* Dark mode specific adjustments for scanner */
      [data-theme="dark"] .result-content:not(.success):not(.error) {
        background: var(--color-surface);
        color: var(--color-text-primary);
      }

      [data-theme="dark"] .manual-input {
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
      }

      /* Tablet responsiveness */
      @media (max-width: 768px) and (min-width: 481px) {
        .app-title {
          font-size: var(--font-size-lg);
          margin: 0 100px;
          max-width: calc(100% - 200px);
        }

        .back-btn,
        .logout-btn {
          font-size: var(--font-size-xs);
          padding: var(--space-xs);
          min-width: 70px;
        }
      }

      /* Mobile responsiveness */
      @media (max-width: 480px) {
        .app-header {
          flex-direction: column;
          align-items: center;
          text-align: center;
          padding: var(--space-md);
          min-height: auto;
        }

        .logout-btn,
        .back-btn {
          position: static;
          margin: var(--space-xs);
          min-width: 80px;
          z-index: auto;
        }

        .app-title {
          margin: var(--space-sm) 0;
          max-width: 100%;
          order: 1;
        }

        .back-btn {
          order: 0;
        }

        .logout-btn {
          order: 2;
        }
      }

        .stats-bar {
          padding: var(--space-xs);
          gap: var(--space-xs);
          flex-wrap: wrap;
        }

        .stats-bar .admin-stat-card {
          min-width: calc(50% - var(--space-xs) / 2);
          flex: 0 0 calc(50% - var(--space-xs) / 2);
        }
        .scan-region {
          width: 240px;
          height: 240px;
        }

        .controls {
          padding: var(--space-lg);
        }

        .control-btn {
          width: 50px !important;
          height: 50px !important;
          min-height: 50px !important;
          font-size: 20px;
        }

        .result-content {
          width: 90%;
          padding: var(--space-xl);
        }

        .offline-indicator {
          top: 110px; /* Adjusted to account for event selector */
          font-size: var(--font-size-sm);
        }
      }

      /* Event Selector Styles */
      .event-selector-wrapper {
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
        padding: var(--space-md) var(--space-xl);
        display: flex;
        align-items: center;
        gap: var(--space-md);
        font-size: var(--font-size-sm);
      }

      .event-selector-label {
        color: var(--color-text-secondary);
        font-weight: 600;
        white-space: nowrap;
        font-family: var(--font-display);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .event-selector {
        flex: 1;
        max-width: 400px;
        background: var(--color-surface) !important;
        border: 1px solid var(--color-border) !important;
        color: var(--color-text-primary) !important;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: var(--font-size-sm);
        font-family: var(--font-sans);
      }

      .event-selector:focus {
        outline: none;
        border-color: var(--color-blue) !important;
        box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
      }

      /* Wide screen optimizations */
      @media (min-width: 1200px) {
        .app-title {
          font-size: var(--font-size-2xl);
          margin: 0 160px;
          max-width: min(calc(100% - 320px), 600px);
        }

        .back-btn,
        .logout-btn {
          min-height: 40px;
          padding: var(--space-sm) var(--space-lg);
          font-size: var(--font-size-base);
        }
      }

      /* Ultra-wide screen constraints */
      @media (min-width: 1600px) {
        .app-header {
          max-width: 1400px;
          margin: 0 auto;
        }
      }

      /* Permission Request Modal */
      .permission-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: calc(var(--z-modal) + 10);
        animation: fadeIn 0.3s ease-out;
      }

      .permission-modal.show {
        display: flex;
      }

      .permission-content {
        background: var(--color-surface);
        border-radius: var(--radius-xl);
        padding: var(--space-3xl);
        max-width: 90%;
        width: 420px;
        text-align: center;
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
        border: 1px solid var(--color-border);
      }

      .permission-icon {
        font-size: 64px;
        margin-bottom: var(--space-xl);
        display: block;
      }

      .permission-title {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        margin-bottom: var(--space-lg);
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .permission-description {
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        color: var(--color-text-secondary);
        margin-bottom: var(--space-xl);
        line-height: var(--line-height-relaxed);
      }

      .device-instructions {
        background: var(--color-surface-elevated);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-lg);
        padding: var(--space-lg);
        margin: var(--space-lg) 0;
        text-align: left;
        font-size: var(--font-size-sm);
        color: var(--color-text-primary);
      }

      .device-instructions h4 {
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        margin-bottom: var(--space-sm);
        color: var(--color-blue);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .device-instructions ol {
        margin: 0;
        padding-left: var(--space-lg);
      }

      .device-instructions li {
        margin-bottom: var(--space-xs);
        line-height: var(--line-height-relaxed);
      }

      .permission-buttons {
        display: flex;
        gap: var(--space-md);
        margin-top: var(--space-xl);
      }

      .permission-btn {
        flex: 1;
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 48px;
        transition: all 0.2s ease;
        cursor: pointer;
        border: 2px solid transparent;
      }

      .permission-btn.primary {
        background: var(--color-blue) !important;
        color: var(--color-white) !important;
        border-color: var(--color-blue) !important;
      }

      .permission-btn.primary:hover {
        background: var(--color-primary-hover) !important;
        border-color: var(--color-primary-hover) !important;
        transform: translateY(-1px);
      }

      .permission-btn.secondary {
        background: var(--color-surface-elevated) !important;
        color: var(--color-text-primary) !important;
        border-color: var(--color-border) !important;
      }

      .permission-btn.secondary:hover {
        background: var(--color-surface) !important;
        border-color: var(--color-text-secondary) !important;
      }

      /* Loading States */
      .scanner-loading {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--color-black);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 50;
      }

      .scanner-loading.show {
        display: flex;
      }

      .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(102, 126, 234, 0.2);
        border-left: 4px solid var(--color-blue);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: var(--space-lg);
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-lg);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin-bottom: var(--space-sm);
      }

      .loading-subtext {
        color: rgba(255, 255, 255, 0.7);
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        text-align: center;
        max-width: 280px;
        line-height: var(--line-height-relaxed);
      }

      /* Error States */
      .scanner-error {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--color-black);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 50;
        padding: var(--space-xl);
      }

      .scanner-error.show {
        display: flex;
      }

      .error-icon {
        font-size: 72px;
        margin-bottom: var(--space-xl);
        color: var(--color-red);
      }

      .error-title {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin-bottom: var(--space-lg);
        text-align: center;
      }

      .error-message {
        color: rgba(255, 255, 255, 0.8);
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        text-align: center;
        max-width: 350px;
        line-height: var(--line-height-relaxed);
        margin-bottom: var(--space-xl);
      }

      .error-actions {
        display: flex;
        gap: var(--space-md);
        flex-wrap: wrap;
        justify-content: center;
        max-width: 100%;
      }

      .error-btn {
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 48px;
        min-width: 120px;
        transition: all 0.2s ease;
        cursor: pointer;
        border: 2px solid transparent;
      }

      .error-btn.retry {
        background: var(--color-blue) !important;
        color: var(--color-white) !important;
        border-color: var(--color-blue) !important;
      }

      .error-btn.retry:hover {
        background: var(--color-primary-hover) !important;
        border-color: var(--color-primary-hover) !important;
        transform: translateY(-1px);
      }

      .error-btn.manual {
        background: var(--color-red) !important;
        color: var(--color-white) !important;
        border-color: var(--color-red) !important;
      }

      .error-btn.manual:hover {
        background: var(--color-secondary-hover) !important;
        border-color: var(--color-secondary-hover) !important;
        transform: translateY(-1px);
      }

      .error-btn.settings {
        background: rgba(255, 255, 255, 0.1) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .error-btn.settings:hover {
        background: rgba(255, 255, 255, 0.2) !important;
        border-color: rgba(255, 255, 255, 0.5) !important;
      }

      /* Success Indicator */
      .scanner-success {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(76, 175, 80, 0.95);
        color: var(--color-white);
        border-radius: var(--radius-xl);
        padding: var(--space-lg) var(--space-xl);
        display: none;
        align-items: center;
        gap: var(--space-md);
        z-index: 60;
        font-family: var(--font-display);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
      }

      .scanner-success.show {
        display: flex;
      }

      .success-icon {
        font-size: var(--font-size-xl);
      }

      /* Full-Screen Scanner Modal */
      .fullscreen-scanner-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .fullscreen-scanner-modal.active {
        display: flex;
      }

      .fullscreen-scanner-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: var(--space-lg);
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 10000;
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
      }

      .fullscreen-scanner-title {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .fullscreen-close-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: var(--color-white);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .fullscreen-close-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
        transform: scale(1.1);
      }

      .fullscreen-scanner-container {
        width: 90vw;
        max-width: 600px;
        height: auto;
        position: relative;
      }

      .fullscreen-scan-region {
        width: 100%;
        aspect-ratio: 1;
        border: 3px solid var(--color-red);
        border-radius: var(--radius-xl);
        position: relative;
        box-shadow: 0 0 60px rgba(239, 68, 68, 0.4);
        transition: all 0.3s ease;
        background: rgba(0, 0, 0, 0.3);
      }

      .fullscreen-scan-region.scanning {
        border-color: var(--color-red);
        box-shadow: 0 0 60px rgba(239, 68, 68, 0.4);
      }

      .fullscreen-scan-region.locked {
        border-color: #10b981;
        box-shadow: 0 0 60px rgba(16, 185, 129, 0.6);
      }

      #fullscreenReader {
        width: 100%;
        height: 100%;
        border-radius: var(--radius-lg);
        overflow: hidden;
      }

      #fullscreenReader video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: var(--radius-lg);
      }

      .fullscreen-instructions {
        color: rgba(255, 255, 255, 0.9);
        font-family: var(--font-sans);
        font-size: var(--font-size-lg);
        text-align: center;
        margin-top: var(--space-xl);
        padding: 0 var(--space-lg);
        max-width: 500px;
      }

      @media (max-width: 768px) {
        .fullscreen-scanner-container {
          width: 95vw;
        }

        .fullscreen-scanner-title {
          font-size: var(--font-size-lg);
        }

        .fullscreen-instructions {
          font-size: var(--font-size-base);
        }
      }

      /* Mobile Optimizations */
      @media (max-width: 480px) {
        .permission-content {
          width: 95%;
          padding: var(--space-xl);
        }

        .permission-buttons {
          flex-direction: column;
        }

        .permission-btn {
          width: 100%;
        }

        .device-instructions {
          padding: var(--space-md);
        }

        .error-actions {
          flex-direction: column;
          align-items: center;
        }

        .error-btn {
          width: 200px;
        }

        .loading-text {
          font-size: var(--font-size-base);
        }

        .error-title {
          font-size: var(--font-size-lg);
        }
      }

      /* Accessibility Enhancements */
      .permission-modal:focus-within .permission-content,
      .scanner-error:focus-within,
      .scanner-loading:focus-within {
        outline: 3px solid var(--color-blue);
        outline-offset: 2px;
      }

      .permission-btn:focus,
      .error-btn:focus {
        outline: 3px solid var(--color-blue);
        outline-offset: 2px;
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .permission-content,
        .scanner-error,
        .scanner-loading {
          border: 2px solid var(--color-text-primary);
        }

        .loading-spinner {
          border-left-color: var(--color-text-primary);
        }
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        .scan-region {
          animation: none;
        }

        .result-modal,
        .result-content,
        .permission-content,
        .scanner-success {
          animation: none;
        }

        .activity-item {
          animation: none;
        }

        .stat-value.pulsing {
          animation: none;
        }

        .activity-item:hover {
          transform: none;
        }

        .control-btn:active,
        .menu-btn:active,
        .permission-btn:hover,
        .error-btn:hover {
          transform: none;
        }

        .loading-spinner {
          animation: none;
          border: 4px solid var(--color-blue);
        }
      }
    </style>
  </head>
  <body>
    <!-- Mobile Hamburger Menu Toggle -->
    <button class="admin-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
      <div class="admin-menu-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </button>

    <!-- Mobile Navigation (Hidden on Desktop) -->
    <nav class="admin-navigation">
      <ul class="admin-nav-list">
        <!-- Core Tools Group -->
        <li role="presentation" class="admin-nav-group-header">Core Tools</li>
        <li class="admin-nav-item">
          <a href="/admin" class="admin-nav-link">
            <span class="nav-icon">🏠</span>
            <span>Portal</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/dashboard" class="admin-nav-link">
            <span class="nav-icon">📊</span>
            <span>Dashboard</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/checkin" class="admin-nav-link active">
            <span class="nav-icon">📱</span>
            <span>Check-in Scanner</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/manual-entry" class="admin-nav-link">
            <span class="nav-icon">✏️</span>
            <span>Manual Entry</span>
          </a>
        </li>

        <!-- Data & Analytics Group -->
        <li role="presentation" aria-hidden="true" class="admin-nav-separator"></li>
        <li role="presentation" class="admin-nav-group-header">Data & Analytics</li>
        <li class="admin-nav-item">
          <a href="/admin/tickets" class="admin-nav-link">
            <span class="nav-icon">🎫</span>
            <span>Tickets</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/analytics" class="admin-nav-link">
            <span class="nav-icon">📈</span>
            <span>Analytics</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/donations" class="admin-nav-link">
            <span class="nav-icon">💝</span>
            <span>Donations</span>
          </a>
        </li>

        <!-- Utilities Group -->
        <li role="presentation" aria-hidden="true" class="admin-nav-separator"></li>
        <li role="presentation" class="admin-nav-group-header">Utilities</li>
        <li class="admin-nav-item">
          <a href="/admin/test" class="admin-nav-link">
            <span class="nav-icon">🧪</span>
            <span>Test</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/api-endpoints" class="admin-nav-link">
            <span class="nav-icon">🔌</span>
            <span>API Endpoints</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/audit-logs" class="admin-nav-link">
            <span class="nav-icon">📋</span>
            <span>Audit Logs</span>
          </a>
        </li>
      </ul>
    </nav>

    <div class="scanner-app">
      <div class="app-header">
        <button
          class="menu-btn admin-menu-toggle"
          onclick="toggleMobileMenu()"
          aria-label="Open menu"
          aria-expanded="false"
          title="Open navigation menu"
        >
          ☰
        </button>
        <div class="app-title-container">
          <div class="app-portal-label">Portal</div>
          <h1 class="app-title" data-testid="scanner-title">
            Check-In Scanner
          </h1>
        </div>
        <!-- Event Selector -->
        <div id="event-selector-container" style="flex: 1; display: flex; justify-content: flex-end; padding-right: var(--space-md);"></div>
      </div>

      <!-- Mobile Navigation Menu -->
      <nav class="admin-nav-list" role="navigation" aria-label="Admin navigation">
        <a href="/admin/dashboard" class="admin-nav-link">
          📊 Dashboard
        </a>
        <a href="/admin/tickets" class="admin-nav-link">
          🎫 Tickets
        </a>
        <a href="/admin/registrations" class="admin-nav-link">
          📝 Registrations
        </a>
        <a href="/admin/checkin" class="admin-nav-link">
          📷 Check-In Scanner
        </a>
        <hr class="admin-nav-divider">
        <button onclick="logout()" class="admin-nav-link admin-nav-logout">
          🚪 Logout
        </button>
      </nav>

      <div class="admin-alert error offline-indicator" id="offlineIndicator">
        <div class="alert-title">📵 Offline Mode</div>
        <div class="alert-content">Check-ins will sync when connected</div>
      </div>

      <div class="scanner-container" data-testid="scanner-container">
        <!-- Test Mode Indicator for Scanner -->
        <div id="scannerTestModeIndicator" class="test-mode-indicator" style="display: none;">
          <span class="test-icon">🧪</span>
          <span class="test-text">Test Mode: Scanner contains test data</span>
        </div>

        <!-- Stats Bar -->
        <div id="statsBar" class="stats-bar">
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('today')" title="Click to view today's check-ins">
            <div class="stat-value" id="statToday">0</div>
            <div class="stat-label">Today</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('session')" title="Click to view this session's check-ins">
            <div class="stat-value" id="statSession">0</div>
            <div class="stat-label">Session</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('apple_wallet')" title="Click to view Apple Wallet check-ins">
            <div class="stat-value" id="statAppleWallet">0</div>
            <div class="stat-label">🍎 Apple</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('google_wallet')" title="Click to view Google Wallet check-ins">
            <div class="stat-value" id="statGoogleWallet">0</div>
            <div class="stat-label">📱 Google</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('total')" title="Click to view all checked-in tickets">
            <div class="stat-value" id="statTotal">0</div>
            <div class="stat-label">Total</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statFailed">0</div>
            <div class="stat-label">Failed</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statInvalid">0</div>
            <div class="stat-label">Invalid</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="statAvgTime">0s</div>
            <div class="stat-label">Avg Time</div>
          </div>
        </div>

        <!-- Scanner Loading State -->
        <div id="scannerLoading" class="scanner-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <div id="loadingText" class="loading-text">Initializing camera...</div>
          <div id="loadingSubtext" class="loading-subtext">Please allow camera permissions</div>
        </div>

        <!-- Recent Activity Feed -->
        <div class="recent-activity">
          <h3 class="activity-header">Recent Scans</h3>
          <div id="activityFeed" class="activity-list">
            <div class="activity-empty">Waiting for scans...</div>
          </div>
        </div>

        <div class="controls">
          <button
            class="control-btn admin-btn admin-btn-primary"
            onclick="openFullscreenScanner()"
            title="Scan Ticket - Camera permissions are saved by your browser and persist across sessions"
            style="font-size: 24px;"
          >
            📷
          </button>
          <button
            class="control-btn manual admin-btn"
            onclick="showManualInput()"
            data-testid="manual-input-toggle"
            title="Manual Entry"
          >
            ⌨️
          </button>
          <button class="control-btn admin-btn" onclick="location.reload()" title="Refresh Scanner">
            🔄
          </button>
        </div>
      </div>
    </div>

    <div class="result-modal" id="resultModal">
      <div class="result-content" id="resultContent">
        <div class="result-icon" id="resultIcon"></div>
        <div
          class="result-title"
          id="resultTitle"
          data-testid="validation-result"
        ></div>
        <div
          class="result-details"
          id="resultDetails"
          data-testid="ticket-info"
        ></div>
        <button class="result-btn admin-btn admin-btn-primary" onclick="closeResult()">
          Continue Scanning
        </button>
      </div>
    </div>

    <!-- Checked-In Tickets Overlay -->
    <div class="tickets-overlay" id="ticketsOverlay">
      <div class="tickets-overlay-content">
        <div class="tickets-overlay-header">
          <h3 id="ticketsOverlayTitle">Checked-In Tickets</h3>
          <button class="tickets-overlay-close" onclick="closeTicketsOverlay()" aria-label="Close">✕</button>
        </div>
        <div class="tickets-overlay-body">
          <div class="tickets-loading" id="ticketsLoading">
            <div class="loading-spinner"></div>
            <p>Loading tickets...</p>
          </div>
          <div class="tickets-error" id="ticketsError" style="display: none;"></div>
          <div class="tickets-table-container" id="ticketsTableContainer" style="display: none;">
            <table class="tickets-table">
              <thead>
                <tr>
                  <th>Ticket ID</th>
                  <th>First Name</th>
                  <th>Last Name</th>
                  <th>Source</th>
                  <th>Scan Time (MT)</th>
                </tr>
              </thead>
              <tbody id="ticketsTableBody">
                <!-- Rows populated by JavaScript -->
              </tbody>
            </table>
          </div>
          <div class="tickets-pagination" id="ticketsPagination" style="display: none;">
            <button class="pagination-btn" id="prevPageBtn" onclick="previousPage()" disabled>← Previous</button>
            <span class="pagination-info" id="paginationInfo">Page 1 of 1</span>
            <button class="pagination-btn" id="nextPageBtn" onclick="nextPage()" disabled>Next →</button>
          </div>
          <div class="tickets-empty" id="ticketsEmpty" style="display: none;">
            <p>No tickets found for this filter.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Permission Request Modal -->
    <div class="permission-modal" id="permissionModal" role="dialog" aria-labelledby="permissionTitle" aria-describedby="permissionDescription">
      <div class="permission-content">
        <div class="permission-icon" id="permissionIcon" aria-hidden="true">📷</div>
        <h3 class="permission-title" id="permissionTitle">Camera Access Required</h3>
        <p class="permission-description" id="permissionDescription">
          To scan QR codes, we need access to your device's camera. This allows you to quickly check in attendees by scanning their tickets.
        </p>
        <div class="device-instructions" id="deviceInstructions">
          <h4 id="deviceType">Camera Instructions</h4>
          <ol id="instructionsList">
            <li>Allow camera access when prompted</li>
            <li>Position QR codes within the scanning area</li>
            <li>Use manual entry if camera doesn't work</li>
          </ol>
        </div>
        <div class="permission-buttons">
          <button class="permission-btn primary" id="enableCamera" onclick="handlePermissionRequest()">
            📷 Enable Camera
          </button>
          <button class="permission-btn secondary" id="useManualOnly" onclick="useManualMode()">
            ⌨️ Manual Only
          </button>
        </div>
      </div>
    </div>

    <!-- Full-Screen Scanner Modal -->
    <div class="fullscreen-scanner-modal" id="fullscreenScannerModal">
      <div class="fullscreen-scanner-header">
        <div class="fullscreen-scanner-title">Scan Ticket QR Code</div>
        <button class="fullscreen-close-btn" onclick="closeFullscreenScanner()" aria-label="Close scanner">
          ✕
        </button>
      </div>
      <div class="fullscreen-scanner-container">
        <div class="fullscreen-scan-region scanning" id="fullscreenScanRegion">
          <div id="fullscreenReader"></div>
        </div>
        <div class="fullscreen-instructions">
          Position the QR code within the frame
        </div>
      </div>
    </div>

    <div class="manual-input-backdrop" id="manualBackdrop" onclick="hideManualInput()"></div>
    <div class="manual-input" id="manualInput">
      <h3>Manual Ticket Entry</h3>
      <input
        type="text"
        id="manualTicketId"
        class="admin-form-input"
        placeholder="Enter ticket ID..."
        autocomplete="off"
        data-testid="qr-manual-input"
      />
      <div class="manual-input-buttons">
        <button
          class="admin-btn admin-btn-primary"
          onclick="submitManualTicket()"
          data-testid="validate-ticket"
        >
          Check In
        </button>
      </div>
    </div>

    <!-- Event Selector Component -->
    <script src="/js/admin-event-selector.js"></script>
    <!-- QR Code Scanner -->
    <script src="/js/vendor/html5-qrcode.min.js" integrity="sha384-c9d8RFSL+u3exBOJ4Yp3HUJXS4znl9f+z66d1y54ig+ea249SpqR+w1wyvXz/lk+"></script>
    <script>
      let scanner = null;
      let sessionCount = 0;
      let isScanning = false;
      let timeManager = null;

      // Import timeManager
      import('/js/time-manager.js').then(module => {
        timeManager = module.default;
      });

      // HTML escaping function to prevent XSS attacks
      // CRITICAL: Use this for ALL user-provided data displayed in innerHTML
      function escapeHtml(unsafe) {
        if (unsafe == null) return "";
        return String(unsafe)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Statistics with localStorage persistence
      const STATS_STORAGE_KEY = 'scanner_stats_v2';
      const STATS_SESSION_HOURS = 8;

      const stats = {
        // Server baselines (loaded from API, never incremented)
        todayBaseline: 0,
        totalBaseline: 0,
        appleWalletBaseline: 0,
        googleWalletBaseline: 0,

        // Session increments (persisted, incremented locally)
        todayIncrement: 0,
        appleWalletIncrement: 0,
        googleWalletIncrement: 0,
        session: 0,
        failed: 0,
        invalid: 0,
        validationTimes: [],

        // Session metadata
        sessionStart: Date.now(),
        lastActivity: Date.now()
      };

      // Restore from localStorage
      function restoreSessionStats() {
        try {
          const stored = localStorage.getItem(STATS_STORAGE_KEY);
          if (!stored) return;

          const data = JSON.parse(stored);
          const age = (Date.now() - data.sessionStart) / (1000 * 60 * 60);

          // Expire after 8 hours
          if (age > STATS_SESSION_HOURS) {
            localStorage.removeItem(STATS_STORAGE_KEY);
            console.log('Session stats expired after 8 hours');
            return;
          }

          // Restore session stats only (not baselines)
          stats.todayIncrement = data.todayIncrement || 0;
          stats.walletIncrement = data.walletIncrement || 0;
          stats.session = data.session || 0;
          stats.queued = data.queued || 0;
          stats.failed = data.failed || 0;
          stats.invalid = data.invalid || 0;
          stats.validationTimes = data.validationTimes || [];
          stats.sessionStart = data.sessionStart;
          console.log('Restored session stats:', { session: stats.session, todayIncrement: stats.todayIncrement });
        } catch (error) {
          console.error('Failed to restore stats:', error);
        }
      }

      // Save to localStorage
      function persistSessionStats() {
        try {
          localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify({
            todayIncrement: stats.todayIncrement,
            walletIncrement: stats.walletIncrement,
            session: stats.session,
            queued: stats.queued,
            failed: stats.failed,
            invalid: stats.invalid,
            validationTimes: stats.validationTimes.slice(-100), // Keep last 100
            sessionStart: stats.sessionStart,
            lastActivity: Date.now()
          }));
        } catch (error) {
          console.error('Failed to persist stats:', error);
        }
      }

      // Initialize - restore previous session if exists
      restoreSessionStats();

      // Performance monitoring and resource management
      const performanceMonitor = {
        scanTimes: [],
        errorCounts: {
          network: 0,
          validation: 0,
          camera: 0,
          memory: 0
        },
        memoryUsage: [],
        batteryInfo: null,
        fps: 0,
        frameCount: 0,
        lastFrameTime: 0,
        isLowPowerMode: false,
        sessionStartTime: Date.now(),
        scanCount: 0,
        cacheHits: 0,
        cacheMisses: 0,

        // Device capability scoring (0-100)
        deviceScore: 0,
        adaptiveSettings: {
          fps: 10,
          resolution: 'medium',
          scanInterval: 100,
          memoryThreshold: 0.8,
          batteryThreshold: 0.2
        }
      };

      // Memory and resource management
      const resourceManager = {
        videoElement: null,
        mediaStream: null,
        cleanupTimers: [],
        memoryCheckInterval: null,
        performanceCheckInterval: null,
        lastCleanup: Date.now(),
        gcCallCount: 0,

        // Resource pooling for frequent allocations
        objectPool: {
          scanResults: [],
          tempArrays: [],
          imageData: []
        },

        // Lazy loading registry
        lazyComponents: new Map(),
        criticalResourcesLoaded: false
      };

      // Network optimization and caching
      const networkCache = {
        validationResults: new Map(),
        ticketData: new Map(),
        maxCacheSize: 100,
        cacheExpiry: 5 * 60 * 1000, // 5 minutes
        requestQueue: [],
        batchSize: 10,
        processingBatch: false
      };

      // Enhanced device and environment detection
      const deviceInfo = {
        isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
        isAndroid: /Android/.test(navigator.userAgent),
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        isChrome: /Chrome/.test(navigator.userAgent) && !/Edge|OPR/.test(navigator.userAgent),
        isPWA: window.matchMedia('(display-mode: standalone)').matches ||
               window.navigator.standalone === true,
        isIOSSafari: false,
        isAndroidChrome: false,
        version: null,
        androidVersion: null,
        chromeVersion: null
      };

      // Detect iOS Safari specifically
      deviceInfo.isIOSSafari = deviceInfo.isIOS && deviceInfo.isSafari;

      // Detect Android Chrome specifically
      deviceInfo.isAndroidChrome = deviceInfo.isAndroid && deviceInfo.isChrome;

      // Get iOS version if available
      if (deviceInfo.isIOS) {
        const match = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
        if (match) {
          deviceInfo.version = {
            major: parseInt(match[1]),
            minor: parseInt(match[2]),
            patch: parseInt(match[3] || 0)
          };
        }
      }

      // Get Android version if available
      if (deviceInfo.isAndroid) {
        const androidMatch = navigator.userAgent.match(/Android (\d+)\.?(\d+)?\.?(\d+)?/);
        if (androidMatch) {
          deviceInfo.androidVersion = {
            major: parseInt(androidMatch[1]),
            minor: parseInt(androidMatch[2] || 0),
            patch: parseInt(androidMatch[3] || 0)
          };
        }

        // Get Chrome version for Android Chrome
        if (deviceInfo.isChrome) {
          const chromeMatch = navigator.userAgent.match(/Chrome\/(\d+)\.?(\d+)?\.?(\d+)?/);
          if (chromeMatch) {
            deviceInfo.chromeVersion = {
              major: parseInt(chromeMatch[1]),
              minor: parseInt(chromeMatch[2] || 0),
              patch: parseInt(chromeMatch[3] || 0)
            };
          }
        }
      }

      // Permission state tracking with Android-specific persistence
      let permissionState = {
        granted: false,
        checked: false,
        persistent: false,
        androidPersistent: false // Android Chrome typically persists permissions
      };

      // Enhanced camera permission checker for both iOS and Android
      async function checkCameraPermissions() {
        try {
          // Android Chrome: Try navigator.permissions API first (well supported)
          if ('permissions' in navigator && 'camera' in navigator.permissions) {
            try {
              const result = await navigator.permissions.query({ name: 'camera' });
              permissionState.granted = result.state === 'granted';
              permissionState.persistent = result.state !== 'prompt';
              permissionState.checked = true;

              // Android Chrome has better permission persistence
              if (deviceInfo.isAndroidChrome) {
                permissionState.androidPersistent = result.state === 'granted';
                console.log(`Android Chrome permission via API: ${result.state} (persistent: ${permissionState.androidPersistent})`);

                // Set up permission change listener for Android
                result.addEventListener('change', () => {
                  permissionState.granted = result.state === 'granted';
                  permissionState.androidPersistent = result.state === 'granted';
                  console.log(`Android permission changed: ${result.state}`);
                });
              } else {
                console.log(`Camera permission via API: ${result.state}`);
              }

              return result.state;
            } catch (e) {
              console.log('Permissions API not supported, using fallback');
            }
          }

          // iOS Safari fallback: attempt getUserMedia to check permissions
          if (deviceInfo.isIOSSafari) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
              });

              // If we get here, permission is granted
              stream.getTracks().forEach(track => track.stop());
              permissionState.granted = true;
              permissionState.checked = true;
              permissionState.persistent = false; // iOS Safari asks every session

              console.log('iOS Safari: Camera permission granted via getUserMedia test');
              return 'granted';
            } catch (error) {
              permissionState.granted = false;
              permissionState.checked = true;

              if (error.name === 'NotAllowedError') {
                console.log('iOS Safari: Camera permission denied');
                return 'denied';
              } else if (error.name === 'NotFoundError') {
                console.log('iOS Safari: No camera found');
                return 'unavailable';
              } else {
                console.log('iOS Safari: Camera permission unknown:', error.name);
                return 'prompt';
              }
            }
          }

          // Android Chrome fallback: attempt getUserMedia to check permissions
          if (deviceInfo.isAndroidChrome) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
              });

              // If we get here, permission is granted
              stream.getTracks().forEach(track => track.stop());
              permissionState.granted = true;
              permissionState.checked = true;
              permissionState.androidPersistent = true; // Android Chrome typically persists

              console.log('Android Chrome: Camera permission granted via getUserMedia test');
              return 'granted';
            } catch (error) {
              permissionState.granted = false;
              permissionState.checked = true;

              if (error.name === 'NotAllowedError') {
                console.log('Android Chrome: Camera permission denied');
                return 'denied';
              } else if (error.name === 'NotFoundError') {
                console.log('Android Chrome: No camera found');
                return 'unavailable';
              } else {
                console.log('Android Chrome: Camera permission unknown:', error.name);
                return 'prompt';
              }
            }
          }

          return 'unknown';
        } catch (error) {
          console.error('Permission check failed:', error);
          return 'error';
        }
      }

      // Show iOS-specific permission guidance
      function showIOSPermissionGuidance() {
        const message = deviceInfo.isPWA
          ? 'Camera access in PWA mode may be limited. For best results:\n\n' +
            '1. Open this page in Safari directly\n' +
            '2. Allow camera access when prompted\n' +
            '3. Use manual entry if camera fails'
          : 'Camera access required for QR scanning:\n\n' +
            '1. Tap "Allow" when Safari asks for camera permission\n' +
            '2. If you previously denied access, go to Settings > Safari > Camera\n' +
            '3. You may need to allow permission each time you open the app';

        if (confirm(message + '\n\nTry manual entry instead?')) {
          showManualInput();
        }
      }

      // Show Android-specific permission guidance
      function showAndroidPermissionGuidance() {
        const message = deviceInfo.isPWA
          ? 'Camera access required for QR scanning. PWA detected:\n\n' +
            '1. Tap "Allow" when Chrome asks for camera permission\n' +
            '2. If denied, tap the camera icon in the address bar\n' +
            '3. Or go to Chrome Settings > Site Settings > Camera\n' +
            '4. Once granted, permission should persist across sessions'
          : 'Camera access required for QR scanning:\n\n' +
            '1. Tap "Allow" when Chrome asks for camera permission\n' +
            '2. If you previously denied access:\n' +
            '   - Tap the camera icon in the address bar, or\n' +
            '   - Go to Chrome Settings > Site Settings > Camera\n' +
            '3. Chrome typically remembers your choice for future visits';

        if (confirm(message + '\n\nTry manual entry instead?')) {
          showManualInput();
        }
      }

      // Show device-appropriate permission guidance
      function showPermissionGuidance() {
        if (deviceInfo.isIOSSafari) {
          showIOSPermissionGuidance();
        } else if (deviceInfo.isAndroidChrome) {
          showAndroidPermissionGuidance();
        } else {
          // Generic guidance for other browsers
          const message = 'Camera access required for QR scanning:\n\n' +
            '1. Allow camera access when prompted\n' +
            '2. Check browser settings if camera access was denied\n' +
            '3. Refresh the page and try again';

          if (confirm(message + '\n\nTry manual entry instead?')) {
            showManualInput();
          }
        }
      }

      // Get optimized scanner configuration for full-screen modal
      function getFullscreenScannerConfig() {
        // Calculate responsive scan box size (80% of viewport width, max 500px)
        const viewportWidth = window.innerWidth;
        const scanBoxSize = Math.min(viewportWidth * 0.8, 500);

        const config = {
          // Large responsive scan region
          qrbox: { width: scanBoxSize, height: scanBoxSize },

          // FPS will be set below based on power mode
          fps: 30,

          // QR_CODE format only for faster recognition
          formatsToSupport: typeof Html5QrcodeSupportedFormats !== 'undefined'
            ? [Html5QrcodeSupportedFormats.QR_CODE]
            : undefined,

          // Simple camera constraints
          videoConstraints: {
            facingMode: "environment"
          }
        };

        // Apply FPS based on power mode
        if (performanceMonitor.isLowPowerMode) {
          config.fps = performanceMonitor.adaptiveSettings.fps;
        } else {
          config.fps = deviceInfo.isIOS ? 20 : 30;
          performanceMonitor.adaptiveSettings.fps = config.fps;
        }

        console.log('Full-screen scanner config:', {
          fps: config.fps,
          qrbox: config.qrbox,
          formatsToSupport: 'QR_CODE only',
          isLowPowerMode: performanceMonitor.isLowPowerMode
        });

        return config;
      }

      // Performance monitoring and optimization functions
      function initializePerformanceMonitoring() {
        // Calculate device capability score
        performanceMonitor.deviceScore = calculateDeviceScore();

        // Set adaptive settings based on device score
        adaptivelyConfigureSettings();

        // Initialize battery monitoring if available
        initializeBatteryMonitoring();

        // Start memory monitoring
        startMemoryMonitoring();

        // Start performance metrics collection
        startPerformanceTracking();
      }

      function calculateDeviceScore() {
        let score = 50; // Base score

        // Memory assessment
        const memoryGB = navigator.deviceMemory || 4;
        score += Math.min(memoryGB * 5, 25); // Max 25 points for memory

        // CPU assessment (rough estimate based on user agent)
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('iphone 14') || userAgent.includes('iphone 15')) score += 20;
        else if (userAgent.includes('iphone 13') || userAgent.includes('iphone 12')) score += 15;
        else if (userAgent.includes('iphone 11') || userAgent.includes('iphone x')) score += 10;
        else if (userAgent.includes('iphone')) score += 5;

        // Android flagship detection
        if (userAgent.includes('pixel 7') || userAgent.includes('pixel 8')) score += 20;
        else if (userAgent.includes('galaxy s23') || userAgent.includes('galaxy s24')) score += 20;
        else if (userAgent.includes('galaxy s22') || userAgent.includes('galaxy s21')) score += 15;
        else if (userAgent.includes('android')) score += 5;

        // Browser optimizations
        if (deviceInfo.isAndroidChrome) score += 10;
        if (deviceInfo.isIOSSafari) score += 5;

        // Connection quality
        const connection = navigator.connection;
        if (connection) {
          if (connection.effectiveType === '4g') score += 10;
          else if (connection.effectiveType === '3g') score += 5;
          if (connection.saveData) score -= 10; // User wants to save data
        }

        return Math.min(Math.max(score, 0), 100);
      }

      function adaptivelyConfigureSettings() {
        const score = performanceMonitor.deviceScore;

        if (score >= 80) {
          // High-end device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 12 : 20;
          performanceMonitor.adaptiveSettings.resolution = 'high';
          performanceMonitor.adaptiveSettings.scanInterval = 50;
        } else if (score >= 60) {
          // Mid-range device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 10 : 15;
          performanceMonitor.adaptiveSettings.resolution = 'medium';
          performanceMonitor.adaptiveSettings.scanInterval = 100;
        } else {
          // Low-end device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 6 : 8;
          performanceMonitor.adaptiveSettings.resolution = 'low';
          performanceMonitor.adaptiveSettings.scanInterval = 200;
          performanceMonitor.isLowPowerMode = true;
        }

        console.log(`Device score: ${score}, Adaptive settings:`, performanceMonitor.adaptiveSettings);
      }

      async function initializeBatteryMonitoring() {
        try {
          if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            performanceMonitor.batteryInfo = {
              level: battery.level,
              charging: battery.charging,
              dischargingTime: battery.dischargingTime,
              chargingTime: battery.chargingTime
            };

            // Enable low power mode if battery is low
            if (battery.level < performanceMonitor.adaptiveSettings.batteryThreshold) {
              enableLowPowerMode();
            }

            // Listen for battery changes
            battery.addEventListener('levelchange', () => {
              performanceMonitor.batteryInfo.level = battery.level;
              if (battery.level < performanceMonitor.adaptiveSettings.batteryThreshold) {
                enableLowPowerMode();
              } else if (battery.level > 0.5 && performanceMonitor.isLowPowerMode) {
                disableLowPowerMode();
              }
            });

            battery.addEventListener('chargingchange', () => {
              performanceMonitor.batteryInfo.charging = battery.charging;
              if (battery.charging && performanceMonitor.isLowPowerMode) {
                disableLowPowerMode();
              }
            });
          }
        } catch (error) {
          console.log('Battery API not available:', error);
        }
      }

      function enableLowPowerMode() {
        if (performanceMonitor.isLowPowerMode) return;

        performanceMonitor.isLowPowerMode = true;

        // Reduce performance settings
        performanceMonitor.adaptiveSettings.fps = Math.max(4, performanceMonitor.adaptiveSettings.fps * 0.6);
        performanceMonitor.adaptiveSettings.scanInterval *= 2;

        // Restart scanner with low power settings if running
        if (isScanning) {
          console.log('Enabling low power mode, restarting scanner');
          restartScannerWithNewSettings();
        }

        console.log('Low power mode enabled');
      }

      function disableLowPowerMode() {
        if (!performanceMonitor.isLowPowerMode) return;

        performanceMonitor.isLowPowerMode = false;

        // Restore performance settings
        adaptivelyConfigureSettings();

        // Restart scanner with normal settings if running
        if (isScanning) {
          console.log('Disabling low power mode, restarting scanner');
          restartScannerWithNewSettings();
        }

        console.log('Low power mode disabled');
      }

      function startMemoryMonitoring() {
        const checkMemory = () => {
          try {
            if ('memory' in performance) {
              const memInfo = performance.memory;
              const usageRatio = memInfo.usedJSHeapSize / memInfo.totalJSHeapSize;

              performanceMonitor.memoryUsage.push({
                timestamp: Date.now(),
                used: memInfo.usedJSHeapSize,
                total: memInfo.totalJSHeapSize,
                ratio: usageRatio
              });

              // Keep only last 50 readings
              if (performanceMonitor.memoryUsage.length > 50) {
                performanceMonitor.memoryUsage.shift();
              }

              // Trigger cleanup if memory usage is high
              if (usageRatio > performanceMonitor.adaptiveSettings.memoryThreshold) {
                performMemoryCleanup();
              }
            }
          } catch (error) {
            console.log('Memory monitoring error:', error);
          }
        };

        resourceManager.memoryCheckInterval = setInterval(checkMemory, 10000); // Check every 10 seconds
        checkMemory(); // Initial check
      }

      function performMemoryCleanup() {
        const now = Date.now();

        // Avoid frequent cleanups
        if (now - resourceManager.lastCleanup < 30000) return;

        resourceManager.lastCleanup = now;
        resourceManager.gcCallCount++;

        try {
          // Clear old cache entries
          cleanupNetworkCache();

          // Clear performance monitoring arrays
          if (performanceMonitor.scanTimes.length > 20) {
            performanceMonitor.scanTimes = performanceMonitor.scanTimes.slice(-10);
          }

          if (performanceMonitor.memoryUsage.length > 20) {
            performanceMonitor.memoryUsage = performanceMonitor.memoryUsage.slice(-10);
          }

          // Return objects to pool
          while (resourceManager.objectPool.scanResults.length > 10) {
            resourceManager.objectPool.scanResults.pop();
          }

          // Force garbage collection if available
          if (window.gc) {
            window.gc();
          }

          console.log(`Memory cleanup performed (${resourceManager.gcCallCount} times)`);
          performanceMonitor.errorCounts.memory++;

        } catch (error) {
          console.error('Memory cleanup error:', error);
        }
      }

      function cleanupNetworkCache() {
        const now = Date.now();

        // Remove expired validation results
        for (const [key, value] of networkCache.validationResults.entries()) {
          if (now - value.timestamp > networkCache.cacheExpiry) {
            networkCache.validationResults.delete(key);
          }
        }

        // Remove expired ticket data
        for (const [key, value] of networkCache.ticketData.entries()) {
          if (now - value.timestamp > networkCache.cacheExpiry) {
            networkCache.ticketData.delete(key);
          }
        }

        // Limit cache size
        if (networkCache.validationResults.size > networkCache.maxCacheSize) {
          const entries = [...networkCache.validationResults.entries()];
          entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
          const toDelete = entries.slice(0, entries.length - networkCache.maxCacheSize + 10);
          toDelete.forEach(([key]) => networkCache.validationResults.delete(key));
        }
      }

      function startPerformanceTracking() {
        const trackPerformance = () => {
          try {
            // Calculate FPS
            const now = performance.now();
            if (performanceMonitor.lastFrameTime > 0) {
              const deltaTime = now - performanceMonitor.lastFrameTime;
              performanceMonitor.fps = 1000 / deltaTime;
            }
            performanceMonitor.lastFrameTime = now;
            performanceMonitor.frameCount++;

            // Collect performance entry data
            const entries = performance.getEntriesByType('measure');
            if (entries.length > 0) {
              const latestEntry = entries[entries.length - 1];
              console.log(`Performance: ${latestEntry.name} took ${latestEntry.duration.toFixed(2)}ms`);
            }

          } catch (error) {
            console.log('Performance tracking error:', error);
          }
        };

        resourceManager.performanceCheckInterval = setInterval(trackPerformance, 1000);
      }

      function measureScanPerformance(operation, startTime) {
        try {
          const endTime = performance.now();
          const duration = endTime - startTime;

          performanceMonitor.scanTimes.push({
            operation,
            duration,
            timestamp: Date.now()
          });

          // Keep only last 50 measurements
          if (performanceMonitor.scanTimes.length > 50) {
            performanceMonitor.scanTimes.shift();
          }

          // Log slow operations
          if (duration > 1000) {
            console.warn(`Slow ${operation}: ${duration.toFixed(2)}ms`);
          }

          return duration;
        } catch (error) {
          console.error('Performance measurement error:', error);
          return 0;
        }
      }

      function getPerformanceMetrics() {
        const metrics = {
          deviceScore: performanceMonitor.deviceScore,
          sessionDuration: Date.now() - performanceMonitor.sessionStartTime,
          scanCount: performanceMonitor.scanCount,
          averageScanTime: 0,
          errorRate: 0,
          memoryUsage: performanceMonitor.memoryUsage.slice(-1)[0],
          batteryInfo: performanceMonitor.batteryInfo,
          cacheHitRate: 0,
          isLowPowerMode: performanceMonitor.isLowPowerMode,
          adaptiveSettings: performanceMonitor.adaptiveSettings
        };

        // Calculate averages
        if (performanceMonitor.scanTimes.length > 0) {
          metrics.averageScanTime = performanceMonitor.scanTimes
            .reduce((sum, scan) => sum + scan.duration, 0) / performanceMonitor.scanTimes.length;
        }

        const totalErrors = Object.values(performanceMonitor.errorCounts)
          .reduce((sum, count) => sum + count, 0);
        metrics.errorRate = totalErrors / (performanceMonitor.scanCount + totalErrors);

        const totalCacheRequests = performanceMonitor.cacheHits + performanceMonitor.cacheMisses;
        if (totalCacheRequests > 0) {
          metrics.cacheHitRate = performanceMonitor.cacheHits / totalCacheRequests;
        }

        return metrics;
      }

      async function restartScannerWithNewSettings() {
        if (!scanner || !isScanning) return;

        try {
          await stopScanner();
          setTimeout(() => {
            initScanner();
          }, 500);
        } catch (error) {
          console.error('Error restarting scanner:', error);
        }
      }

      // Resource cleanup functions
      function cleanupResources() {
        try {
          // Clear all timers
          resourceManager.cleanupTimers.forEach(timer => clearTimeout(timer));
          resourceManager.cleanupTimers = [];

          if (resourceManager.memoryCheckInterval) {
            clearInterval(resourceManager.memoryCheckInterval);
            resourceManager.memoryCheckInterval = null;
          }

          if (resourceManager.performanceCheckInterval) {
            clearInterval(resourceManager.performanceCheckInterval);
            resourceManager.performanceCheckInterval = null;
          }

          // Clean up video element
          if (resourceManager.videoElement) {
            resourceManager.videoElement.srcObject = null;
            resourceManager.videoElement = null;
          }

          // Clean up media stream
          if (resourceManager.mediaStream) {
            resourceManager.mediaStream.getTracks().forEach(track => {
              track.stop();
            });
            resourceManager.mediaStream = null;
          }

          // Clear caches
          networkCache.validationResults.clear();
          networkCache.ticketData.clear();

          console.log('Resources cleaned up');
        } catch (error) {
          console.error('Error during resource cleanup:', error);
        }
      }

      // Lazy loading implementation
      function lazyLoadComponent(componentName, loader) {
        if (resourceManager.lazyComponents.has(componentName)) {
          return resourceManager.lazyComponents.get(componentName);
        }

        const promise = loader();
        resourceManager.lazyComponents.set(componentName, promise);
        return promise;
      }

      // Network caching for validation results
      function getCachedValidationResult(qrToken) {
        const cached = networkCache.validationResults.get(qrToken);
        if (cached && (Date.now() - cached.timestamp) < networkCache.cacheExpiry) {
          performanceMonitor.cacheHits++;
          return cached.data;
        }
        performanceMonitor.cacheMisses++;
        return null;
      }

      function setCachedValidationResult(qrToken, data) {
        networkCache.validationResults.set(qrToken, {
          data,
          timestamp: Date.now()
        });
      }

      // Batch network requests
      function addToRequestQueue(request) {
        networkCache.requestQueue.push(request);

        if (!networkCache.processingBatch) {
          scheduleRequestBatch();
        }
      }

      function scheduleRequestBatch() {
        networkCache.processingBatch = true;

        setTimeout(async () => {
          if (networkCache.requestQueue.length === 0) {
            networkCache.processingBatch = false;
            return;
          }

          const batch = networkCache.requestQueue.splice(0, networkCache.batchSize);

          try {
            // Process batch requests
            await Promise.allSettled(batch.map(request => request()));
          } catch (error) {
            console.error('Batch request error:', error);
          }

          networkCache.processingBatch = false;

          // Schedule next batch if more requests pending
          if (networkCache.requestQueue.length > 0) {
            scheduleRequestBatch();
          }
        }, 100);
      }

      // UI State Management
      const uiState = {
        isPermissionModalShown: false,
        isLoading: false,
        isError: false,
        loadingTimeout: null
      };

      // Show permission request modal with device-specific instructions
      function showPermissionModal() {
        if (uiState.isPermissionModalShown) return;

        const modal = document.getElementById('permissionModal');
        const icon = document.getElementById('permissionIcon');
        const title = document.getElementById('permissionTitle');
        const description = document.getElementById('permissionDescription');
        const deviceType = document.getElementById('deviceType');
        const instructionsList = document.getElementById('instructionsList');

        // Device-specific customization
        if (deviceInfo.isIOSSafari) {
          icon.textContent = '📱';
          title.textContent = 'iOS Camera Access';
          description.textContent = 'Safari needs permission to access your camera for QR code scanning. This helps you quickly check in attendees.';
          deviceType.textContent = 'iOS Safari Instructions';

          const instructions = deviceInfo.isPWA ? [
            'Tap "Allow" when Safari asks for camera permission',
            'If you previously denied access, go to Settings > Safari > Camera',
            'PWA mode may have limitations - use Safari directly if needed',
            'You may need to grant permission each time you open the app'
          ] : [
            'Tap "Allow" when Safari asks for camera permission',
            'If you previously denied access, go to Settings > Safari > Camera',
            'Grant permission each time if using private browsing',
            'Position QR codes clearly within the scanning area'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        } else if (deviceInfo.isAndroidChrome) {
          icon.textContent = '🤖';
          title.textContent = 'Android Camera Access';
          description.textContent = 'Chrome needs permission to access your camera for QR code scanning. This permission will be remembered for future visits.';
          deviceType.textContent = 'Android Chrome Instructions';

          const instructions = deviceInfo.isPWA ? [
            'Tap "Allow" when Chrome asks for camera permission',
            'Permission will be saved for future use in PWA mode',
            'If denied, tap the camera icon in the address bar',
            'Or go to Chrome Settings > Site Settings > Camera'
          ] : [
            'Tap "Allow" when Chrome asks for camera permission',
            'Chrome will remember your choice for future visits',
            'If previously denied, tap the camera icon in address bar',
            'Ensure good lighting for better QR code detection'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        } else {
          icon.textContent = '📷';
          title.textContent = 'Camera Access Required';
          description.textContent = 'Your browser needs permission to access the camera for QR code scanning. This enables quick attendee check-ins.';
          deviceType.textContent = 'Browser Instructions';

          const instructions = [
            'Allow camera access when your browser prompts',
            'Check browser settings if camera access was denied',
            'Refresh the page and try again if needed',
            'Use manual entry if camera issues persist'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        }

        modal.classList.add('show');
        uiState.isPermissionModalShown = true;

        // Announce to screen readers
        announceToScreenReader(`${title.textContent}. ${description.textContent} Press Enter to enable camera or Escape to use manual entry.`);

        // Focus the primary button for accessibility
        setTimeout(() => {
          document.getElementById('enableCamera').focus();
        }, 300);
      }

      // Hide permission modal
      function hidePermissionModal() {
        const modal = document.getElementById('permissionModal');
        modal.classList.remove('show');
        uiState.isPermissionModalShown = false;
      }

      // Handle permission request from modal
      async function handlePermissionRequest() {
        hidePermissionModal();
        showLoadingState('Requesting camera access...', 'Please allow camera permissions when prompted');

        try {
          await actuallyInitScanner();
        } catch (error) {
          console.error('Permission request failed:', error);
          showErrorState('Permission Denied', 'Camera access was not granted. You can retry or use manual entry.', 'permission');
        }
      }

      // Use manual mode only (bypass camera entirely)
      function useManualMode() {
        hidePermissionModal();
        showManualInput();
      }

      // Show loading state
      function showLoadingState(text = 'Initializing Camera', subtext = 'Please wait while we access your camera...') {
        if (uiState.isLoading) return;

        const loadingEl = document.getElementById('scannerLoading');
        const loadingText = document.getElementById('loadingText');
        const loadingSubtext = document.getElementById('loadingSubtext');

        if (!loadingEl || !loadingText || !loadingSubtext) {
          console.warn('Loading state elements not found');
          return;
        }

        loadingText.textContent = text;
        loadingSubtext.textContent = subtext;
        loadingEl.style.display = 'block';
        loadingEl.classList.add('show');
        uiState.isLoading = true;

        // Announce to screen readers
        announceToScreenReader(`${text}. ${subtext}`);

        // Auto-hide loading after 30 seconds as fallback
        uiState.loadingTimeout = setTimeout(() => {
          if (uiState.isLoading) {
            hideLoadingState();
            showErrorState('Timeout', 'Camera initialization took too long. Please try again.', 'timeout');
          }
        }, 30000);
      }

      // Hide loading state
      function hideLoadingState() {
        const loadingEl = document.getElementById('scannerLoading');
        if (!loadingEl) return;

        loadingEl.style.display = 'none';
        loadingEl.classList.remove('show');
        uiState.isLoading = false;

        if (uiState.loadingTimeout) {
          clearTimeout(uiState.loadingTimeout);
          uiState.loadingTimeout = null;
        }
      }

      // Show error state
      function showErrorState(title, message, errorType = 'generic') {
        hideLoadingState();

        const errorEl = document.getElementById('scannerError');
        const errorIcon = document.getElementById('errorIcon');
        const errorTitle = document.getElementById('errorTitle');
        const errorMessage = document.getElementById('errorMessage');
        const retryBtn = document.getElementById('retryCamera');
        const settingsBtn = document.getElementById('openSettings');

        errorTitle.textContent = title;
        errorMessage.textContent = message;

        // Customize based on error type
        switch (errorType) {
          case 'permission':
            errorIcon.textContent = '🚫';
            retryBtn.textContent = '🔄 Try Again';
            settingsBtn.style.display = 'inline-block';
            break;
          case 'not_found':
            errorIcon.textContent = '📷';
            retryBtn.textContent = '🔄 Retry';
            settingsBtn.style.display = 'none';
            break;
          case 'in_use':
            errorIcon.textContent = '⚠️';
            retryBtn.textContent = '🔄 Retry';
            settingsBtn.style.display = 'none';
            break;
          case 'timeout':
            errorIcon.textContent = '⏰';
            retryBtn.textContent = '🔄 Retry';
            settingsBtn.style.display = 'none';
            break;
          default:
            errorIcon.textContent = '❌';
            retryBtn.textContent = '🔄 Retry';
            settingsBtn.style.display = 'none';
        }

        errorEl.classList.add('show');
        uiState.isError = true;

        // Announce to screen readers
        const actions = settingsBtn.style.display !== 'none'
          ? 'Available options: Retry Camera, Manual Entry, or Settings'
          : 'Available options: Retry Camera or Manual Entry';
        announceToScreenReader(`${title}. ${message}. ${actions}. Press Escape to close.`);

        // Focus retry button for accessibility
        setTimeout(() => {
          retryBtn.focus();
        }, 300);
      }

      // Hide error state
      function hideErrorState() {
        const errorEl = document.getElementById('scannerError');
        errorEl.classList.remove('show');
        uiState.isError = false;
      }

      // Show success indicator
      function showSuccessIndicator(duration = 2000) {
        const successEl = document.getElementById('scannerSuccess');
        successEl.classList.add('show');

        // Announce to screen readers
        announceToScreenReader('Camera ready. Scanner is now active and ready to scan QR codes.');

        setTimeout(() => {
          successEl.classList.remove('show');
        }, duration);
      }

      // Retry scanner initialization
      function retryScanner() {
        hideErrorState();
        initScanner();
      }

      // Open camera settings (platform-specific)
      function openCameraSettings() {
        let message = 'To enable camera access:\n\n';

        if (deviceInfo.isIOSSafari) {
          message += 'iOS Safari:\n1. Go to Settings > Safari > Camera\n2. Select "Allow" for this website\n3. Refresh this page';
        } else if (deviceInfo.isAndroidChrome) {
          message += 'Android Chrome:\n1. Tap the camera icon in the address bar\n2. Select "Allow"\n3. Or go to Chrome Settings > Site Settings > Camera';
        } else {
          message += 'Browser Settings:\n1. Look for camera/permissions in browser settings\n2. Allow camera access for this website\n3. Refresh this page';
        }

        alert(message);
      }

      // Enhanced scanner initialization with iOS and Android support
      async function initScanner() {
        try {
          console.log('Initializing scanner...', deviceInfo);

          // Pre-check permissions based on device type
          const permissionResult = await checkCameraPermissions();

          if (permissionResult === 'denied') {
            showPermissionModal();
            return;
          } else if (permissionResult === 'unavailable') {
            showErrorState('No Camera Found', 'No camera was detected on this device. Please use manual entry.', 'not_found');
            return;
          } else if (permissionResult === 'prompt') {
            showPermissionModal();
            return;
          }

          await actuallyInitScanner();

        } catch (error) {
          console.error("Scanner initialization failed:", error);
          showErrorState('Initialization Failed', 'Failed to initialize camera scanner. Please try again or use manual entry.', 'generic');
        }
      }

      // Actual scanner initialization (separated for reuse)
      async function actuallyInitScanner() {
        const initStartTime = performance.now();
        showLoadingState('Starting camera...', 'Initializing QR code scanner');

        try {
          // Initialize performance monitoring if not already done
          if (performanceMonitor.deviceScore === 0) {
            initializePerformanceMonitoring();
          }

          // Initialize Html5QrCode instance
          scanner = new Html5Qrcode("reader");

          // Get device-optimized configuration
          const config = getFullscreenScannerConfig();
          console.log('Scanner config for', deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'generic', ':', config);

          // Device-agnostic camera constraints
          const cameraConstraints = {
            facingMode: "environment"
          };

          // Attempt to start scanner with error handling
          await scanner.start(
            cameraConstraints,
            config,
            onScanSuccess,
            onScanError
          );

          isScanning = true;
          console.log('Scanner started successfully');

          // Measure initialization performance
          measureScanPerformance('scanner_initialization', initStartTime);

          hideLoadingState();
          showSuccessIndicator();

          // Apply device-specific video attributes and memory optimization
          setTimeout(() => {
            const videoElement = document.querySelector('#reader video');
            if (videoElement) {
              // Store reference for resource management
              resourceManager.videoElement = videoElement;

              // Get media stream for proper cleanup
              if (videoElement.srcObject) {
                resourceManager.mediaStream = videoElement.srcObject;
              }

              if (deviceInfo.isIOS) {
                // iOS-specific attributes
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                videoElement.muted = true;

                // iOS memory optimization
                videoElement.style.objectFit = 'cover';
                videoElement.style.transformOrigin = 'center center';

                console.log('iOS video attributes and optimizations applied');
              } else if (deviceInfo.isAndroid) {
                // Android-specific attributes
                videoElement.setAttribute('playsinline', '');
                videoElement.muted = true;

                // Android Chrome specific optimizations
                if (deviceInfo.isAndroidChrome) {
                  videoElement.style.objectFit = 'cover';
                  videoElement.style.willChange = 'auto'; // Avoid unnecessary GPU layers
                  console.log('Android Chrome video attributes applied');
                }
              }

              // Universal performance optimizations
              videoElement.style.imageRendering = 'optimizeSpeed';
              videoElement.style.backfaceVisibility = 'hidden';

              // Add performance monitoring for video frames
              if (performanceMonitor.isLowPowerMode) {
                videoElement.style.transform = 'scale(0.8)'; // Reduce processing load
              }
            }
          }, 1000);

        } catch (startError) {
          console.error('Scanner start error:', startError);
          handleScannerStartError(startError);
        }
      }

      // Handle scanner start errors with device-specific messaging
      function handleScannerStartError(error) {
        console.error('Scanner start error details:', {
          name: error.name,
          message: error.message,
          code: error.code,
          device: deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'unknown'
        });

        let title, message, errorType;

        // iOS-specific error handling
        if (deviceInfo.isIOSSafari) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = deviceInfo.isPWA
              ? 'Camera access was denied. For PWA mode, you may need to open this page in Safari directly and grant permission.'
              : 'Camera access was denied. Please go to Settings > Safari > Camera to enable access for this website.';
            errorType = 'permission';
          } else if (error.name === 'OverconstrainedError') {
            // iOS-specific: camera constraints too restrictive
            console.log('iOS: Retrying with relaxed constraints');
            retryWithRelaxedConstraints();
            return;
          } else if (error.name === 'NotFoundError') {
            title = 'No Camera Found';
            message = 'This iOS device does not have a camera available for use.';
            errorType = 'not_found';
          } else {
            title = 'iOS Camera Error';
            message = `Camera initialization failed on iOS: ${error.message}`;
            errorType = 'generic';
          }
        }
        // Android-specific error handling
        else if (deviceInfo.isAndroidChrome) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = deviceInfo.isPWA
              ? 'Camera access was denied. Tap the camera icon in the address bar or go to Chrome Settings > Site Settings > Camera to enable access.'
              : 'Camera access was denied. Chrome will remember your choice. Tap the camera icon in the address bar to change permissions.';
            errorType = 'permission';
          } else if (error.name === 'OverconstrainedError') {
            // Android: try with fallback constraints
            console.log('Android: Retrying with relaxed constraints');
            retryWithRelaxedConstraints();
            return;
          } else if (error.name === 'NotFoundError') {
            title = 'No Camera Found';
            message = 'No camera was detected on this Android device.';
            errorType = 'not_found';
          } else if (error.name === 'AbortError') {
            title = 'Camera In Use';
            message = 'Camera is currently being used by another app. Please close other camera apps and try again.';
            errorType = 'in_use';
          } else if (error.name === 'NotReadableError') {
            title = 'Camera Unavailable';
            message = 'Camera is not accessible. It may be in use by another application or browser tab.';
            errorType = 'in_use';
          } else {
            title = 'Android Camera Error';
            message = `Camera initialization failed: ${error.message}`;
            errorType = 'generic';
          }
        }
        // Generic Android handling for non-Chrome browsers
        else if (deviceInfo.isAndroid && !deviceInfo.isChrome) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = 'Camera access was denied. For better camera support, consider using Chrome browser. Check your browser settings to enable camera access.';
            errorType = 'permission';
          } else {
            title = 'Camera Error';
            message = `Camera not available on this Android browser: ${error.message}. Consider using Chrome for better compatibility.`;
            errorType = 'generic';
          }
        }
        // General error handling for other platforms
        else {
          switch (error.name) {
            case 'NotAllowedError':
              title = 'Camera Permission Denied';
              message = 'Camera access was denied. Please check your browser settings and allow camera access for this website.';
              errorType = 'permission';
              break;
            case 'NotFoundError':
              title = 'No Camera Found';
              message = 'No camera was detected on this device.';
              errorType = 'not_found';
              break;
            case 'NotReadableError':
              title = 'Camera Unavailable';
              message = 'Camera is already in use by another application. Please close other camera apps and try again.';
              errorType = 'in_use';
              break;
            case 'OverconstrainedError':
              console.log('Generic: Retrying with relaxed constraints');
              retryWithRelaxedConstraints();
              return;
            case 'SecurityError':
              title = 'Security Error';
              message = 'Camera access blocked for security reasons. Please check your browser settings.';
              errorType = 'permission';
              break;
            default:
              title = 'Camera Error';
              message = `Camera initialization failed: ${error.message}`;
              errorType = 'generic';
          }
        }

        showErrorState(title, message, errorType);
      }

      // Handle scanner initialization errors
      function handleScannerInitError(error) {
        console.error('Scanner init error:', error);
        showErrorState('Initialization Failed', 'Failed to initialize camera scanner. Please use manual entry mode.', 'generic');
      }

      // Retry scanner with relaxed constraints (device-agnostic fallback)
      async function retryWithRelaxedConstraints() {
        try {
          console.log('Retrying scanner with relaxed constraints for',
            deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'generic device');

          showLoadingState('Retrying with relaxed settings...', 'Attempting camera initialization with compatibility mode');

          if (scanner) {
            try {
              await scanner.stop();
            } catch (e) {
              console.log('Error stopping scanner during retry:', e);
            }
          }

          scanner = new Html5Qrcode("reader");

          // Device-specific relaxed configurations
          let relaxedConfig;

          if (deviceInfo.isIOS) {
            relaxedConfig = {
              fps: 5,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              videoConstraints: {
                facingMode: "environment"
                // Remove resolution constraints for iOS compatibility
              }
            };
          } else if (deviceInfo.isAndroid) {
            relaxedConfig = {
              fps: deviceInfo.isAndroidChrome ? 10 : 8,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              experimentalFeatures: {
                useBarCodeDetectorIfSupported: false // Disable for stability during retry
              },
              videoConstraints: {
                facingMode: "environment",
                // Minimal constraints for Android compatibility
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            };
          } else {
            // Generic fallback
            relaxedConfig = {
              fps: 8,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              videoConstraints: {
                facingMode: "environment"
              }
            };
          }

          await scanner.start(
            { facingMode: { ideal: "environment" } },
            relaxedConfig,
            onScanSuccess,
            onScanError
          );

          isScanning = true;
          console.log('Scanner started with relaxed constraints');

          hideLoadingState();
          showSuccessIndicator();

        } catch (retryError) {
          console.error('Retry failed:', retryError);

          // Device-specific retry failure messages
          let title = 'Retry Failed';
          let message = 'Camera scanner could not be initialized even with relaxed settings. Please use manual entry.';

          if (deviceInfo.isAndroidChrome && retryError.name === 'OverconstrainedError') {
            title = 'Android Compatibility Issue';
            message = 'This Android device\'s camera doesn\'t support the required settings for QR scanning.';
          } else if (deviceInfo.isIOS && retryError.name === 'OverconstrainedError') {
            title = 'iOS Compatibility Issue';
            message = 'iOS camera constraints not supported on this device. Manual entry is recommended.';
          } else if (retryError.name === 'NotAllowedError') {
            title = 'Permission Still Denied';
            message = 'Camera access is still denied. Please check your browser settings or use manual entry.';
          }

          showErrorState(title, message, 'generic');
        }
      }

      // Stop scanner safely with enhanced resource cleanup
      async function stopScanner() {
        if (scanner && isScanning) {
          const stopStartTime = performance.now();

          try {
            await scanner.stop();
            isScanning = false;

            // Enhanced resource cleanup
            if (resourceManager.mediaStream) {
              resourceManager.mediaStream.getTracks().forEach(track => {
                track.stop();
                console.log(`Stopped ${track.kind} track`);
              });
              resourceManager.mediaStream = null;
            }

            // Clean up video element reference
            if (resourceManager.videoElement) {
              resourceManager.videoElement.srcObject = null;
              resourceManager.videoElement = null;
            }

            // Measure stop performance
            measureScanPerformance('scanner_stop', stopStartTime);

            console.log('Scanner stopped with resource cleanup');
          } catch (error) {
            console.error('Error stopping scanner:', error);
            performanceMonitor.errorCounts.camera++;
            isScanning = false;

            // Force cleanup even if stop failed
            try {
              if (resourceManager.mediaStream) {
                resourceManager.mediaStream.getTracks().forEach(track => track.stop());
                resourceManager.mediaStream = null;
              }
            } catch (cleanupError) {
              console.error('Force cleanup error:', cleanupError);
            }
          }
        }
      }

      // Add visibility change handler for mobile browser background behavior
      document.addEventListener('visibilitychange', function() {
        if (scanner) {
          if (document.hidden) {
            // Page hidden, stop scanner to free camera resources
            console.log('Page hidden, stopping scanner for', deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'unknown device');
            stopScanner();
          } else {
            // Page visible again, restart scanner if needed
            const restartDelay = deviceInfo.isIOS ? 500 : deviceInfo.isAndroid ? 300 : 400;

            setTimeout(() => {
              if (!isScanning) {
                console.log('Page visible, restarting scanner for', deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'unknown device');
                initScanner();
              }
            }, restartDelay);
          }
        }
      });

      // Android-specific: Handle page focus/blur for better camera resource management
      if (deviceInfo.isAndroid) {
        window.addEventListener('blur', function() {
          if (scanner && isScanning) {
            console.log('Android: Window lost focus, pausing scanner');
            // Android Chrome might need explicit camera release when switching apps
            setTimeout(() => {
              if (document.hidden && isScanning) {
                stopScanner();
              }
            }, 1000);
          }
        });

        window.addEventListener('focus', function() {
          if (scanner && !isScanning && !document.hidden) {
            console.log('Android: Window gained focus, checking scanner state');
            setTimeout(() => {
              if (!isScanning && !document.hidden) {
                initScanner();
              }
            }, 500);
          }
        });
      }

      // PWA-specific handling for both iOS and Android
      if (deviceInfo.isPWA) {
        // Handle PWA lifecycle events
        window.addEventListener('beforeinstallprompt', function(e) {
          console.log('PWA install prompt available');
        });

        // Handle PWA app state changes
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'PWA_STATE_CHANGE') {
              console.log('PWA state changed:', event.data.state);
              // Restart scanner if needed after PWA state change
              if (event.data.state === 'active' && !isScanning) {
                setTimeout(() => initScanner(), 1000);
              }
            }
          });
        }
      }

      // Enhanced cleanup when page unloads
      window.addEventListener('beforeunload', function() {
        try {
          // Stop scanner
          if (scanner) {
            scanner.stop();
          }

          // Comprehensive resource cleanup
          cleanupResources();

          // Send performance metrics if available
          if (navigator.sendBeacon && performanceMonitor.scanCount > 0) {
            const metrics = getPerformanceMetrics();
            navigator.sendBeacon('/api/performance-metrics', JSON.stringify({
              session: metrics,
              timestamp: Date.now(),
              userAgent: navigator.userAgent,
              deviceScore: performanceMonitor.deviceScore
            }));
          }

        } catch (error) {
          console.log('Enhanced cleanup error:', error);
        }
      });

      /**
       * Extract JWT token from QR code content
       * QR codes contain: https://domain.com/my-ticket#TOKEN
       * We need to extract just the TOKEN part for validation
       */
      function extractTokenFromQR(qrContent) {
        try {
          // Check if it's a my-ticket URL with hash
          if (qrContent.includes('#')) {
            const hashIndex = qrContent.indexOf('#');
            if (hashIndex >= 0) {
              const extracted = qrContent.substring(hashIndex + 1);
              console.log('Token extracted successfully from URL');
              return extracted;
            }
          }

          // If no hash, assume it's already a token
          console.log('Processing QR code content');
          return qrContent;
        } catch (error) {
          console.error('Error extracting token from QR - invalid format');
          return qrContent;
        }
      }

      // Handle successful scan with performance tracking
      async function onScanSuccess(decodedText) {
        if (!isScanning) return;

        const scanStartTime = performance.now();

        // Prevent multiple scans
        isScanning = false;

        // Visual feedback: Show green border (QR locked on)
        const scanRegion = document.querySelector('.scan-region');
        if (scanRegion) {
          scanRegion.classList.remove('scanning');
          scanRegion.classList.add('locked');
        }

        // Update scan count for performance monitoring
        performanceMonitor.scanCount++;

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(200);
        }

        // Validate QR code with performance tracking
        try {
          await validateTicket(extractTokenFromQR(decodedText));
          measureScanPerformance('scan_success', scanStartTime);
        } catch (error) {
          performanceMonitor.errorCounts.validation++;
          console.error('Validation error:', error);
        }

        // Resume scanning after adaptive delay
        const resumeDelay = performanceMonitor.isLowPowerMode ? 3000 : 2000;
        setTimeout(() => {
          isScanning = true;

          // Visual feedback: Return to red border (scanning state)
          if (scanRegion) {
            scanRegion.classList.remove('locked');
            scanRegion.classList.add('scanning');
          }
        }, resumeDelay);
      }

      // Handle scan errors (ignore)
      function onScanError(error) {
        // Ignore scan errors
      }

      // Validate ticket (QR code or JWT wallet token) with caching
      async function validateTicket(token) {
        const validationStartTime = performance.now();

        try {
          // Check cache first for performance
          const cachedResult = getCachedValidationResult(token);
          if (cachedResult) {
            console.log('Using cached validation result');
            showResult(cachedResult.status, cachedResult.title, cachedResult.message);
            measureScanPerformance('validation_cached', validationStartTime);
            return;
          }

          // Detect wallet tokens (JWT format)
          const isWalletToken = token.includes(".") && token.length > 100;

          // Get selected event ID from event selector
          const selectedEventId = window.eventSelector ? window.eventSelector.getSelectedEventId() : null;

          // Get CSRF token for admin operations (only if admin authenticated)
          let headers = { "Content-Type": "application/json" };
          try {
            const csrfResponse = await fetch("/api/admin/csrf-token", {
              credentials: "include"
            });
            if (csrfResponse.ok) {
              const csrfData = await csrfResponse.json();
              headers["X-CSRF-Token"] = csrfData.token;
            }
          } catch (error) {
            // Not admin authenticated, continue without CSRF token
            console.log("Not admin authenticated, continuing without CSRF token");
          }

          const response = await fetch("/api/tickets/validate", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              token: token,
              validatedBy: "admin-scanner",
              location: "entrance",
              wallet_source: isWalletToken ? "jwt" : null,
              qr_access_method: isWalletToken ? "wallet" : "qr_code",
              event_id: selectedEventId,
            }),
            credentials: "include"
          });

          const data = await response.json();

          if (data.offline) {
            // Offline check-in
            stats.queued++;
            showResult(
              "queued",
              "Queued for Sync",
              `Check-in saved offline (${stats.queued} in queue)`,
            );
          } else if (data.valid) {
            // Success
            stats.session++;
            stats.todayIncrement++;  // Increment session overlay, not baseline

            // Increment wallet-specific counters
            if (data.ticket && data.ticket.wallet_source) {
              if (data.ticket.wallet_source === 'apple_wallet') {
                stats.appleWalletIncrement++;
              } else if (data.ticket.wallet_source === 'google_wallet' || data.ticket.wallet_source === 'samsung_wallet') {
                stats.googleWalletIncrement++;
              }
            }

            // Detect if this is a test ticket
            const isTestTicket = data.ticket && (
              data.ticket.is_test === true ||
              data.ticket.ticket_id?.startsWith('TEST-') ||
              data.ticket.attendeeName?.includes('Test') ||
              data.ticket.type?.includes('test')
            );

            // Show wallet badge if from wallet
            const walletBadge =
              data.ticket && data.ticket.wallet_source ? "📱 " : "🎫 ";
            const accessMethod =
              data.ticket && data.ticket.qr_access_method === "wallet"
                ? " (Wallet)"
                : "";

            if (data.ticket) {
              const resultTitle = isTestTicket ?
                `🧪 ${walletBadge}Valid Test Ticket!` :
                `${walletBadge}Valid Ticket!`;

              showResult(
                "success",
                resultTitle,
                `${data.ticket.attendee}\n${data.ticket.type}${accessMethod}\nScan ${data.ticket.scanCount}/${data.ticket.maxScans}`,
                isTestTicket,
                data.ticket.ticket_id,
                data.ticket.wallet_source
              );
            } else {
              showResult("success", "Valid Ticket!", "Check-in successful", false, null, null);
            }
          } else {
            // Invalid ticket
            stats.invalid++;
            showResult(
              "error",
              "Invalid Ticket",
              data.error || "This ticket cannot be validated",
            );
          }

          // Track validation time
          const validationTime = performance.now() - validationStartTime;
          stats.validationTimes.push(validationTime);
          // Keep only last 100 validation times to avoid memory bloat
          if (stats.validationTimes.length > 100) {
            stats.validationTimes.shift();
          }

          // Update stats AFTER validation time is recorded
          // This ensures average time includes the current scan
          updateStats();

          // Measure successful validation performance
          measureScanPerformance('validation_network', validationStartTime);

        } catch (error) {
          console.error("Validation error:", error);
          performanceMonitor.errorCounts.network++;

          // Track failed validation (network/system error)
          stats.failed++;

          // Queue for offline sync
          stats.queued++;
          updateStats();
          const result = {
            status: "queued",
            title: "Queued for Sync",
            message: "No connection - check-in saved"
          };
          showResult(result.status, result.title, result.message);

          // Cache the offline result briefly to prevent immediate retries
          setCachedValidationResult(token, result);

          // Measure error performance
          measureScanPerformance('validation_error', validationStartTime);
        }
      }

      // Show result modal
      function showResult(type, title, details, isTestTicket = false, ticketId = null, walletSource = null) {
        const modal = document.getElementById("resultModal");
        const content = document.getElementById("resultContent");
        const icon = document.getElementById("resultIcon");
        const titleEl = document.getElementById("resultTitle");
        const detailsEl = document.getElementById("resultDetails");

        // Detect if this is a test ticket from details or title
        const isTestScan = isTestTicket || title.includes('TEST') || details.includes('TEST-') || details.includes('🧪');

        // Set content with test mode awareness
        if (type === "success") {
          content.className = `result-content success ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "🧪" : "✅";
          content.setAttribute("data-testid", "checkin-success");

          // Haptic feedback for successful scan
          if (navigator.vibrate) {
            navigator.vibrate([50, 30, 50]); // Double tap pattern
          }
        } else if (type === "error") {
          content.className = `result-content error ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "🧪❌" : "❌";
          content.setAttribute("data-testid", "validation-error");
        } else if (type === "queued") {
          content.className = `result-content ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "🧪📥" : "📥";
          content.setAttribute("data-testid", "network-error");
        }

        // Update title and details with test mode indicators
        titleEl.textContent = isTestScan && !title.includes('🧪') ? `🧪 ${title}` : title;

        // For success scans, enhance display with prominent attendee name
        if (type === 'success' && details.includes('\n')) {
          const lines = details.split('\n');
          const attendeeName = lines[0];
          const otherDetails = lines.slice(1).join('\n');

          // XSS Fix: Escape user-provided data before injecting into innerHTML
          detailsEl.innerHTML = `
            <div style="font-size: var(--font-size-xl); font-weight: 700; margin-bottom: var(--space-sm); font-family: var(--font-display);">
              ${escapeHtml(attendeeName)}
            </div>
            <div style="opacity: 0.85;">
              ${escapeHtml(otherDetails)}
            </div>
          `;
        } else {
          detailsEl.textContent = details;
        }

        // Add to activity feed
        addToActivityFeed({
          type: type,
          title: title,
          details: details,
          isTestTicket: isTestScan,
          ticketId: ticketId,
          walletSource: walletSource
        });

        // Show modal
        modal.classList.add("show");

        // Auto-close after 3 seconds
        setTimeout(() => {
          closeResult();
        }, 3000);
      }

      // Close result modal
      function closeResult() {
        document.getElementById("resultModal").classList.remove("show");
      }

      // Full-Screen Scanner Functions
      let fullscreenScanner = null;
      let isFullscreenScanning = false;

      async function openFullscreenScanner() {
        // If the inline scanner is running, stop it to release camera
        // This prevents NotReadableError ("device already in use") on mobile devices
        if (isScanning && scanner) {
          await stopScanner();
        }

        const modal = document.getElementById('fullscreenScannerModal');
        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Show modal
        modal.classList.add('active');

        // Initialize scanner
        try {
          fullscreenScanner = new Html5Qrcode("fullscreenReader");

          const config = getFullscreenScannerConfig();

          await fullscreenScanner.start(
            { facingMode: "environment" },
            config,
            onFullscreenScanSuccess,
            onFullscreenScanFailure
          );

          isFullscreenScanning = true;
          scanRegion.classList.add('scanning');
          console.log('Full-screen scanner started successfully');

        } catch (error) {
          console.error('Failed to start full-screen scanner:', error);
          alert('Failed to access camera. Please check permissions and try again.');
          closeFullscreenScanner();
        }
      }

      async function closeFullscreenScanner() {
        const modal = document.getElementById('fullscreenScannerModal');
        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Stop scanner
        if (fullscreenScanner) {
          try {
            await fullscreenScanner.stop();
            fullscreenScanner.clear();
          } catch (error) {
            console.log('Error stopping scanner:', error);
          }
          fullscreenScanner = null;
        }

        isFullscreenScanning = false;
        scanRegion.classList.remove('scanning', 'locked');
        modal.classList.remove('active');

        // After closing fullscreen, restart the inline scanner if it was running
        if (!isScanning && scanner) {
          try {
            await initScanner();
          } catch (error) {
            console.log('Error restarting inline scanner:', error);
          }
        }
      }

      async function onFullscreenScanSuccess(decodedText) {
        if (!isFullscreenScanning) return;

        isFullscreenScanning = false;

        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Visual feedback: green border (locked on QR)
        scanRegion.classList.remove('scanning');
        scanRegion.classList.add('locked');

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(200);
        }

        // Validate ticket
        try {
          await validateTicket(extractTokenFromQR(decodedText));

          // Close scanner after short delay
          setTimeout(async () => {
            await closeFullscreenScanner();
          }, 500);

        } catch (error) {
          console.error('Validation error:', error);

          // Resume scanning after error
          setTimeout(() => {
            isFullscreenScanning = true;
            scanRegion.classList.remove('locked');
            scanRegion.classList.add('scanning');
          }, 2000);
        }
      }

      function onFullscreenScanFailure(error) {
        // Silently handle scan failures (normal during scanning)
        // Only log if it's an actual error, not just "No QR code found"
        if (error && !error.includes && !error.toString().includes('NotFoundException')) {
          console.log('Scan error:', error);
        }
      }

      // Show manual input with backdrop
      function showManualInput() {
        document.getElementById("manualBackdrop").classList.add("show");
        document.getElementById("manualInput").classList.add("show");
        document.getElementById("manualTicketId").focus();
      }

      // Hide manual input and backdrop
      function hideManualInput() {
        document.getElementById("manualBackdrop").classList.remove("show");
        document.getElementById("manualInput").classList.remove("show");
        document.getElementById("manualTicketId").value = "";
      }

      // Enhanced keyboard navigation and accessibility
      document.addEventListener('keydown', (e) => {
        // Escape key handling
        if (e.key === 'Escape') {
          if (document.getElementById("permissionModal").classList.contains("show")) {
            e.preventDefault();
            useManualMode(); // Escape from permission modal goes to manual mode
          } else if (document.getElementById("manualInput").classList.contains("show")) {
            e.preventDefault();
            hideManualInput();
          } else if (uiState.isError) {
            e.preventDefault();
            hideErrorState();
          }
        }

        // Enter key handling for permission modal
        if (e.key === 'Enter' && document.getElementById("permissionModal").classList.contains("show")) {
          e.preventDefault();
          handlePermissionRequest();
        }

        // Tab navigation for error state
        if (e.key === 'Tab' && uiState.isError) {
          const errorEl = document.getElementById('scannerError');
          const focusableElements = errorEl.querySelectorAll('button:not([style*="display: none"])');
          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }

        // Spacebar for retry (accessibility)
        if (e.key === ' ' && uiState.isError && document.activeElement.id === 'retryCamera') {
          e.preventDefault();
          retryScanner();
        }
      });

      // Add ARIA live region for screen readers
      const ariaLiveRegion = document.createElement('div');
      ariaLiveRegion.setAttribute('aria-live', 'polite');
      ariaLiveRegion.setAttribute('aria-atomic', 'true');
      ariaLiveRegion.style.position = 'absolute';
      ariaLiveRegion.style.left = '-10000px';
      ariaLiveRegion.style.width = '1px';
      ariaLiveRegion.style.height = '1px';
      ariaLiveRegion.style.overflow = 'hidden';
      document.body.appendChild(ariaLiveRegion);

      // Announce state changes to screen readers
      function announceToScreenReader(message) {
        ariaLiveRegion.textContent = message;
        // Clear after a delay to allow for re-announcement of the same message
        setTimeout(() => {
          ariaLiveRegion.textContent = '';
        }, 1000);
      }

      // Submit manual ticket
      async function submitManualTicket() {
        const ticketId = document.getElementById("manualTicketId").value.trim();

        if (!ticketId) {
          alert("Please enter a ticket ID");
          return;
        }

        hideManualInput();

        // For manual entry, we need to look up the ticket first
        try {
          // Get selected event ID from event selector
          const selectedEventId = window.eventSelector ? window.eventSelector.getSelectedEventId() : null;
          const eventParam = selectedEventId ? `&event_id=${selectedEventId}` : '';

          const response = await fetch(
            `/api/tickets?ticket_id=${encodeURIComponent(ticketId)}${eventParam}`,
            {
              credentials: "include"
            }
          );
          const data = await response.json();

          if (data.ticket && data.ticket.qr_token) {
            await validateTicket(data.ticket.qr_token);
          } else {
            showResult("error", "Not Found", "Ticket ID not found");
          }
        } catch (error) {
          showResult("error", "Error", "Failed to lookup ticket");
        }
      }

      // Update statistics display
      function updateStats() {
        // Display = baseline + session increment
        document.getElementById("statToday").textContent = stats.todayBaseline + stats.todayIncrement;
        document.getElementById("statSession").textContent = stats.session;
        document.getElementById("statAppleWallet").textContent = stats.appleWalletBaseline + stats.appleWalletIncrement;
        document.getElementById("statGoogleWallet").textContent = stats.googleWalletBaseline + stats.googleWalletIncrement;
        // Total should include today's session scans
        document.getElementById("statTotal").textContent = stats.totalBaseline + stats.todayIncrement;

        // Update new stats
        document.getElementById("statFailed").textContent = stats.failed;
        document.getElementById("statInvalid").textContent = stats.invalid;

        // Calculate and display average validation time
        if (stats.validationTimes.length > 0) {
          const avgTime = stats.validationTimes.reduce((a, b) => a + b, 0) / stats.validationTimes.length;
          document.getElementById("statAvgTime").textContent = `${(avgTime / 1000).toFixed(1)}s`;
        } else {
          document.getElementById("statAvgTime").textContent = "0s";
        }

        // Persist to localStorage
        persistSessionStats();
      }

      // Open overlay modal with filtered checked-in tickets
      async function viewStatTickets(statType, page = 1) {
        const overlay = document.getElementById('ticketsOverlay');
        const titleEl = document.getElementById('ticketsOverlayTitle');
        const loadingEl = document.getElementById('ticketsLoading');
        const errorEl = document.getElementById('ticketsError');
        const tableContainer = document.getElementById('ticketsTableContainer');
        const emptyEl = document.getElementById('ticketsEmpty');
        const tableBody = document.getElementById('ticketsTableBody');
        const paginationEl = document.getElementById('ticketsPagination');

        // Update pagination state
        currentFilter = statType;
        currentPage = page;

        // Set title based on filter
        const titles = {
          'today': "Today's Check-Ins",
          'session': "Session Check-Ins",
          'wallet': "Wallet Check-Ins",
          'apple_wallet': "🍎 Apple Wallet Check-Ins",
          'google_wallet': "📱 Google Wallet Check-Ins",
          'total': "All Checked-In Tickets"
        };
        titleEl.textContent = titles[statType] || "Checked-In Tickets";

        // Show overlay with loading state
        overlay.classList.add('show');
        loadingEl.style.display = 'flex';
        errorEl.style.display = 'none';
        tableContainer.style.display = 'none';
        emptyEl.style.display = 'none';

        // For session filter, use local data from recentScans array
        if (statType === 'session') {
          loadingEl.style.display = 'none';

          if (recentScans.length === 0) {
            const emptyParagraph = emptyEl.querySelector('p');
            if (emptyParagraph) {
              emptyParagraph.textContent = "No tickets scanned in this session yet.";
            }
            emptyEl.style.display = 'block';
            return;
          }

          // Render session scans from local array
          tableBody.innerHTML = recentScans
            .filter(scan => scan.type === 'success')
            .map(scan => {
              const detailsLines = scan.details.split('\n');
              const fullName = detailsLines[0] || '';
              const [firstName, ...lastNameParts] = fullName.split(' ');
              const lastName = lastNameParts.join(' ');
              const timeFormatted = timeManager ?
                timeManager.formatDateTime(new Date(scan.timestamp)) :
                new Date(scan.timestamp).toLocaleString();

              // Make row clickable if ticket ID is available
              const hasTicketId = scan.ticketId && scan.ticketId !== '—';
              // XSS Fix: Escape ticketId in onclick handlers to prevent code injection
              const clickHandler = hasTicketId ?
                `onclick="openTicketDetail('${escapeHtml(scan.ticketId)}')" role="button" tabindex="0" onkeypress="if(event.key === 'Enter' || event.key === ' ') openTicketDetail('${escapeHtml(scan.ticketId)}')"` :
                'style="cursor: default;"';

              // Wallet source badge
              const walletBadge = scan.walletSource === 'apple_wallet' ? '🍎' :
                                  scan.walletSource === 'google_wallet' ? '📱' :
                                  scan.walletSource === 'samsung_wallet' ? '📱' : '—';

              // XSS Fix: Escape all user-provided data
              return `
                <tr ${clickHandler}>
                  <td>${escapeHtml(scan.ticketId || '—')}</td>
                  <td>${escapeHtml(firstName || '—')}</td>
                  <td>${escapeHtml(lastName || '—')}</td>
                  <td>${walletBadge}</td>
                  <td>${escapeHtml(timeFormatted)}</td>
                </tr>
              `;
            }).join('');

          tableContainer.style.display = 'block';
          return;
        }

        try {
          // Get selected event ID
          const selectedEventId = window.eventSelector ?
            window.eventSelector.getSelectedEventId() : null;

          // Build query params
          const params = new URLSearchParams();
          params.set('filter', statType);
          params.set('page', page);
          params.set('limit', 50);
          if (selectedEventId && selectedEventId !== 'all') params.set('eventId', selectedEventId);

          // Fetch tickets from API
          const response = await fetch(`/api/admin/checked-in-tickets?${params}`, {
            credentials: 'include'
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch tickets: ${response.status}`);
          }

          const data = await response.json();

          loadingEl.style.display = 'none';

          if (!data.tickets || data.tickets.length === 0) {
            // Update empty state message based on filter type
            const emptyMessages = {
              'today': "No tickets scanned today.",
              'apple_wallet': "No tickets scanned from Apple Wallet yet.",
              'google_wallet': "No tickets scanned from Google Wallet yet.",
              'wallet': "No tickets scanned from any wallet yet.",
              'total': "No tickets have been scanned yet."
            };
            const emptyParagraph = emptyEl.querySelector('p');
            if (emptyParagraph) {
              emptyParagraph.textContent = emptyMessages[statType] || "No tickets found for this filter.";
            }
            emptyEl.style.display = 'block';
            return;
          }

          // Render tickets table
          tableBody.innerHTML = data.tickets.map(ticket => {
            const scanTime = ticket.scan_time_mt ||
              (timeManager ? timeManager.formatDateTime(ticket.scan_time) : ticket.scan_time);

            // Wallet source badge
            const walletBadge = ticket.wallet_source === 'apple_wallet' ? '🍎' :
                                ticket.wallet_source === 'google_wallet' ? '📱' :
                                ticket.wallet_source === 'samsung_wallet' ? '📱' : '—';

            // XSS Fix: Escape all API data before rendering
            return `
              <tr onclick="openTicketDetail('${escapeHtml(ticket.ticket_id)}')" role="button" tabindex="0" onkeypress="if(event.key === 'Enter' || event.key === ' ') openTicketDetail('${escapeHtml(ticket.ticket_id)}')">
                <td>${escapeHtml(ticket.ticket_id)}</td>
                <td>${escapeHtml(ticket.first_name)}</td>
                <td>${escapeHtml(ticket.last_name)}</td>
                <td>${walletBadge}</td>
                <td>${escapeHtml(scanTime)}</td>
              </tr>
            `;
          }).join('');

          tableContainer.style.display = 'block';

          // Update pagination controls
          if (data.pagination) {
            totalPages = data.pagination.total_pages;
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const paginationInfo = document.getElementById('paginationInfo');

            // Update pagination info text
            paginationInfo.textContent = `Page ${data.pagination.page} of ${data.pagination.total_pages} (${data.pagination.total_count} total)`;

            // Update button states
            prevBtn.disabled = !data.pagination.has_prev;
            nextBtn.disabled = !data.pagination.has_next;

            // Show pagination controls
            paginationEl.style.display = 'flex';
          } else {
            paginationEl.style.display = 'none';
          }
        } catch (error) {
          console.error('Failed to load tickets:', error);
          loadingEl.style.display = 'none';
          errorEl.textContent = 'Failed to load tickets. Please try again.';
          errorEl.style.display = 'block';
        }
      }

      function closeTicketsOverlay() {
        document.getElementById('ticketsOverlay').classList.remove('show');
      }

      function previousPage() {
        if (currentPage > 1) {
          viewStatTickets(currentFilter, currentPage - 1);
        }
      }

      function nextPage() {
        if (currentPage < totalPages) {
          viewStatTickets(currentFilter, currentPage + 1);
        }
      }

      function openTicketDetail(ticketId) {
        if (!ticketId) {
          console.error('No ticket ID provided');
          return;
        }
        // Navigate to ticket detail page with ticketId query parameter
        window.location.href = `/admin/ticket-detail?ticketId=${encodeURIComponent(ticketId)}`;
      }

      // Load statistics
      async function loadStats() {
        try {
          // Get selected event ID from event selector
          const selectedEventId = window.eventSelector ? window.eventSelector.getSelectedEventId() : null;
          const eventParam = selectedEventId && selectedEventId !== 'all' ? `?eventId=${selectedEventId}` : '';

          const response = await fetch(`/api/admin/scanner-stats${eventParam}`, {
            credentials: "include"
          });
          const data = await response.json();

          // Debug logging to track stats loading
          console.log('📊 Scanner Stats API Response:', {
            today: data.stats?.today,
            total: data.stats?.total,
            apple_wallet: data.stats?.apple_wallet,
            google_wallet: data.stats?.google_wallet,
            eventId: selectedEventId,
            timestamp: new Date().toISOString()
          });

          if (data.stats) {
            // Load baselines from server, preserve session increments
            stats.todayBaseline = data.stats.today || 0;
            stats.totalBaseline = data.stats.total || 0;
            stats.appleWalletBaseline = data.stats.apple_wallet || 0;
            stats.googleWalletBaseline = data.stats.google_wallet || 0;
            // Session increments (todayIncrement, appleWalletIncrement, googleWalletIncrement, session, etc.) are NOT reset here - they persist!

            // Note: Test mode indicators removed as scanner-stats focuses on scanned tickets only
            // If test mode tracking is needed, it should be added to scanner-stats endpoint

            // Update display (combines baselines + increments)
            updateStats();
          }
        } catch (error) {
          console.error("Failed to load stats:", error);
        }
      }

      // Update scanner test mode indicators
      function updateScannerTestModeIndicators(hasTestData) {
        const testModeIndicator = document.getElementById('scannerTestModeIndicator');
        const statsBar = document.getElementById('statsBar');

        if (hasTestData) {
          // Show test mode indicator
          testModeIndicator.style.display = 'block';
          statsBar.classList.add('scanner-test-stats');
        } else {
          // Hide test mode indicator
          testModeIndicator.style.display = 'none';
          statsBar.classList.remove('scanner-test-stats');
        }
      }

      // Check online status
      function updateOnlineStatus() {
        const indicator = document.getElementById("offlineIndicator");

        if (navigator.onLine) {
          indicator.style.display = "none";

          // Trigger sync if we have queued items
          if (stats.queued > 0 && "serviceWorker" in navigator) {
            navigator.serviceWorker.ready.then((registration) => {
              return registration.sync.register("sync-checkins");
            });
          }
        } else {
          indicator.style.display = "block";
        }
      }

      // Toggle mobile navigation menu
      function toggleMobileMenu() {
        if (window.adminMobileNav) {
          window.adminMobileNav.toggleMenu();
        }
      }

      // Show menu (placeholder)
      function showMenu() {
        if (confirm("Return to dashboard?")) {
          window.location.href = "/admin/dashboard";
        }
      }

      // Check authentication (mobile sessions last 72 hours)
      async function checkAuth() {
        if (window.AdminAuthGuard) {
          return await window.AdminAuthGuard.verifyAndShow();
        } else {
          console.error("AdminAuthGuard not available");
          window.location.href = "/admin/login";
          return false;
        }
      }

      // Show mobile login UI
      function showMobileLogin() {
        document.body.innerHTML = `
                <div style="
                    height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: linear-gradient(135deg, var(--color-blue) 0%, var(--color-red) 100%);
                ">
                    <div style="
                        background: var(--color-surface);
                        padding: 40px;
                        border-radius: 20px;
                        box-shadow: var(--shadow-xl);
                        max-width: 90%;
                        width: 350px;
                    ">
                        <h2 style="color: var(--color-text-primary); margin-bottom: 10px; text-align: center;">
                            🎫 Check-in Staff Login
                        </h2>
                        <p style="color: var(--color-text-secondary); text-align: center; margin-bottom: 30px; font-size: 14px;">
                            Session lasts 72 hours
                        </p>
                        <form id="mobileLoginForm" onsubmit="handleMobileLogin(event)">
                            <input 
                                type="password" 
                                id="staffPassword"
                                placeholder="Enter staff password"
                                required
                                style="
                                    width: 100%;
                                    padding: 15px;
                                    border: 1px solid var(--color-border);
                                    border-radius: 10px;
                                    font-size: 16px;
                                    margin-bottom: 20px;
                                    background: var(--color-background-secondary);
                                    color: var(--color-text-primary);
                                "
                            >
                            <button type="submit" style="
                                width: 100%;
                                padding: 15px;
                                background: var(--color-primary);
                                color: var(--color-text-inverse);
                                border: none;
                                border-radius: 10px;
                                font-size: 18px;
                                font-weight: 600;
                                cursor: pointer;
                            ">
                                Login to Scanner
                            </button>
                            <div id="loginError" style="
                                color: var(--color-error);
                                text-align: center;
                                margin-top: 15px;
                                display: none;
                            "></div>
                        </form>
                    </div>
                </div>
            `;

        // Focus password field
        setTimeout(() => {
          document.getElementById("staffPassword").focus();
        }, 100);
      }

      // Handle mobile login
      async function handleMobileLogin(event) {
        event.preventDefault();

        const password = document.getElementById("staffPassword").value;
        const errorDiv = document.getElementById("loginError");

        try {
          // Get CSRF token first
          const csrfResponse = await fetch("/api/admin/csrf-token", {
            credentials: "include"
          });
          const csrfData = await csrfResponse.json();

          // Attempt login with mobile mode
          const response = await fetch("/api/admin/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": csrfData.token,
            },
            body: JSON.stringify({
              username: "admin",
              password: password,
              mode: "mobile",
              csrfToken: csrfData.token,
            }),
            credentials: "include"
          });

          const data = await response.json();

          if (response.ok) {
            // Login successful, reload page
            location.reload();
          } else {
            errorDiv.textContent = data.error || "Invalid password";
            errorDiv.style.display = "block";
            document.getElementById("staffPassword").value = "";
            document.getElementById("staffPassword").focus();
          }
        } catch (error) {
          errorDiv.textContent = "Connection error. Please try again.";
          errorDiv.style.display = "block";
        }
      }

      // Initialize app
      async function init() {
        // Check authentication
        if (!(await checkAuth())) return;

        // Wait for event selector to be available
        const waitForEventSelector = async () => {
          let attempts = 0;
          while (!window.eventSelector && attempts < 20) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          return window.eventSelector;
        };

        // Initialize event selector
        const eventSelector = await waitForEventSelector();
        if (eventSelector) {
          await eventSelector.init();
          eventSelector.render('event-selector-container');

          // Set up event change listener to reload stats
          eventSelector.onChange(() => {
            // Clear session stats when event changes
            stats.session = 0;
            updateStats();
            loadStats();
          });
        }

        // Register service worker
        if ("serviceWorker" in navigator) {
          try {
            await navigator.serviceWorker.register("/js/sw.js");
            console.log("Service worker registered");
          } catch (error) {
            console.error("Service worker registration failed:", error);
          }
        }

        // Initialize scanner
        await initScanner();

        // Load statistics
        await loadStats();

        // Load today's scans into recent activity feed
        await loadTodaysScans();

        // Monitor online status
        updateOnlineStatus();
        window.addEventListener("online", updateOnlineStatus);
        window.addEventListener("offline", updateOnlineStatus);

        // Refresh stats periodically
        setInterval(loadStats, 30000);
      }

      // Back to Portal function
      function backToPortal() {
        window.location.href = "/admin";
      }

      // Logout function
      async function logout() {
        if (!confirm("Are you sure you want to logout?")) return;

        try {
          const headers = {};

          // Add CSRF token for secure logout
          try {
            const csrfResponse = await fetch("/api/admin/csrf-token", {
              credentials: "same-origin"
            });
            if (csrfResponse.ok) {
              const csrfData = await csrfResponse.json();
              headers["X-CSRF-Token"] = csrfData.token || csrfData.csrfToken;
            }
          } catch (error) {
            console.warn("Could not fetch CSRF token for logout:", error);
          }

          await fetch("/api/admin/login", {
            method: "DELETE",
            headers: headers,
            credentials: "same-origin"
          });
        } finally {
          // Clear client storage
          localStorage.removeItem('adminToken');
          sessionStorage.clear();
          // Redirect
          window.location.href = '/admin/login';
        }
      }

      // Performance debugging interface (available in console)
      window.scannerPerformance = {
        getMetrics: getPerformanceMetrics,
        getDeviceScore: () => performanceMonitor.deviceScore,
        getAdaptiveSettings: () => performanceMonitor.adaptiveSettings,
        getCacheStats: () => ({
          validationCache: networkCache.validationResults.size,
          ticketCache: networkCache.ticketData.size,
          cacheHitRate: performanceMonitor.cacheHits / (performanceMonitor.cacheHits + performanceMonitor.cacheMisses),
          requestQueueLength: networkCache.requestQueue.length
        }),
        getMemoryStats: () => performanceMonitor.memoryUsage.slice(-5),
        getErrorCounts: () => performanceMonitor.errorCounts,
        getScanTimes: () => performanceMonitor.scanTimes.slice(-10),
        isLowPowerMode: () => performanceMonitor.isLowPowerMode,
        getBatteryInfo: () => performanceMonitor.batteryInfo,
        clearCache: () => {
          networkCache.validationResults.clear();
          networkCache.ticketData.clear();
          console.log('Caches cleared');
        },
        forceMemoryCleanup: () => {
          performMemoryCleanup();
          console.log('Memory cleanup forced');
        },
        enableLowPowerMode: () => {
          enableLowPowerMode();
          console.log('Low power mode enabled');
        },
        disableLowPowerMode: () => {
          disableLowPowerMode();
          console.log('Low power mode disabled');
        },
        restartScanner: () => {
          restartScannerWithNewSettings();
          console.log('Scanner restarted with new settings');
        },
        exportMetrics: () => {
          const metrics = {
            session: getPerformanceMetrics(),
            deviceInfo: deviceInfo,
            userAgent: navigator.userAgent,
            timestamp: timeManager ? timeManager.formatDateTime(new Date()) : new Date().toISOString()
          };
          console.log('Performance metrics:', JSON.stringify(metrics, null, 2));
          return metrics;
        }
      };

      // Initialize performance monitoring on load
      document.addEventListener('DOMContentLoaded', function() {
        if (performanceMonitor.deviceScore === 0) {
          initializePerformanceMonitoring();
        }
      });

      // Recent Activity Feed
      const recentScans = [];
      const MAX_RECENT_SCANS = 10;

      // Load today's scans from database on page initialization
      async function loadTodaysScans() {
        try {
          const selectedEventId = window.eventSelector ? window.eventSelector.getSelectedEventId() : null;
          const params = new URLSearchParams({
            filter: 'today',
            limit: 50,
            page: 1
          });

          if (selectedEventId && selectedEventId !== 'all') {
            params.set('eventId', selectedEventId);
          }

          const response = await fetch(`/api/admin/checked-in-tickets?${params}`, {
            credentials: 'include'
          });

          if (!response.ok) {
            console.error('Failed to load today\'s scans');
            return;
          }

          const data = await response.json();

          // Populate recentScans with today's data (most recent first)
          if (data.tickets && Array.isArray(data.tickets)) {
            recentScans.length = 0; // Clear existing
            data.tickets.forEach(ticket => {
              recentScans.push({
                timestamp: new Date(ticket.scan_time).getTime(),
                type: 'success',
                title: `${ticket.first_name || 'Unknown'} ${ticket.last_name || ''}`.trim(),
                details: `${ticket.ticket_type}\n${ticket.ticket_id}`,
                ticketId: ticket.ticket_id,
                walletSource: ticket.wallet_source
              });
            });

            // Limit to MAX_RECENT_SCANS
            if (recentScans.length > MAX_RECENT_SCANS) {
              recentScans.length = MAX_RECENT_SCANS;
            }

            // Render the activity feed
            renderActivityFeed();
          }
        } catch (error) {
          console.error('Failed to load today\'s scans:', error);
        }
      }

      // Pagination state
      let currentPage = 1;
      let currentFilter = 'total';
      let totalPages = 1;

      function addToActivityFeed(scanData) {
        // Add to beginning of array
        recentScans.unshift({
          timestamp: Date.now(),
          type: scanData.type, // 'success', 'error', 'queued'
          title: scanData.title,
          details: scanData.details,
          isTestTicket: scanData.isTestTicket || false,
          ticketId: scanData.ticketId || null,
          walletSource: scanData.walletSource || null
        });

        // Keep only last 10 scans
        if (recentScans.length > MAX_RECENT_SCANS) {
          recentScans.pop();
        }

        // Re-render the feed
        renderActivityFeed();
      }

      function renderActivityFeed() {
        const feedContainer = document.getElementById('activityFeed');
        if (!feedContainer) return;

        if (recentScans.length === 0) {
          feedContainer.innerHTML = '<div class="activity-empty">Waiting for scans...</div>';
          return;
        }

        feedContainer.innerHTML = recentScans.map(scan => {
          // Format timestamp
          const timeAgo = formatTimeAgo(scan.timestamp);

          // Determine icon and status class
          let icon = '🎫';
          let statusClass = scan.type;

          if (scan.type === 'success') {
            icon = scan.isTestTicket ? '🧪' : '✅';
          } else if (scan.type === 'error') {
            icon = scan.isTestTicket ? '🧪❌' : '❌';
            statusClass = 'error';
          } else if (scan.type === 'queued') {
            icon = '📥';
            statusClass = 'pending';
          }

          // Extract attendee name and ticket type from details if available
          const detailsLines = scan.details.split('\n');
          const attendeeName = detailsLines[0] || scan.details;
          const ticketType = detailsLines.length > 1 ? detailsLines[1] : '';

          // XSS Fix: Escape all user-provided data in activity feed
          return `
            <div class="activity-item ${statusClass}" role="article" aria-label="${escapeHtml(scan.title)}">
              <div class="activity-icon" aria-hidden="true">${icon}</div>
              <div class="activity-details">
                <div class="activity-name">${escapeHtml(attendeeName)}</div>
                ${ticketType ? `<div class="activity-ticket-type">${escapeHtml(ticketType)}</div>` : ''}
                <div class="activity-status">${escapeHtml(scan.title)}</div>
              </div>
              <div class="activity-time">
                <time datetime="${new Date(scan.timestamp).toISOString()}">${escapeHtml(timeAgo)}</time>
              </div>
            </div>
          `;
        }).join('');

        // Auto-scroll to top to show newest scan
        feedContainer.scrollTop = 0;
      }

      function formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);

        if (seconds < 10) return 'just now';
        if (seconds < 60) return `${seconds}s ago`;

        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;

        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;

        return 'today';
      }

      // Update activity feed every 30 seconds to refresh "time ago" labels
      setInterval(() => {
        if (recentScans.length > 0) {
          renderActivityFeed();
        }
      }, 30000);

      // Close tickets overlay when clicking backdrop
      document.addEventListener('click', (e) => {
        const overlay = document.getElementById('ticketsOverlay');
        if (e.target === overlay) {
          closeTicketsOverlay();
        }
      });

      // Log initial performance setup
      console.log('Scanner Performance Optimization Loaded');
      console.log('Available debugging: window.scannerPerformance');
      console.log('Device detection:', deviceInfo);

      // Start app
      init();
    </script>

    <!-- Mobile Navigation Controller -->
    <script src="/js/admin-mobile-nav.js"></script>
  </body>
</html>
