<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <!-- Inline theme detection to prevent FOUC -->
    <script>
      (function() {
        // Detect admin pages
        const path = window.location.pathname.toLowerCase();
        const isAdmin = path.includes('/admin') || path.includes('pages/admin');

        if (isAdmin) {
          // Admin pages always use dark theme
          document.documentElement.setAttribute('data-theme', 'dark');
        } else {
          // Main site: check user preference
          let stored = null;
          try {
            stored = localStorage.getItem('theme-preference');
          } catch {
            // localStorage might be disabled
          }

          const preference = stored || 'system';
          let theme = preference;

          if (preference === 'system') {
            // Detect system preference
            theme = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches)
              ? 'dark'
              : 'light';
          }

          document.documentElement.setAttribute('data-theme', theme);
        }
      })();
    </script>

    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="theme-color" content="#5b6bb5" />
    <title>Check-in Scanner - A Lo Cubano</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/images/icons/icon-192x192.png" />

    <!-- Admin Auth Guard - loaded early for security -->
    <script src="/js/admin-auth-guard.js"></script>

    <!-- Theme Manager - loaded early to prevent FOUC -->
    <script type="module" src="/js/theme-manager.js"></script>
    <script type="module" src="/js/time-manager.js"></script>

    <!-- CSS System -->
    
    <!-- Preconnect to Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- Preload critical fonts -->
    <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Playfair+Display:ital,wght@0,400;0,900;1,400;1,900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Playfair+Display:ital,wght@0,400;0,900;1,400;1,900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" media="print" onload="this.media='all'">
    <noscript>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Playfair+Display:ital,wght@0,400;0,900;1,400;1,900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap">
    </noscript>
    <!-- Critical CSS (render-blocking) -->
    <link rel="stylesheet" href="/css/bundle-critical.css" />

    <!-- Admin CSS -->
    <link rel="stylesheet" href="/css/bundle-admin.css" />

    <!-- Deferred CSS (lazy-loaded) -->
    <link rel="stylesheet" href="/css/bundle-deferred.css" media="print" onload="this.media='all'">
    <noscript>
      <link rel="stylesheet" href="/css/bundle-deferred.css">
    </noscript>
  <!-- Scanner-specific styles -->
    <style>
      /* QR Scanner specific overrides */
      body {
        height: 100vh;
        overflow: hidden;
        background: var(--color-background);
        color: var(--color-text-primary);
      }

      .scanner-app {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .app-header {
        background: linear-gradient(
          135deg,
          var(--color-blue) 0%,
          var(--color-red) 100%
        );
        padding: var(--space-lg) var(--space-xl);
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: var(--shadow-lg);
        position: sticky;
        top: 0;
        z-index: 1000;
        min-height: 80px;
      }

      .app-title-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        margin: 0 60px;
      }

      .app-portal-label {
        font-family: var(--font-sans);
        font-size: var(--font-size-xs);
        color: rgba(255, 255, 255, 0.8);
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 4px;
      }

      .app-title {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        color: var(--color-white);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wider);
        margin: 0;
        text-align: center;
      }

      .menu-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        width: 44px;
        height: 44px;
        min-height: 44px !important;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--color-white) !important;
        font-size: var(--font-size-xl);
        padding: 0 !important;
      }

      .menu-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      .menu-btn:active {
        transform: scale(0.95);
      }

      .scanner-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .stats-bar {
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
        padding: var(--space-xs) var(--space-sm);
        display: flex;
        gap: var(--space-xs);
        font-size: var(--font-size-xs);
        min-height: 45px;
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
      }

      .stats-bar .admin-stat-card {
        padding: var(--space-xs) !important;
        margin: 0 !important;
        min-width: auto !important;
        flex: 1;
        cursor: default;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .stats-bar .stat-number {
        font-size: var(--font-size-lg);
        font-weight: 700;
        line-height: 1;
        margin-bottom: 2px;
      }

      .stats-bar .stat-label {
        font-size: var(--font-size-xs);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.8;
      }

      .stats-bar .admin-stat-card:hover {
        transform: none;
        box-shadow: var(--shadow-md);
      }

      .scanner-viewport {
        flex: 1;
        position: relative;
        background: var(--color-black);
        overflow: hidden;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #reader {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }

      .scanner-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .scan-region {
        width: 280px;
        height: 280px;
        border: 3px solid var(--color-red);
        border-radius: var(--radius-xl);
        position: relative;
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.3);
        transition: all 0.3s ease;
      }

      /* Scanner state: actively scanning (default - red border) */
      .scan-region.scanning {
        border-color: var(--color-red);
        box-shadow: 0 0 40px rgba(239, 68, 68, 0.3);
      }

      /* Scanner state: QR code locked on (green border) */
      .scan-region.locked {
        border-color: var(--color-success);
        box-shadow: 0 0 40px rgba(4, 120, 87, 0.5);
      }

      /* Scan corners removed for cleaner appearance - full-screen scanner uses simple borders */

      /* Stats Bar */
      .stats-bar {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: var(--space-md);
        padding: var(--space-lg);
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: var(--space-md);
        background: var(--color-surface);
        border-radius: var(--radius-md);
        border: 1px solid var(--color-border);
        transition: all 0.2s ease;
        flex: 0 0 auto;
        min-width: 80px;
      }

      .stat-item:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .stat-item-clickable {
        cursor: pointer;
      }

      .stat-item-clickable:hover {
        border-color: var(--color-blue);
        box-shadow: var(--shadow-lg);
      }

      .stat-item-clickable:active {
        transform: translateY(0);
      }

      .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: var(--color-blue);
        font-family: var(--font-mono);
        line-height: 1;
        margin-bottom: var(--space-xs);
      }

      .stat-label {
        font-size: 12px;
        font-weight: 600;
        color: var(--color-text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        text-align: center;
      }

      /* Highlight stats with colors */
      #statValid { color: var(--color-success); }
      #statFailed { color: var(--color-red); }
      #statRateLimited { color: var(--color-warning); }
      #statAvgTime { color: var(--color-info); }

      /* Active state for clickable stat cards */
      .stat-item-clickable.active {
        background: var(--color-primary);
        border-color: var(--color-primary);
      }

      .stat-item-clickable.active .stat-value,
      .stat-item-clickable.active .stat-label {
        color: var(--color-white);
      }

      /* Badge styles for ticket table */
      .badge {
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        display: inline-block;
        white-space: nowrap;
      }

      .badge-success {
        background: rgba(4, 120, 87, 0.2);
        color: var(--color-success);
        border: 1px solid rgba(4, 120, 87, 0.3);
      }

      .badge-error {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .badge-warning {
        background: rgba(245, 158, 11, 0.2);
        color: #f59e0b;
        border: 1px solid rgba(245, 158, 11, 0.3);
      }

      .badge-info {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid rgba(59, 130, 246, 0.3);
      }

      /* Mobile responsive stats */
      @media (max-width: 768px) {
        .stats-bar {
          grid-template-columns: repeat(4, 1fr);
          gap: var(--space-sm);
          padding: var(--space-md);
        }

        .stat-item {
          padding: var(--space-sm);
        }

        .stat-value {
          font-size: 18px;
        }

        .stat-label {
          font-size: 10px;
        }
      }

      @media (max-width: 480px) {
        .stat-item {
          min-width: 70px;
          padding: var(--space-sm);
        }
      }

      .controls {
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
        padding: var(--space-lg) var(--space-xl);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: var(--space-xl);
        box-shadow: var(--shadow-lg);
        position: sticky;
        bottom: 0;
        z-index: 50;
      }

      .controls::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .control-btn {
        width: 60px !important;
        height: 60px !important;
        min-height: 60px !important;
        border-radius: 50% !important;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        padding: 0 !important;
        box-shadow: var(--shadow-md);
      }

      .control-btn:active {
        transform: scale(0.95);
      }

      /* Recent Activity Feed */
      .recent-activity {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: var(--space-lg);
        padding-bottom: 90px; /* Account for footer controls height to prevent items from hiding */
        background: linear-gradient(180deg,
          rgba(91, 107, 181, 0.03) 0%,
          rgba(204, 41, 54, 0.03) 100%);
        -webkit-overflow-scrolling: touch;
      }

      .activity-header {
        font-family: var(--font-display);
        font-size: var(--font-size-lg);
        font-weight: 700;
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin: 0 0 var(--space-lg) 0;
        padding-bottom: var(--space-sm);
        border-bottom: 2px solid var(--color-border);
        position: relative;
      }

      .activity-header::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 60px;
        height: 2px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .activity-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
      }

      .activity-empty {
        text-align: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
        font-family: var(--font-accent);
        font-style: italic;
        font-size: var(--font-size-base);
      }

      .activity-item {
        display: flex;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-md);
        background: var(--color-surface);
        border-left: 4px solid;
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-sm);
        animation: slideInRight 0.3s ease-out;
        transition: all 0.2s ease;
      }

      .activity-item:hover {
        transform: translateX(-2px);
        box-shadow: var(--shadow-md);
      }

      .activity-item.success {
        border-color: var(--color-success);
      }

      .activity-item.error {
        border-color: var(--color-error);
      }

      .activity-item.pending {
        border-color: var(--color-warning);
      }

      .activity-icon {
        font-size: 24px;
        line-height: 1;
        flex-shrink: 0;
      }

      .activity-details {
        flex: 1;
        min-width: 0;
      }

      .activity-ticket {
        font-family: var(--font-mono);
        font-size: var(--font-size-sm);
        font-weight: 600;
        color: var(--color-text-primary);
        margin-bottom: var(--space-xs);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .activity-info {
        font-size: var(--font-size-xs);
        color: var(--color-text-secondary);
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        flex-wrap: wrap;
      }

      .activity-timestamp {
        font-family: var(--font-mono);
        font-size: var(--font-size-xs);
        color: var(--color-text-muted);
        flex-shrink: 0;
      }

      .activity-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: var(--radius-sm);
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .activity-badge.type {
        background: rgba(91, 107, 181, 0.1);
        color: var(--color-blue);
      }

      @keyframes slideInRight {
        from {
          opacity: 0;
          transform: translateX(30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      /* Pulsing animation on active stats */
      .stat-value.pulsing {
        animation: pulse 1s ease-in-out 2;
      }

      /* Mobile responsive activity feed */
      @media (max-width: 768px) {
        .recent-activity {
          padding: var(--space-md);
        }

        .activity-item {
          padding: var(--space-sm);
          gap: var(--space-sm);
        }

        .activity-icon {
          font-size: 20px;
        }

        .activity-ticket {
          font-size: var(--font-size-xs);
        }

        .activity-info {
          font-size: 10px;
        }
      }

      .control-btn.manual {
        background: var(--color-red) !important;
        border-color: var(--color-red) !important;
        color: var(--color-white) !important;
      }

      .control-btn.manual:hover {
        background: var(--color-secondary-hover) !important;
        border-color: var(--color-secondary-hover) !important;
      }

      .result-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10001; /* Higher than fullscreen scanner modal to overlay on camera */
        animation: fadeIn 0.3s ease-out;
        pointer-events: none; /* Allow camera interaction beneath */
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .result-modal.show {
        display: flex;
      }

      .result-content {
        background: var(--color-white);
        border-radius: var(--radius-xl);
        padding: var(--space-xl);
        max-width: 90%;
        width: 350px;
        max-height: 85vh;
        overflow-y: auto;
        text-align: center;
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
        pointer-events: auto; /* Enable interaction with result card */
      }

      @keyframes slideUp {
        from {
          transform: translateY(50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .result-content.success {
        background: var(--color-success);
        color: var(--color-white);
      }

      .result-content.error {
        background: var(--color-error);
        color: var(--color-white);
      }

      .result-content.validating {
        background: var(--color-white);
        color: var(--color-text-primary);
        border: 3px solid var(--color-blue);
      }

      .result-icon {
        font-size: 48px;
        margin-bottom: var(--space-md);
      }

      .result-title {
        font-family: var(--font-display);
        font-size: var(--font-size-2xl);
        font-weight: 700;
        margin-bottom: var(--space-md);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .result-details {
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        opacity: 0.9;
        margin-bottom: var(--space-xl);
        white-space: pre-line;
        line-height: var(--line-height-relaxed);
      }

      .countdown-timer {
        margin-top: var(--space-lg);
        margin-bottom: var(--space-md);
        padding: var(--space-sm) var(--space-md);
        background: rgba(0, 0, 0, 0.1);
        border-radius: var(--radius-md);
        font-family: var(--font-mono);
        font-size: var(--font-size-sm);
        opacity: 0.8;
      }

      .countdown-timer #countdownSeconds {
        font-weight: 700;
        font-size: 1.1em;
        color: currentColor;
      }

      .result-content.success .countdown-timer {
        background: rgba(255, 255, 255, 0.15);
      }

      .result-content.error .countdown-timer {
        background: rgba(255, 255, 255, 0.15);
      }

      .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: currentColor !important;
        border: 2px solid rgba(255, 255, 255, 0.3) !important;
        padding: var(--space-md) var(--space-xl);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 44px;
      }

      .result-content.success .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .result-content.success .result-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      .result-content.error .result-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .result-content.error .result-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
        color: var(--color-white) !important;
      }

      /* Checked-In Tickets Overlay */
      .tickets-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.2s ease-out;
      }

      .tickets-overlay.show {
        display: flex;
      }

      .tickets-overlay-content {
        background: var(--color-surface);
        border-radius: var(--radius-lg);
        width: 90%;
        max-width: 900px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow-2xl);
        overflow: hidden;
      }

      .tickets-overlay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-lg);
        border-bottom: 2px solid var(--color-border);
        background: linear-gradient(90deg, rgba(91,107,181,0.1), rgba(204,41,54,0.1));
        position: relative;
      }

      .tickets-overlay-header::after {
        content: "";
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 100px;
        height: 2px;
        background: linear-gradient(90deg, var(--color-blue), var(--color-red));
      }

      .tickets-overlay-header h3 {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        color: var(--color-text-primary);
        margin: 0;
      }

      .tickets-overlay-close {
        background: transparent;
        border: none;
        color: var(--color-text-primary);
        font-size: var(--font-size-2xl);
        cursor: pointer;
        padding: var(--space-xs);
        line-height: 1;
        transition: all 0.2s ease;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: var(--radius-md);
      }

      .tickets-overlay-close:hover {
        background: rgba(0, 0, 0, 0.05);
        transform: scale(1.1);
      }

      .tickets-overlay-body {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-lg);
        display: flex;
        flex-direction: column;
      }

      .tickets-loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
      }

      .tickets-loading .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid var(--color-border);
        border-top-color: var(--color-blue);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-bottom: var(--space-md);
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .tickets-error {
        padding: var(--space-lg);
        background: rgba(204, 41, 54, 0.1);
        border: 1px solid var(--color-error);
        border-radius: var(--radius-md);
        color: var(--color-error);
        text-align: center;
        margin: var(--space-lg);
      }

      .tickets-empty {
        text-align: center;
        padding: var(--space-3xl);
        color: var(--color-text-muted);
        font-family: var(--font-accent);
        font-style: italic;
      }

      .tickets-table-container {
        overflow-x: auto;
        overflow-y: auto;
        flex: 1;
      }

      .tickets-table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--font-size-base);
      }

      .tickets-table thead {
        position: sticky;
        top: 0;
        background: var(--color-surface-elevated);
        z-index: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tickets-table th {
        text-align: left;
        padding: var(--space-md);
        font-family: var(--font-display);
        text-transform: uppercase;
        font-size: var(--font-size-sm);
        font-weight: 700;
        letter-spacing: var(--letter-spacing-wide);
        border-bottom: 2px solid var(--color-border);
        color: var(--color-text-primary);
      }

      .tickets-table td {
        padding: var(--space-md);
        border-bottom: 1px solid var(--color-border);
        font-family: var(--font-sans);
      }

      .tickets-table tbody tr {
        transition: background-color 0.2s ease, transform 0.1s ease;
        cursor: pointer;
      }

      .tickets-table tbody tr:hover {
        background: rgba(91, 107, 181, 0.08);
        transform: translateX(2px);
      }

      .tickets-table tbody tr:active {
        background: rgba(91, 107, 181, 0.12);
      }

      .tickets-table tbody tr:last-child td {
        border-bottom: none;
      }

      /* Mobile responsive */
      @media (max-width: 768px) {
        .tickets-overlay-content {
          width: 95%;
          max-height: 90vh;
        }

        .tickets-overlay-header {
          padding: var(--space-md);
        }

        .tickets-overlay-header h3 {
          font-size: var(--font-size-lg);
        }

        .tickets-overlay-body {
          padding: var(--space-md);
        }

        .tickets-table {
          font-size: var(--font-size-sm);
        }

        .tickets-table th,
        .tickets-table td {
          padding: var(--space-sm);
        }

        /* Stack table columns more compactly on small screens */
        .tickets-table th:first-child,
        .tickets-table td:first-child {
          min-width: 100px;
        }
      }

      .tickets-pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: var(--space-md);
        padding: var(--space-lg);
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
      }

      .pagination-btn {
        padding: var(--space-sm) var(--space-md);
        background: var(--color-blue);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        cursor: pointer;
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        font-weight: 600;
        transition: all 0.2s ease;
        min-width: 100px;
      }

      .pagination-btn:hover:not(:disabled) {
        background: var(--color-blue-dark);
        transform: translateY(-1px);
      }

      .pagination-btn:disabled {
        background: var(--color-border);
        color: var(--color-text-muted);
        cursor: not-allowed;
        opacity: 0.5;
      }

      .pagination-info {
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
        min-width: 100px;
        text-align: center;
      }

      .manual-input-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: calc(var(--z-modal) - 1);
      }

      .manual-input-backdrop.show {
        display: block;
      }

      .manual-input {
        position: fixed;
        bottom: -100%;
        left: 0;
        right: 0;
        background: var(--color-surface);
        color: var(--color-text-primary);
        padding: var(--space-xl);
        border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        transition: bottom 0.3s ease-out;
        z-index: var(--z-modal);
        box-shadow: var(--shadow-2xl);
      }

      .manual-input.show {
        bottom: 0;
      }

      .manual-input h3 {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        margin-bottom: var(--space-lg);
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .manual-input-buttons {
        display: flex;
        gap: var(--space-md);
        margin-top: var(--space-lg);
      }

      /* Hide HTML5 QR Code default UI elements */
      #reader__dashboard_section_csr,
      #reader__dashboard_section_fsr {
        display: none !important;
      }

      #reader__scan_region {
        border: none !important;
      }

      #reader video {
        object-fit: cover !important;
      }

      .offline-indicator {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: var(--z-modal);
        margin: 0;
        width: auto;
        max-width: 90%;
        display: none;
      }

      /* Dark mode specific adjustments for scanner */
      [data-theme="dark"] .result-content:not(.success):not(.error) {
        background: var(--color-surface);
        color: var(--color-text-primary);
      }

      [data-theme="dark"] .manual-input {
        background: var(--color-surface-elevated);
        border-top: 1px solid var(--color-border);
      }

      /* Tablet responsiveness */
      @media (max-width: 768px) and (min-width: 481px) {
        .app-title {
          font-size: var(--font-size-lg);
          margin: 0 100px;
          max-width: calc(100% - 200px);
        }

        .back-btn,
        .logout-btn {
          font-size: var(--font-size-xs);
          padding: var(--space-xs);
          min-width: 70px;
        }
      }

      /* Mobile responsiveness */
      @media (max-width: 480px) {
        .app-header {
          flex-direction: column;
          align-items: center;
          text-align: center;
          padding: var(--space-md);
          min-height: auto;
        }

        .logout-btn,
        .back-btn {
          position: static;
          margin: var(--space-xs);
          min-width: 80px;
          z-index: auto;
        }

        .app-title {
          margin: var(--space-sm) 0;
          max-width: 100%;
          order: 1;
        }

        .back-btn {
          order: 0;
        }

        .logout-btn {
          order: 2;
        }
      }

        .stats-bar {
          padding: var(--space-xs);
          gap: var(--space-xs);
          flex-wrap: wrap;
        }

        .stats-bar .admin-stat-card {
          min-width: calc(50% - var(--space-xs) / 2);
          flex: 0 0 calc(50% - var(--space-xs) / 2);
        }
        .scan-region {
          width: 240px;
          height: 240px;
        }

        .controls {
          padding: var(--space-lg);
        }

        .control-btn {
          width: 50px !important;
          height: 50px !important;
          min-height: 50px !important;
          font-size: 20px;
        }

        .result-content {
          width: 90%;
          padding: var(--space-xl);
        }

        .offline-indicator {
          top: 110px; /* Adjusted to account for event selector */
          font-size: var(--font-size-sm);
        }
      }

      /* Event Selector Styles */
      .event-selector-wrapper {
        background: var(--color-surface-elevated);
        border-bottom: 1px solid var(--color-border);
        padding: var(--space-md) var(--space-xl);
        display: flex;
        align-items: center;
        gap: var(--space-md);
        font-size: var(--font-size-sm);
      }

      .event-selector-label {
        color: var(--color-text-secondary);
        font-weight: 600;
        white-space: nowrap;
        font-family: var(--font-display);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .event-selector {
        flex: 1;
        max-width: 400px;
        background: var(--color-surface) !important;
        border: 1px solid var(--color-border) !important;
        color: var(--color-text-primary) !important;
        padding: var(--space-sm) var(--space-md);
        border-radius: var(--radius-md);
        font-size: var(--font-size-sm);
        font-family: var(--font-sans);
      }

      .event-selector:focus {
        outline: none;
        border-color: var(--color-blue) !important;
        box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
      }

      /* Wide screen optimizations */
      @media (min-width: 1200px) {
        .app-title {
          font-size: var(--font-size-2xl);
          margin: 0 160px;
          max-width: min(calc(100% - 320px), 600px);
        }

        .back-btn,
        .logout-btn {
          min-height: 40px;
          padding: var(--space-sm) var(--space-lg);
          font-size: var(--font-size-base);
        }
      }

      /* Ultra-wide screen constraints */
      @media (min-width: 1600px) {
        .app-header {
          max-width: 1400px;
          margin: 0 auto;
        }
      }

      /* Permission Request Modal */
      .permission-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: calc(var(--z-modal) + 10);
        animation: fadeIn 0.3s ease-out;
      }

      .permission-modal.show {
        display: flex;
      }

      .permission-content {
        background: var(--color-surface);
        border-radius: var(--radius-xl);
        padding: var(--space-3xl);
        max-width: 90%;
        width: 420px;
        text-align: center;
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
        border: 1px solid var(--color-border);
      }

      .permission-icon {
        font-size: 64px;
        margin-bottom: var(--space-xl);
        display: block;
      }

      .permission-title {
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        margin-bottom: var(--space-lg);
        color: var(--color-text-primary);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .permission-description {
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        color: var(--color-text-secondary);
        margin-bottom: var(--space-xl);
        line-height: var(--line-height-relaxed);
      }

      .device-instructions {
        background: var(--color-surface-elevated);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-lg);
        padding: var(--space-lg);
        margin: var(--space-lg) 0;
        text-align: left;
        font-size: var(--font-size-sm);
        color: var(--color-text-primary);
      }

      .device-instructions h4 {
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        margin-bottom: var(--space-sm);
        color: var(--color-blue);
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .device-instructions ol {
        margin: 0;
        padding-left: var(--space-lg);
      }

      .device-instructions li {
        margin-bottom: var(--space-xs);
        line-height: var(--line-height-relaxed);
      }

      .permission-buttons {
        display: flex;
        gap: var(--space-md);
        margin-top: var(--space-xl);
      }

      .permission-btn {
        flex: 1;
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 48px;
        transition: all 0.2s ease;
        cursor: pointer;
        border: 2px solid transparent;
      }

      .permission-btn.primary {
        background: var(--color-blue) !important;
        color: var(--color-white) !important;
        border-color: var(--color-blue) !important;
      }

      .permission-btn.primary:hover {
        background: var(--color-primary-hover) !important;
        border-color: var(--color-primary-hover) !important;
        transform: translateY(-1px);
      }

      .permission-btn.secondary {
        background: var(--color-surface-elevated) !important;
        color: var(--color-text-primary) !important;
        border-color: var(--color-border) !important;
      }

      .permission-btn.secondary:hover {
        background: var(--color-surface) !important;
        border-color: var(--color-text-secondary) !important;
      }

      /* Loading States */
      .scanner-loading {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--color-black);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 50;
      }

      .scanner-loading.show {
        display: flex;
      }

      .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(102, 126, 234, 0.2);
        border-left: 4px solid var(--color-blue);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: var(--space-lg);
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-lg);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin-bottom: var(--space-sm);
      }

      .loading-subtext {
        color: rgba(255, 255, 255, 0.7);
        font-family: var(--font-sans);
        font-size: var(--font-size-sm);
        text-align: center;
        max-width: 280px;
        line-height: var(--line-height-relaxed);
      }

      /* Error States */
      .scanner-error {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--color-black);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 50;
        padding: var(--space-xl);
      }

      .scanner-error.show {
        display: flex;
      }

      .error-icon {
        font-size: 72px;
        margin-bottom: var(--space-xl);
        color: var(--color-red);
      }

      .error-title {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        margin-bottom: var(--space-lg);
        text-align: center;
      }

      .error-message {
        color: rgba(255, 255, 255, 0.8);
        font-family: var(--font-sans);
        font-size: var(--font-size-base);
        text-align: center;
        max-width: 350px;
        line-height: var(--line-height-relaxed);
        margin-bottom: var(--space-xl);
      }

      .error-actions {
        display: flex;
        gap: var(--space-md);
        flex-wrap: wrap;
        justify-content: center;
        max-width: 100%;
      }

      .error-btn {
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-lg);
        font-family: var(--font-display);
        font-size: var(--font-size-base);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        min-height: 48px;
        min-width: 120px;
        transition: all 0.2s ease;
        cursor: pointer;
        border: 2px solid transparent;
      }

      .error-btn.retry {
        background: var(--color-blue) !important;
        color: var(--color-white) !important;
        border-color: var(--color-blue) !important;
      }

      .error-btn.retry:hover {
        background: var(--color-primary-hover) !important;
        border-color: var(--color-primary-hover) !important;
        transform: translateY(-1px);
      }

      .error-btn.manual {
        background: var(--color-red) !important;
        color: var(--color-white) !important;
        border-color: var(--color-red) !important;
      }

      .error-btn.manual:hover {
        background: var(--color-secondary-hover) !important;
        border-color: var(--color-secondary-hover) !important;
        transform: translateY(-1px);
      }

      .error-btn.settings {
        background: rgba(255, 255, 255, 0.1) !important;
        color: var(--color-white) !important;
        border-color: rgba(255, 255, 255, 0.3) !important;
      }

      .error-btn.settings:hover {
        background: rgba(255, 255, 255, 0.2) !important;
        border-color: rgba(255, 255, 255, 0.5) !important;
      }

      /* Success Indicator */
      .scanner-success {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(4, 120, 87, 0.95);
        color: var(--color-white);
        border-radius: var(--radius-xl);
        padding: var(--space-lg) var(--space-xl);
        display: none;
        align-items: center;
        gap: var(--space-md);
        z-index: 60;
        font-family: var(--font-display);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
        animation: slideUp 0.3s ease-out;
        box-shadow: var(--shadow-2xl);
      }

      .scanner-success.show {
        display: flex;
      }

      .success-icon {
        font-size: var(--font-size-xl);
      }

      /* Full-Screen Scanner Modal */
      .fullscreen-scanner-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 9999;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .fullscreen-scanner-modal.active {
        display: flex;
      }

      .fullscreen-scanner-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: var(--space-lg);
        display: flex;
        justify-content: space-between;
        align-items: center;
        z-index: 10000;
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
      }

      .fullscreen-scanner-title {
        color: var(--color-white);
        font-family: var(--font-display);
        font-size: var(--font-size-xl);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: var(--letter-spacing-wide);
      }

      .fullscreen-close-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: var(--color-white);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .fullscreen-close-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
        transform: scale(1.1);
      }

      .fullscreen-scanner-container {
        width: 90vw;
        max-width: 600px;
        height: auto;
        position: relative;
      }

      .fullscreen-scan-region {
        width: 100%;
        aspect-ratio: 1;
        border: 3px solid var(--color-red);
        border-radius: var(--radius-xl);
        position: relative;
        box-shadow: 0 0 60px rgba(239, 68, 68, 0.4);
        transition: all 0.3s ease;
        background: rgba(0, 0, 0, 0.3);
      }

      .fullscreen-scan-region.scanning {
        border-color: var(--color-red);
        box-shadow: 0 0 60px rgba(239, 68, 68, 0.4);
      }

      .fullscreen-scan-region.locked {
        border-color: var(--color-success);
        box-shadow: 0 0 60px rgba(4, 120, 87, 0.6);
      }

      #fullscreenReader {
        width: 100%;
        height: 100%;
        border-radius: var(--radius-lg);
        overflow: hidden;
      }

      #fullscreenReader video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: var(--radius-lg);
      }

      .fullscreen-instructions {
        color: rgba(255, 255, 255, 0.9);
        font-family: var(--font-sans);
        font-size: var(--font-size-lg);
        text-align: center;
        margin-top: var(--space-xl);
        padding: 0 var(--space-lg);
        max-width: 500px;
      }

      @media (max-width: 768px) {
        .fullscreen-scanner-container {
          width: 95vw;
        }

        .fullscreen-scanner-title {
          font-size: var(--font-size-lg);
        }

        .fullscreen-instructions {
          font-size: var(--font-size-base);
        }
      }

      /* Mobile Optimizations */
      @media (max-width: 480px) {
        .permission-content {
          width: 95%;
          padding: var(--space-xl);
        }

        .permission-buttons {
          flex-direction: column;
        }

        .permission-btn {
          width: 100%;
        }

        .device-instructions {
          padding: var(--space-md);
        }

        .error-actions {
          flex-direction: column;
          align-items: center;
        }

        .error-btn {
          width: 200px;
        }

        .loading-text {
          font-size: var(--font-size-base);
        }

        .error-title {
          font-size: var(--font-size-lg);
        }
      }

      /* Accessibility Enhancements */
      .permission-modal:focus-within .permission-content,
      .scanner-error:focus-within,
      .scanner-loading:focus-within {
        outline: 3px solid var(--color-blue);
        outline-offset: 2px;
      }

      .permission-btn:focus,
      .error-btn:focus {
        outline: 3px solid var(--color-blue);
        outline-offset: 2px;
      }

      /* High contrast mode support */
      @media (prefers-contrast: high) {
        .permission-content,
        .scanner-error,
        .scanner-loading {
          border: 2px solid var(--color-text-primary);
        }

        .loading-spinner {
          border-left-color: var(--color-text-primary);
        }
      }

      /* Reduced motion support */
      @media (prefers-reduced-motion: reduce) {
        .scan-region {
          animation: none;
        }

        .result-modal,
        .result-content,
        .permission-content,
        .scanner-success {
          animation: none;
        }

        .activity-item {
          animation: none;
        }

        .stat-value.pulsing {
          animation: none;
        }

        .activity-item:hover {
          transform: none;
        }

        .control-btn:active,
        .menu-btn:active,
        .permission-btn:hover,
        .error-btn:hover {
          transform: none;
        }

        .loading-spinner {
          animation: none;
          border: 4px solid var(--color-blue);
        }
      }
    </style>
  </head>
  <body>
    <!-- Mobile Hamburger Menu Toggle -->
    <button class="admin-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
      <div class="admin-menu-icon">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </button>

    <!-- Mobile Navigation (Hidden on Desktop) -->
    <nav class="admin-navigation">
      <ul class="admin-nav-list">
        <!-- Core Tools Group -->
        <li role="presentation" class="admin-nav-group-header">Core Tools</li>
        <li class="admin-nav-item">
          <a href="/admin" class="admin-nav-link">
            <span class="nav-icon">üè†</span>
            <span>Portal</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/dashboard" class="admin-nav-link">
            <span class="nav-icon">üìä</span>
            <span>Dashboard</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/checkin" class="admin-nav-link active">
            <span class="nav-icon">üì±</span>
            <span>Check-in Scanner</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/manual-entry" class="admin-nav-link">
            <span class="nav-icon">‚úèÔ∏è</span>
            <span>Manual Entry</span>
          </a>
        </li>

        <!-- Data & Analytics Group -->
        <li role="presentation" aria-hidden="true" class="admin-nav-separator"></li>
        <li role="presentation" class="admin-nav-group-header">Data & Analytics</li>
        <li class="admin-nav-item">
          <a href="/admin/tickets" class="admin-nav-link">
            <span class="nav-icon">üé´</span>
            <span>Tickets</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/analytics" class="admin-nav-link">
            <span class="nav-icon">üìà</span>
            <span>Analytics</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/donations" class="admin-nav-link">
            <span class="nav-icon">üíù</span>
            <span>Donations</span>
          </a>
        </li>

        <!-- Utilities Group -->
        <li role="presentation" aria-hidden="true" class="admin-nav-separator"></li>
        <li role="presentation" class="admin-nav-group-header">Utilities</li>
        <li class="admin-nav-item">
          <a href="/admin/test" class="admin-nav-link">
            <span class="nav-icon">üß™</span>
            <span>Test</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/api-endpoints" class="admin-nav-link">
            <span class="nav-icon">üîå</span>
            <span>API Endpoints</span>
          </a>
        </li>
        <li class="admin-nav-item">
          <a href="/admin/audit-logs" class="admin-nav-link">
            <span class="nav-icon">üìã</span>
            <span>Audit Logs</span>
          </a>
        </li>
      </ul>
    </nav>

    <div class="scanner-app">
      <div class="app-header">
        <button
          class="menu-btn admin-menu-toggle"
          onclick="toggleMobileMenu(this)"
          aria-label="Open menu"
          aria-expanded="false"
          title="Open navigation menu"
        >
          ‚ò∞
        </button>
        <div class="app-title-container">
          <div class="app-portal-label">Portal</div>
          <h1 class="app-title" data-testid="scanner-title">
            Check-In Scanner
          </h1>
        </div>
      </div>

      <div class="admin-alert error offline-indicator" id="offlineIndicator">
        <div class="alert-title">üìµ Offline Mode</div>
        <div class="alert-content">Check-ins will sync when connected</div>
      </div>

      <div class="scanner-container" data-testid="scanner-container">
        <!-- Test Mode Indicator for Scanner -->
        <div id="scannerTestModeIndicator" class="test-mode-indicator" style="display: none;">
          <span class="test-icon">üß™</span>
          <span class="test-text">Test Mode: Scanner contains test data</span>
        </div>

        <!-- Stats Bar -->
        <div id="statsBar" class="stats-bar" role="region" aria-label="Scanner Statistics">
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('session')" title="Click to view this session's check-ins" role="button" tabindex="0" aria-label="Session check-ins: 0. Click to view details">
            <div class="stat-value" id="statSession" aria-live="polite">0</div>
            <div class="stat-label">Session</div>
          </div>
          <div class="stat-item" role="status" aria-label="Average validation time: 0 milliseconds">
            <div class="stat-value" id="statAvgTime" aria-live="polite">0ms</div>
            <div class="stat-label">Avg Time</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('today')" title="Click to view today's check-ins" role="button" tabindex="0" aria-label="Today's check-ins: 0. Click to view details">
            <div class="stat-value" id="statToday" aria-live="polite">0</div>
            <div class="stat-label">Today</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('total')" title="Click to view all checked-in tickets" role="button" tabindex="0" aria-label="Total check-ins: 0. Click to view details">
            <div class="stat-value" id="statTotal" aria-live="polite">0</div>
            <div class="stat-label">Total</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('valid')" title="Click to view valid scans" role="button" tabindex="0" aria-label="Valid scans: 0. Click to view details">
            <div class="stat-value" id="statValid" aria-live="polite">0</div>
            <div class="stat-label">Valid</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('failed')" title="Click to view failed scans" role="button" tabindex="0" aria-label="Failed scans: 0. Click to view details">
            <div class="stat-value" id="statFailed" aria-live="polite">0</div>
            <div class="stat-label">Failed</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('rateLimited')" title="Click to view rate limited scans" role="button" tabindex="0" aria-label="Rate limited scans: 0. Click to view details">
            <div class="stat-value" id="statRateLimited" aria-live="polite">0</div>
            <div class="stat-label">Rate Limited</div>
          </div>
          <div class="stat-item stat-item-clickable" onclick="viewStatTickets('alreadyScanned')" title="Click to view re-scanned tickets" role="button" tabindex="0" aria-label="Re-scanned tickets: 0. Click to view details">
            <div class="stat-value" id="statAlreadyScanned" aria-live="polite">0</div>
            <div class="stat-label">Re-scanned</div>
          </div>
        </div>

        <!-- Scanner Loading State -->
        <div id="scannerLoading" class="scanner-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <div id="loadingText" class="loading-text">Initializing camera...</div>
          <div id="loadingSubtext" class="loading-subtext">Please allow camera permissions</div>
        </div>

        <!-- Recent Activity Feed -->
        <div class="recent-activity">
          <h3 class="activity-header">Recent Scans</h3>
          <div id="activityFeed" class="activity-list">
            <div class="activity-empty">Waiting for scans...</div>
          </div>
        </div>

        <div class="controls">
          <button
            class="control-btn admin-btn admin-btn-primary"
            onclick="openFullscreenScanner()"
            title="Scan Ticket - Camera permissions are saved by your browser and persist across sessions"
            style="font-size: 24px;"
          >
            üì∑
          </button>
          <button
            class="control-btn manual admin-btn"
            onclick="showManualInput()"
            data-testid="manual-input-toggle"
            title="Manual Entry"
          >
            ‚å®Ô∏è
          </button>
          <button class="control-btn admin-btn" onclick="location.reload()" title="Refresh Scanner">
            üîÑ
          </button>
          <button class="control-btn admin-btn" onclick="clearSessionData()" title="Clear Session Data - Reset session scan logs and counters" style="background: var(--color-warning) !important; border-color: var(--color-warning) !important;">
            üóëÔ∏è
          </button>
        </div>
      </div>
    </div>

    <div class="result-modal" id="resultModal">
      <div class="result-content" id="resultContent">
        <div class="result-icon" id="resultIcon"></div>
        <div
          class="result-title"
          id="resultTitle"
          data-testid="validation-result"
        ></div>
        <div
          class="result-details"
          id="resultDetails"
          data-testid="ticket-info"
        ></div>
        <div class="countdown-timer" id="countdownTimer" style="display: none;">
          Returning to scanner in <span id="countdownSeconds">12</span>s
        </div>
        <button class="result-btn admin-btn admin-btn-primary" onclick="closeResult()">
          Continue Scanning
        </button>
      </div>
    </div>

    <!-- Checked-In Tickets Overlay -->
    <div class="tickets-overlay" id="ticketsOverlay">
      <div class="tickets-overlay-content">
        <div class="tickets-overlay-header">
          <h3 id="ticketsOverlayTitle">Checked-In Tickets</h3>
          <button class="tickets-overlay-close" onclick="closeTicketsOverlay()" aria-label="Close">‚úï</button>
        </div>
        <div class="tickets-overlay-body">
          <div class="tickets-loading" id="ticketsLoading">
            <div class="loading-spinner"></div>
            <p>Loading tickets...</p>
          </div>
          <div class="tickets-error" id="ticketsError" style="display: none;"></div>
          <div class="tickets-table-container" id="ticketsTableContainer" style="display: none;">
            <table class="tickets-table">
              <thead>
                <tr>
                  <th>Ticket ID</th>
                  <th>First Name</th>
                  <th>Last Name</th>
                  <th>Scan Time (MT)</th>
                </tr>
              </thead>
              <tbody id="ticketsTableBody">
                <!-- Rows populated by JavaScript -->
              </tbody>
            </table>
          </div>
          <div class="tickets-pagination" id="ticketsPagination" style="display: none;">
            <button class="pagination-btn" id="prevPageBtn" onclick="previousPage()" disabled>‚Üê Previous</button>
            <span class="pagination-info" id="paginationInfo">Page 1 of 1</span>
            <button class="pagination-btn" id="nextPageBtn" onclick="nextPage()" disabled>Next ‚Üí</button>
          </div>
          <div class="tickets-empty" id="ticketsEmpty" style="display: none;">
            <p>No tickets found for this filter.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Permission Request Modal -->
    <div class="permission-modal" id="permissionModal" role="dialog" aria-labelledby="permissionTitle" aria-describedby="permissionDescription">
      <div class="permission-content">
        <div class="permission-icon" id="permissionIcon" aria-hidden="true">üì∑</div>
        <h3 class="permission-title" id="permissionTitle">Camera Access Required</h3>
        <p class="permission-description" id="permissionDescription">
          To scan QR codes, we need access to your device's camera. This allows you to quickly check in attendees by scanning their tickets.
        </p>
        <div class="device-instructions" id="deviceInstructions">
          <h4 id="deviceType">Camera Instructions</h4>
          <ol id="instructionsList">
            <li>Allow camera access when prompted</li>
            <li>Position QR codes within the scanning area</li>
            <li>Use manual entry if camera doesn't work</li>
          </ol>
        </div>
        <div class="permission-buttons">
          <button class="permission-btn primary" id="enableCamera" onclick="handlePermissionRequest()">
            üì∑ Enable Camera
          </button>
          <button class="permission-btn secondary" id="useManualOnly" onclick="useManualMode()">
            ‚å®Ô∏è Manual Only
          </button>
        </div>
      </div>
    </div>

    <!-- Full-Screen Scanner Modal -->
    <div class="fullscreen-scanner-modal" id="fullscreenScannerModal">
      <div class="fullscreen-scanner-header">
        <div class="fullscreen-scanner-title">Scan Ticket QR Code</div>
        <button class="fullscreen-close-btn" onclick="closeFullscreenScanner()" aria-label="Close scanner">
          ‚úï
        </button>
      </div>
      <div class="fullscreen-scanner-container">
        <div class="fullscreen-scan-region scanning" id="fullscreenScanRegion">
          <div id="fullscreenReader"></div>
        </div>
        <div class="fullscreen-instructions">
          Position the QR code within the frame
        </div>
      </div>
    </div>

    <div class="manual-input-backdrop" id="manualBackdrop" onclick="hideManualInput()"></div>
    <div class="manual-input" id="manualInput">
      <h3>Manual Ticket Entry</h3>
      <input
        type="text"
        id="manualTicketId"
        class="admin-form-input"
        placeholder="Enter ticket ID..."
        autocomplete="off"
        data-testid="qr-manual-input"
      />
      <div class="manual-input-buttons">
        <button
          class="admin-btn admin-btn-primary"
          onclick="submitManualTicket()"
          data-testid="validate-ticket"
        >
          Check In
        </button>
      </div>
    </div>

    <!-- Event Selector Component -->
    <script src="/js/admin-event-selector.js"></script>
    <!-- QR Code Scanner -->
    <script src="/js/vendor/html5-qrcode.min.js" integrity="sha384-c9d8RFSL+u3exBOJ4Yp3HUJXS4znl9f+z66d1y54ig+ea249SpqR+w1wyvXz/lk+"></script>
    <script>
      let scanner = null;
      let sessionCount = 0;
      let isScanning = false;
      let timeManager = null;

      // Countdown timer variables for result modal
      let countdownInterval = null;
      let countdownTimeout = null;
      let countdownSeconds = 10;

      // Import timeManager
      import('/js/time-manager.js').then(module => {
        timeManager = module.default;
      });

      // HTML escaping function to prevent XSS attacks
      // CRITICAL: Use this for ALL user-provided data displayed in innerHTML
      function escapeHtml(unsafe) {
        if (unsafe == null) return "";
        return String(unsafe)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Statistics with localStorage persistence
      const STATS_STORAGE_KEY = 'scanner_stats_v2';
      const SESSION_SCAN_LOG_IDS_KEY = 'session_scan_log_ids_v1';
      const STATS_SESSION_HOURS = 8;
      const MAX_SESSION_SCAN_LOGS = 900; // SQLite hard limit: 999 bind parameters, keep safety buffer

      // Conditional logging utility - only logs in development
      // Usage: Replace console.log() with debugLog.log() to prevent production logging
      // Example: debugLog.log('Debug info') instead of console.log('Debug info')
      // Error logs are always shown (even in production) for critical debugging
      const IS_PRODUCTION = window.location.hostname === 'www.alocubanoboulderfest.org' ||
                           window.location.hostname === 'alocubanoboulderfest.org';

      const debugLog = {
        log: (...args) => {
          if (!IS_PRODUCTION) {
            console.log(...args);
          }
        },
        warn: (...args) => {
          if (!IS_PRODUCTION) {
            console.warn(...args);
          }
        },
        error: (...args) => {
          // Always log errors, even in production
          console.error(...args);
        },
        info: (...args) => {
          if (!IS_PRODUCTION) {
            console.info(...args);
          }
        }
      };

      // Session scan log IDs for database queries
      const sessionScanLogIds = [];

      const stats = {
        // Server baselines (loaded from API, never incremented)
        todayBaseline: 0,
        totalBaseline: 0,
        validBaseline: 0,
        failedBaseline: 0,
        rateLimitedBaseline: 0,
        alreadyScannedBaseline: 0,

        // Session increments (persisted, incremented locally)
        todayIncrement: 0,
        queued: 0,
        session: 0,
        failed: 0,
        invalid: 0,
        validationTimes: [],

        // NEW: Session-level category increments for accurate card display
        sessionValidIncrement: 0,
        sessionFailedIncrement: 0,
        sessionRateLimitedIncrement: 0,
        sessionAlreadyScannedIncrement: 0,

        // Session metadata
        sessionStart: Date.now(),
        lastActivity: Date.now()
      };

      // Restore from localStorage
      function restoreSessionStats() {
        try {
          const stored = localStorage.getItem(STATS_STORAGE_KEY);
          if (!stored) return;

          const data = JSON.parse(stored);
          const age = (Date.now() - data.sessionStart) / (1000 * 60 * 60);

          // Expire after 8 hours
          if (age > STATS_SESSION_HOURS) {
            localStorage.removeItem(STATS_STORAGE_KEY);
            console.log('Session stats expired after 8 hours');
            return;
          }

          // Restore session stats only (not baselines)
          stats.todayIncrement = data.todayIncrement || 0;
          stats.appleWalletIncrement = data.appleWalletIncrement || 0;
          stats.googleWalletIncrement = data.googleWalletIncrement || 0;
          stats.session = data.session || 0;
          stats.queued = data.queued || 0;
          stats.failed = data.failed || 0;
          stats.invalid = data.invalid || 0;
          stats.validationTimes = data.validationTimes || [];

          // Restore new session category increments
          stats.sessionValidIncrement = data.sessionValidIncrement || 0;
          stats.sessionFailedIncrement = data.sessionFailedIncrement || 0;
          stats.sessionRateLimitedIncrement = data.sessionRateLimitedIncrement || 0;
          stats.sessionAlreadyScannedIncrement = data.sessionAlreadyScannedIncrement || 0;

          stats.sessionStart = data.sessionStart;
          console.log('Restored session stats:', { session: stats.session, todayIncrement: stats.todayIncrement });
        } catch (error) {
          console.error('Failed to restore stats:', error);
        }
      }

      // Save to localStorage
      function persistSessionStats() {
        try {
          localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify({
            todayIncrement: stats.todayIncrement,
            appleWalletIncrement: stats.appleWalletIncrement,
            googleWalletIncrement: stats.googleWalletIncrement,
            session: stats.session,
            queued: stats.queued,
            failed: stats.failed,
            invalid: stats.invalid,
            validationTimes: stats.validationTimes.slice(-100), // Keep last 100

            // New session category increments
            sessionValidIncrement: stats.sessionValidIncrement,
            sessionFailedIncrement: stats.sessionFailedIncrement,
            sessionRateLimitedIncrement: stats.sessionRateLimitedIncrement,
            sessionAlreadyScannedIncrement: stats.sessionAlreadyScannedIncrement,

            sessionStart: stats.sessionStart,
            lastActivity: Date.now()
          }));

          // Also persist scan log IDs
          persistSessionScanLogIds();
        } catch (error) {
          if (error.name === 'QuotaExceededError') {
            console.error('localStorage quota exceeded - clearing old stats data');
            // Clear old data and retry with minimal stats
            localStorage.removeItem(STATS_STORAGE_KEY);
            try {
              localStorage.setItem(STATS_STORAGE_KEY, JSON.stringify({
                todayIncrement: stats.todayIncrement,
                session: stats.session,
                validationTimes: stats.validationTimes.slice(-50), // Keep only last 50
                sessionStart: stats.sessionStart,
                lastActivity: Date.now()
              }));
            } catch (retryError) {
              console.error('Unable to save stats even after truncation:', retryError);
            }
          } else {
            console.error('Failed to persist stats:', error);
          }
        }
      }

      // Restore session scan log IDs from localStorage
      function restoreSessionScanLogIds() {
        try {
          const stored = localStorage.getItem(SESSION_SCAN_LOG_IDS_KEY);
          if (!stored) return;

          const data = JSON.parse(stored);
          const age = (Date.now() - data.sessionStart) / (1000 * 60 * 60);

          // Expire after 8 hours (same as session stats)
          if (age > STATS_SESSION_HOURS) {
            localStorage.removeItem(SESSION_SCAN_LOG_IDS_KEY);
            console.log('Session scan log IDs expired after 8 hours');
            return;
          }

          // Restore scan log IDs
          if (Array.isArray(data.ids)) {
            sessionScanLogIds.length = 0;
            sessionScanLogIds.push(...data.ids);
            console.log(`Restored ${sessionScanLogIds.length} session scan log IDs`);
          }
        } catch (error) {
          console.error('Failed to restore session scan log IDs:', error);
        }
      }

      // Save session scan log IDs to localStorage
      function persistSessionScanLogIds() {
        try {
          // Truncate to MAX_SESSION_SCAN_LOGS before saving
          const idsToSave = sessionScanLogIds.length > MAX_SESSION_SCAN_LOGS
            ? sessionScanLogIds.slice(-MAX_SESSION_SCAN_LOGS)
            : sessionScanLogIds;

          localStorage.setItem(SESSION_SCAN_LOG_IDS_KEY, JSON.stringify({
            ids: idsToSave,
            sessionStart: stats.sessionStart,
            lastActivity: Date.now()
          }));
        } catch (error) {
          if (error.name === 'QuotaExceededError') {
            console.error('localStorage quota exceeded - clearing old session data');
            // Clear old data and retry
            localStorage.removeItem(SESSION_SCAN_LOG_IDS_KEY);
            // Try again with truncated data
            try {
              const truncatedIds = sessionScanLogIds.slice(-500); // Save only last 500
              localStorage.setItem(SESSION_SCAN_LOG_IDS_KEY, JSON.stringify({
                ids: truncatedIds,
                sessionStart: stats.sessionStart,
                lastActivity: Date.now()
              }));
            } catch (retryError) {
              console.error('Unable to save session data even after truncation:', retryError);
            }
          } else {
            console.error('Failed to persist session scan log IDs:', error);
          }
        }
      }

      // Initialize - restore previous session if exists
      restoreSessionStats();
      restoreSessionScanLogIds();

      // Check localStorage availability
      try {
        localStorage.setItem('__storage_test__', 'test');
        localStorage.removeItem('__storage_test__');
      } catch (e) {
        console.warn('localStorage is not available - session data will not persist across page reloads');
        // Note: We don't show a UI notification here to avoid disrupting the user experience
        // The scanner will still work, just without session persistence
      }

      // Cross-tab synchronization - sync session data when changed in another tab
      window.addEventListener('storage', (event) => {
        // Only handle changes to our scanner storage keys
        if (event.key === STATS_STORAGE_KEY || event.key === SESSION_SCAN_LOG_IDS_KEY) {
          debugLog.log('[CROSS-TAB] Storage change detected from another tab', {
            key: event.key,
            oldValue: event.oldValue ? 'exists' : 'null',
            newValue: event.newValue ? 'exists' : 'null'
          });

          // Restore session data from localStorage (updated by other tab)
          if (event.key === STATS_STORAGE_KEY) {
            restoreSessionStats();
            updateStats();
            debugLog.log('[CROSS-TAB] Session stats synchronized from other tab');
          }

          // Restore session scan log IDs from localStorage (updated by other tab)
          if (event.key === SESSION_SCAN_LOG_IDS_KEY) {
            restoreSessionScanLogIds();
            debugLog.log('[CROSS-TAB] Session scan log IDs synchronized from other tab', {
              count: sessionScanLogIds.length
            });
          }
        }

        // Handle session clear from another tab
        if ((event.key === STATS_STORAGE_KEY || event.key === SESSION_SCAN_LOG_IDS_KEY) && event.newValue === null) {
          debugLog.log('[CROSS-TAB] Session cleared in another tab - syncing clear operation');

          if (event.key === STATS_STORAGE_KEY) {
            // Reset stats to match the clear operation
            stats.session = 0;
            stats.todayIncrement = 0;
            stats.appleWalletIncrement = 0;
            stats.googleWalletIncrement = 0;
            stats.queued = 0;
            stats.failed = 0;
            stats.invalid = 0;
            stats.validationTimes = [];
            updateStats();
          }

          if (event.key === SESSION_SCAN_LOG_IDS_KEY) {
            sessionScanLogIds.length = 0;
          }
        }
      });

      debugLog.log('[CROSS-TAB] Cross-tab synchronization initialized');

      // Performance monitoring and resource management
      const performanceMonitor = {
        scanTimes: [],
        errorCounts: {
          network: 0,
          validation: 0,
          camera: 0,
          memory: 0
        },
        memoryUsage: [],
        batteryInfo: null,
        fps: 0,
        frameCount: 0,
        lastFrameTime: 0,
        isLowPowerMode: false,
        sessionStartTime: Date.now(),
        scanCount: 0,
        cacheHits: 0,
        cacheMisses: 0,

        // Device capability scoring (0-100)
        deviceScore: 0,
        adaptiveSettings: {
          fps: 10,
          resolution: 'medium',
          scanInterval: 100,
          memoryThreshold: 0.8,
          batteryThreshold: 0.2
        }
      };

      // Audio feedback using Web Audio API
      const audioFeedback = {
        audioContext: null,
        initialized: false,

        init() {
          if (this.initialized) return;
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
          } catch (error) {
            console.warn('Web Audio API not supported:', error);
          }
        },

        playBeep(frequency, duration, type = 'sine') {
          if (!this.initialized) this.init();
          if (!this.audioContext) return;

          try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            // Fade out to prevent clicking
            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
          } catch (error) {
            console.warn('Error playing beep:', error);
          }
        },

        playSuccess() {
          // Pleasant ascending tone (C5 to E5)
          this.playBeep(523, 0.1, 'sine');
          setTimeout(() => this.playBeep(659, 0.1, 'sine'), 100);
        },

        playError() {
          // Lower tone pattern (indicates error)
          this.playBeep(200, 0.15, 'square');
          setTimeout(() => this.playBeep(180, 0.15, 'square'), 150);
        }
      };

      // Memory and resource management
      const resourceManager = {
        videoElement: null,
        mediaStream: null,
        cleanupTimers: [],
        memoryCheckInterval: null,
        performanceCheckInterval: null,
        lastCleanup: Date.now(),
        gcCallCount: 0,

        // Resource pooling for frequent allocations
        objectPool: {
          scanResults: [],
          tempArrays: [],
          imageData: []
        },

        // Lazy loading registry
        lazyComponents: new Map(),
        criticalResourcesLoaded: false
      };

      // Network optimization and caching
      const networkCache = {
        validationResults: new Map(),
        ticketData: new Map(),
        maxCacheSize: 100,
        cacheExpiry: 5 * 60 * 1000, // 5 minutes
        requestQueue: [],
        batchSize: 10,
        processingBatch: false
      };

      // Enhanced device and environment detection
      const deviceInfo = {
        isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
        isAndroid: /Android/.test(navigator.userAgent),
        isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        isChrome: /Chrome/.test(navigator.userAgent) && !/Edge|OPR/.test(navigator.userAgent),
        isPWA: window.matchMedia('(display-mode: standalone)').matches ||
               window.navigator.standalone === true,
        isIOSSafari: false,
        isAndroidChrome: false,
        version: null,
        androidVersion: null,
        chromeVersion: null
      };

      // Detect iOS Safari specifically
      deviceInfo.isIOSSafari = deviceInfo.isIOS && deviceInfo.isSafari;

      // Detect Android Chrome specifically
      deviceInfo.isAndroidChrome = deviceInfo.isAndroid && deviceInfo.isChrome;

      // Get iOS version if available
      if (deviceInfo.isIOS) {
        const match = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
        if (match) {
          deviceInfo.version = {
            major: parseInt(match[1]),
            minor: parseInt(match[2]),
            patch: parseInt(match[3] || 0)
          };
        }
      }

      // Get Android version if available
      if (deviceInfo.isAndroid) {
        const androidMatch = navigator.userAgent.match(/Android (\d+)\.?(\d+)?\.?(\d+)?/);
        if (androidMatch) {
          deviceInfo.androidVersion = {
            major: parseInt(androidMatch[1]),
            minor: parseInt(androidMatch[2] || 0),
            patch: parseInt(androidMatch[3] || 0)
          };
        }

        // Get Chrome version for Android Chrome
        if (deviceInfo.isChrome) {
          const chromeMatch = navigator.userAgent.match(/Chrome\/(\d+)\.?(\d+)?\.?(\d+)?/);
          if (chromeMatch) {
            deviceInfo.chromeVersion = {
              major: parseInt(chromeMatch[1]),
              minor: parseInt(chromeMatch[2] || 0),
              patch: parseInt(chromeMatch[3] || 0)
            };
          }
        }
      }

      // Permission state tracking with Android-specific persistence
      let permissionState = {
        granted: false,
        checked: false,
        persistent: false,
        androidPersistent: false // Android Chrome typically persists permissions
      };

      // Enhanced camera permission checker for both iOS and Android
      async function checkCameraPermissions() {
        try {
          // Android Chrome: Try navigator.permissions API first (well supported)
          if ('permissions' in navigator && 'camera' in navigator.permissions) {
            try {
              const result = await navigator.permissions.query({ name: 'camera' });
              permissionState.granted = result.state === 'granted';
              permissionState.persistent = result.state !== 'prompt';
              permissionState.checked = true;

              // Android Chrome has better permission persistence
              if (deviceInfo.isAndroidChrome) {
                permissionState.androidPersistent = result.state === 'granted';
                console.log(`Android Chrome permission via API: ${result.state} (persistent: ${permissionState.androidPersistent})`);

                // Set up permission change listener for Android
                result.addEventListener('change', () => {
                  permissionState.granted = result.state === 'granted';
                  permissionState.androidPersistent = result.state === 'granted';
                  console.log(`Android permission changed: ${result.state}`);
                });
              } else {
                console.log(`Camera permission via API: ${result.state}`);
              }

              return result.state;
            } catch (e) {
              console.log('Permissions API not supported, using fallback');
            }
          }

          // iOS Safari fallback: attempt getUserMedia to check permissions
          if (deviceInfo.isIOSSafari) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
              });

              // If we get here, permission is granted
              stream.getTracks().forEach(track => track.stop());
              permissionState.granted = true;
              permissionState.checked = true;
              permissionState.persistent = false; // iOS Safari asks every session

              console.log('iOS Safari: Camera permission granted via getUserMedia test');
              return 'granted';
            } catch (error) {
              permissionState.granted = false;
              permissionState.checked = true;

              if (error.name === 'NotAllowedError') {
                console.log('iOS Safari: Camera permission denied');
                return 'denied';
              } else if (error.name === 'NotFoundError') {
                console.log('iOS Safari: No camera found');
                return 'unavailable';
              } else {
                console.log('iOS Safari: Camera permission unknown:', error.name);
                return 'prompt';
              }
            }
          }

          // Android Chrome fallback: attempt getUserMedia to check permissions
          if (deviceInfo.isAndroidChrome) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
              });

              // If we get here, permission is granted
              stream.getTracks().forEach(track => track.stop());
              permissionState.granted = true;
              permissionState.checked = true;
              permissionState.androidPersistent = true; // Android Chrome typically persists

              console.log('Android Chrome: Camera permission granted via getUserMedia test');
              return 'granted';
            } catch (error) {
              permissionState.granted = false;
              permissionState.checked = true;

              if (error.name === 'NotAllowedError') {
                console.log('Android Chrome: Camera permission denied');
                return 'denied';
              } else if (error.name === 'NotFoundError') {
                console.log('Android Chrome: No camera found');
                return 'unavailable';
              } else {
                console.log('Android Chrome: Camera permission unknown:', error.name);
                return 'prompt';
              }
            }
          }

          return 'unknown';
        } catch (error) {
          console.error('Permission check failed:', error);
          return 'error';
        }
      }

      // Show iOS-specific permission guidance
      function showIOSPermissionGuidance() {
        const message = deviceInfo.isPWA
          ? 'Camera access in PWA mode may be limited. For best results:\n\n' +
            '1. Open this page in Safari directly\n' +
            '2. Allow camera access when prompted\n' +
            '3. Use manual entry if camera fails'
          : 'Camera access required for QR scanning:\n\n' +
            '1. Tap "Allow" when Safari asks for camera permission\n' +
            '2. If you previously denied access, go to Settings > Safari > Camera\n' +
            '3. You may need to allow permission each time you open the app';

        if (confirm(message + '\n\nTry manual entry instead?')) {
          showManualInput();
        }
      }

      // Show Android-specific permission guidance
      function showAndroidPermissionGuidance() {
        const message = deviceInfo.isPWA
          ? 'Camera access required for QR scanning. PWA detected:\n\n' +
            '1. Tap "Allow" when Chrome asks for camera permission\n' +
            '2. If denied, tap the camera icon in the address bar\n' +
            '3. Or go to Chrome Settings > Site Settings > Camera\n' +
            '4. Once granted, permission should persist across sessions'
          : 'Camera access required for QR scanning:\n\n' +
            '1. Tap "Allow" when Chrome asks for camera permission\n' +
            '2. If you previously denied access:\n' +
            '   - Tap the camera icon in the address bar, or\n' +
            '   - Go to Chrome Settings > Site Settings > Camera\n' +
            '3. Chrome typically remembers your choice for future visits';

        if (confirm(message + '\n\nTry manual entry instead?')) {
          showManualInput();
        }
      }

      // Show device-appropriate permission guidance
      function showPermissionGuidance() {
        if (deviceInfo.isIOSSafari) {
          showIOSPermissionGuidance();
        } else if (deviceInfo.isAndroidChrome) {
          showAndroidPermissionGuidance();
        } else {
          // Generic guidance for other browsers
          const message = 'Camera access required for QR scanning:\n\n' +
            '1. Allow camera access when prompted\n' +
            '2. Check browser settings if camera access was denied\n' +
            '3. Refresh the page and try again';

          if (confirm(message + '\n\nTry manual entry instead?')) {
            showManualInput();
          }
        }
      }

      /**
       * Get optimized scanner configuration for full-screen modal
       *
       * TUNABLE SCANNING PARAMETERS:
       *
       * 1. qrbox - Scan region size [REMOVED]
       *    Previous: 55% of viewport width, required precise QR alignment
       *    Current: REMOVED - scans entire camera frame
       *    Reason: Zero margin of error caused UX issues. QR codes had to be
       *            precisely within box boundaries. Full-frame scanning is more
       *            forgiving and matches user expectations.
       *
       * 2. fps - Frames per second for scanning
       *    Current: 30 for Android, 20 for iOS
       *    Impact: Higher = faster detection, more battery/CPU usage
       *            Lower = slower detection, better battery life
       *    Range: 5-30 fps (10 minimum recommended for good UX)
       *
       * 3. formatsToSupport - Barcode formats to detect
       *    Current: QR_CODE only
       *    Impact: Fewer formats = faster recognition
       *            More formats = slower but more versatile
       *    Options: QR_CODE, CODE_128, EAN_13, etc.
       *
       * OPTIONAL PARAMETERS (not currently used):
       *
       * - aspectRatio: Camera aspect ratio (default: 1.0)
       * - videoConstraints: Advanced camera settings
       *     { width: { min: 640, ideal: 1280, max: 1920 },
       *       height: { min: 480, ideal: 720, max: 1080 },
       *       facingMode: "environment" }
       * - disableFlip: Skip horizontal flip detection (may speed up 2x)
       * - experimentalFeatures.useBarCodeDetectorIfSupported:
       *     Use native BarcodeDetector API (Chrome only, much faster)
       * - qrbox: { width: number, height: number }
       *     Restricts scanning to specific region (NOT recommended - zero tolerance)
       */
      function getFullscreenScannerConfig() {
        // No qrbox - scans entire camera frame for maximum detection area
        // This eliminates the need for precise QR code alignment

        const config = {
          // qrbox removed - entire camera frame is now scannable
          // Previous: Required QR code to be precisely within box boundaries
          // Current: QR codes detected anywhere in camera view

          // FPS will be set below based on power mode
          fps: 30,

          // QR_CODE format only for faster recognition
          formatsToSupport: typeof Html5QrcodeSupportedFormats !== 'undefined'
            ? [Html5QrcodeSupportedFormats.QR_CODE]
            : undefined,

          // Enable native BarcodeDetector API (Chrome/Edge only, 2-3x faster)
          // Automatically falls back to ZXing.js on unsupported browsers
          useBarCodeDetectorIfSupported: true
        };

        // Apply FPS based on power mode
        if (performanceMonitor.isLowPowerMode) {
          config.fps = performanceMonitor.adaptiveSettings.fps;
        } else {
          config.fps = deviceInfo.isIOS ? 20 : 30;
          performanceMonitor.adaptiveSettings.fps = config.fps;
        }

        console.log('Full-screen scanner config:', {
          fps: config.fps,
          scanRegion: 'entire camera frame',
          formatsToSupport: 'QR_CODE only',
          isLowPowerMode: performanceMonitor.isLowPowerMode
        });

        return config;
      }

      // Performance monitoring and optimization functions
      function initializePerformanceMonitoring() {
        // Calculate device capability score
        performanceMonitor.deviceScore = calculateDeviceScore();

        // Set adaptive settings based on device score
        adaptivelyConfigureSettings();

        // Initialize battery monitoring if available
        initializeBatteryMonitoring();

        // Start memory monitoring
        startMemoryMonitoring();

        // Start performance metrics collection
        startPerformanceTracking();
      }

      function calculateDeviceScore() {
        let score = 50; // Base score

        // Memory assessment
        const memoryGB = navigator.deviceMemory || 4;
        score += Math.min(memoryGB * 5, 25); // Max 25 points for memory

        // CPU assessment (rough estimate based on user agent)
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('iphone 14') || userAgent.includes('iphone 15')) score += 20;
        else if (userAgent.includes('iphone 13') || userAgent.includes('iphone 12')) score += 15;
        else if (userAgent.includes('iphone 11') || userAgent.includes('iphone x')) score += 10;
        else if (userAgent.includes('iphone')) score += 5;

        // Android flagship detection
        if (userAgent.includes('pixel 7') || userAgent.includes('pixel 8')) score += 20;
        else if (userAgent.includes('galaxy s23') || userAgent.includes('galaxy s24')) score += 20;
        else if (userAgent.includes('galaxy s22') || userAgent.includes('galaxy s21')) score += 15;
        else if (userAgent.includes('android')) score += 5;

        // Browser optimizations
        if (deviceInfo.isAndroidChrome) score += 10;
        if (deviceInfo.isIOSSafari) score += 5;

        // Connection quality
        const connection = navigator.connection;
        if (connection) {
          if (connection.effectiveType === '4g') score += 10;
          else if (connection.effectiveType === '3g') score += 5;
          if (connection.saveData) score -= 10; // User wants to save data
        }

        return Math.min(Math.max(score, 0), 100);
      }

      function adaptivelyConfigureSettings() {
        const score = performanceMonitor.deviceScore;

        if (score >= 80) {
          // High-end device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 12 : 20;
          performanceMonitor.adaptiveSettings.resolution = 'high';
          performanceMonitor.adaptiveSettings.scanInterval = 50;
        } else if (score >= 60) {
          // Mid-range device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 10 : 15;
          performanceMonitor.adaptiveSettings.resolution = 'medium';
          performanceMonitor.adaptiveSettings.scanInterval = 100;
        } else {
          // Low-end device
          performanceMonitor.adaptiveSettings.fps = deviceInfo.isIOS ? 6 : 8;
          performanceMonitor.adaptiveSettings.resolution = 'low';
          performanceMonitor.adaptiveSettings.scanInterval = 200;
          performanceMonitor.isLowPowerMode = true;
        }

        console.log(`Device score: ${score}, Adaptive settings:`, performanceMonitor.adaptiveSettings);
      }

      async function initializeBatteryMonitoring() {
        try {
          if ('getBattery' in navigator) {
            const battery = await navigator.getBattery();
            performanceMonitor.batteryInfo = {
              level: battery.level,
              charging: battery.charging,
              dischargingTime: battery.dischargingTime,
              chargingTime: battery.chargingTime
            };

            // Enable low power mode if battery is low
            if (battery.level < performanceMonitor.adaptiveSettings.batteryThreshold) {
              enableLowPowerMode();
            }

            // Listen for battery changes
            battery.addEventListener('levelchange', () => {
              performanceMonitor.batteryInfo.level = battery.level;
              if (battery.level < performanceMonitor.adaptiveSettings.batteryThreshold) {
                enableLowPowerMode();
              } else if (battery.level > 0.5 && performanceMonitor.isLowPowerMode) {
                disableLowPowerMode();
              }
            });

            battery.addEventListener('chargingchange', () => {
              performanceMonitor.batteryInfo.charging = battery.charging;
              if (battery.charging && performanceMonitor.isLowPowerMode) {
                disableLowPowerMode();
              }
            });
          }
        } catch (error) {
          console.log('Battery API not available:', error);
        }
      }

      function enableLowPowerMode() {
        if (performanceMonitor.isLowPowerMode) return;

        performanceMonitor.isLowPowerMode = true;

        // Reduce performance settings
        performanceMonitor.adaptiveSettings.fps = Math.max(4, performanceMonitor.adaptiveSettings.fps * 0.6);
        performanceMonitor.adaptiveSettings.scanInterval *= 2;

        // Restart scanner with low power settings if running
        if (isScanning) {
          console.log('Enabling low power mode, restarting scanner');
          restartScannerWithNewSettings();
        }

        console.log('Low power mode enabled');
      }

      function disableLowPowerMode() {
        if (!performanceMonitor.isLowPowerMode) return;

        performanceMonitor.isLowPowerMode = false;

        // Restore performance settings
        adaptivelyConfigureSettings();

        // Restart scanner with normal settings if running
        if (isScanning) {
          console.log('Disabling low power mode, restarting scanner');
          restartScannerWithNewSettings();
        }

        console.log('Low power mode disabled');
      }

      function startMemoryMonitoring() {
        const checkMemory = () => {
          try {
            if ('memory' in performance) {
              const memInfo = performance.memory;
              const usageRatio = memInfo.usedJSHeapSize / memInfo.totalJSHeapSize;

              performanceMonitor.memoryUsage.push({
                timestamp: Date.now(),
                used: memInfo.usedJSHeapSize,
                total: memInfo.totalJSHeapSize,
                ratio: usageRatio
              });

              // Keep only last 50 readings
              if (performanceMonitor.memoryUsage.length > 50) {
                performanceMonitor.memoryUsage.shift();
              }

              // Trigger cleanup if memory usage is high
              if (usageRatio > performanceMonitor.adaptiveSettings.memoryThreshold) {
                performMemoryCleanup();
              }
            }
          } catch (error) {
            console.log('Memory monitoring error:', error);
          }
        };

        resourceManager.memoryCheckInterval = setInterval(checkMemory, 10000); // Check every 10 seconds
        checkMemory(); // Initial check
      }

      function performMemoryCleanup() {
        const now = Date.now();

        // Avoid frequent cleanups
        if (now - resourceManager.lastCleanup < 30000) return;

        resourceManager.lastCleanup = now;
        resourceManager.gcCallCount++;

        try {
          // Clear old cache entries
          cleanupNetworkCache();

          // Clear performance monitoring arrays
          if (performanceMonitor.scanTimes.length > 20) {
            performanceMonitor.scanTimes = performanceMonitor.scanTimes.slice(-10);
          }

          if (performanceMonitor.memoryUsage.length > 20) {
            performanceMonitor.memoryUsage = performanceMonitor.memoryUsage.slice(-10);
          }

          // Return objects to pool
          while (resourceManager.objectPool.scanResults.length > 10) {
            resourceManager.objectPool.scanResults.pop();
          }

          // Force garbage collection if available
          if (window.gc) {
            window.gc();
          }

          console.log(`Memory cleanup performed (${resourceManager.gcCallCount} times)`);
          performanceMonitor.errorCounts.memory++;

        } catch (error) {
          console.error('Memory cleanup error:', error);
        }
      }

      function cleanupNetworkCache() {
        const now = Date.now();

        // Remove expired validation results
        for (const [key, value] of networkCache.validationResults.entries()) {
          if (now - value.timestamp > networkCache.cacheExpiry) {
            networkCache.validationResults.delete(key);
          }
        }

        // Remove expired ticket data
        for (const [key, value] of networkCache.ticketData.entries()) {
          if (now - value.timestamp > networkCache.cacheExpiry) {
            networkCache.ticketData.delete(key);
          }
        }

        // Limit cache size
        if (networkCache.validationResults.size > networkCache.maxCacheSize) {
          const entries = [...networkCache.validationResults.entries()];
          entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
          const toDelete = entries.slice(0, entries.length - networkCache.maxCacheSize + 10);
          toDelete.forEach(([key]) => networkCache.validationResults.delete(key));
        }
      }

      function startPerformanceTracking() {
        const trackPerformance = () => {
          try {
            // Calculate FPS
            const now = performance.now();
            if (performanceMonitor.lastFrameTime > 0) {
              const deltaTime = now - performanceMonitor.lastFrameTime;
              performanceMonitor.fps = 1000 / deltaTime;
            }
            performanceMonitor.lastFrameTime = now;
            performanceMonitor.frameCount++;

            // Collect performance entry data
            const entries = performance.getEntriesByType('measure');
            if (entries.length > 0) {
              const latestEntry = entries[entries.length - 1];
              console.log(`Performance: ${latestEntry.name} took ${latestEntry.duration.toFixed(2)}ms`);
            }

          } catch (error) {
            console.log('Performance tracking error:', error);
          }
        };

        resourceManager.performanceCheckInterval = setInterval(trackPerformance, 1000);
      }

      function measureScanPerformance(operation, startTime) {
        try {
          const endTime = performance.now();
          const duration = endTime - startTime;

          performanceMonitor.scanTimes.push({
            operation,
            duration,
            timestamp: Date.now()
          });

          // Keep only last 50 measurements
          if (performanceMonitor.scanTimes.length > 50) {
            performanceMonitor.scanTimes.shift();
          }

          // Log slow operations
          if (duration > 1000) {
            console.warn(`Slow ${operation}: ${duration.toFixed(2)}ms`);
          }

          return duration;
        } catch (error) {
          console.error('Performance measurement error:', error);
          return 0;
        }
      }

      function getPerformanceMetrics() {
        const metrics = {
          deviceScore: performanceMonitor.deviceScore,
          sessionDuration: Date.now() - performanceMonitor.sessionStartTime,
          scanCount: performanceMonitor.scanCount,
          averageScanTime: 0,
          errorRate: 0,
          memoryUsage: performanceMonitor.memoryUsage.slice(-1)[0],
          batteryInfo: performanceMonitor.batteryInfo,
          cacheHitRate: 0,
          isLowPowerMode: performanceMonitor.isLowPowerMode,
          adaptiveSettings: performanceMonitor.adaptiveSettings
        };

        // Calculate averages
        if (performanceMonitor.scanTimes.length > 0) {
          metrics.averageScanTime = performanceMonitor.scanTimes
            .reduce((sum, scan) => sum + scan.duration, 0) / performanceMonitor.scanTimes.length;
        }

        const totalErrors = Object.values(performanceMonitor.errorCounts)
          .reduce((sum, count) => sum + count, 0);
        metrics.errorRate = totalErrors / (performanceMonitor.scanCount + totalErrors);

        const totalCacheRequests = performanceMonitor.cacheHits + performanceMonitor.cacheMisses;
        if (totalCacheRequests > 0) {
          metrics.cacheHitRate = performanceMonitor.cacheHits / totalCacheRequests;
        }

        return metrics;
      }

      async function restartScannerWithNewSettings() {
        if (!scanner || !isScanning) return;

        try {
          await stopScanner();
          setTimeout(() => {
            initScanner();
          }, 500);
        } catch (error) {
          console.error('Error restarting scanner:', error);
        }
      }

      // Resource cleanup functions
      function cleanupResources() {
        try {
          // Clear all timers
          resourceManager.cleanupTimers.forEach(timer => clearTimeout(timer));
          resourceManager.cleanupTimers = [];

          if (resourceManager.memoryCheckInterval) {
            clearInterval(resourceManager.memoryCheckInterval);
            resourceManager.memoryCheckInterval = null;
          }

          if (resourceManager.performanceCheckInterval) {
            clearInterval(resourceManager.performanceCheckInterval);
            resourceManager.performanceCheckInterval = null;
          }

          // Clean up video element
          if (resourceManager.videoElement) {
            resourceManager.videoElement.srcObject = null;
            resourceManager.videoElement = null;
          }

          // Clean up media stream
          if (resourceManager.mediaStream) {
            resourceManager.mediaStream.getTracks().forEach(track => {
              track.stop();
            });
            resourceManager.mediaStream = null;
          }

          // Clear caches
          networkCache.validationResults.clear();
          networkCache.ticketData.clear();

          console.log('Resources cleaned up');
        } catch (error) {
          console.error('Error during resource cleanup:', error);
        }
      }

      // Lazy loading implementation
      function lazyLoadComponent(componentName, loader) {
        if (resourceManager.lazyComponents.has(componentName)) {
          return resourceManager.lazyComponents.get(componentName);
        }

        const promise = loader();
        resourceManager.lazyComponents.set(componentName, promise);
        return promise;
      }

      // Network caching for validation results
      function getCachedValidationResult(qrToken) {
        const cached = networkCache.validationResults.get(qrToken);
        if (cached && (Date.now() - cached.timestamp) < networkCache.cacheExpiry) {
          performanceMonitor.cacheHits++;
          return cached.data;
        }
        performanceMonitor.cacheMisses++;
        return null;
      }

      function setCachedValidationResult(qrToken, data) {
        networkCache.validationResults.set(qrToken, {
          data,
          timestamp: Date.now()
        });
      }

      // Batch network requests
      function addToRequestQueue(request) {
        networkCache.requestQueue.push(request);

        if (!networkCache.processingBatch) {
          scheduleRequestBatch();
        }
      }

      function scheduleRequestBatch() {
        networkCache.processingBatch = true;

        setTimeout(async () => {
          if (networkCache.requestQueue.length === 0) {
            networkCache.processingBatch = false;
            return;
          }

          const batch = networkCache.requestQueue.splice(0, networkCache.batchSize);

          try {
            // Process batch requests
            await Promise.allSettled(batch.map(request => request()));
          } catch (error) {
            console.error('Batch request error:', error);
          }

          networkCache.processingBatch = false;

          // Schedule next batch if more requests pending
          if (networkCache.requestQueue.length > 0) {
            scheduleRequestBatch();
          }
        }, 100);
      }

      // UI State Management
      const uiState = {
        isPermissionModalShown: false,
        isLoading: false,
        isError: false,
        loadingTimeout: null
      };

      // Show permission request modal with device-specific instructions
      function showPermissionModal() {
        if (uiState.isPermissionModalShown) return;

        const modal = document.getElementById('permissionModal');
        const icon = document.getElementById('permissionIcon');
        const title = document.getElementById('permissionTitle');
        const description = document.getElementById('permissionDescription');
        const deviceType = document.getElementById('deviceType');
        const instructionsList = document.getElementById('instructionsList');

        // Device-specific customization
        if (deviceInfo.isIOSSafari) {
          icon.textContent = 'üì±';
          title.textContent = 'iOS Camera Access';
          description.textContent = 'Safari needs permission to access your camera for QR code scanning. This helps you quickly check in attendees.';
          deviceType.textContent = 'iOS Safari Instructions';

          const instructions = deviceInfo.isPWA ? [
            'Tap "Allow" when Safari asks for camera permission',
            'If you previously denied access, go to Settings > Safari > Camera',
            'PWA mode may have limitations - use Safari directly if needed',
            'You may need to grant permission each time you open the app'
          ] : [
            'Tap "Allow" when Safari asks for camera permission',
            'If you previously denied access, go to Settings > Safari > Camera',
            'Grant permission each time if using private browsing',
            'Position QR codes clearly within the scanning area'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        } else if (deviceInfo.isAndroidChrome) {
          icon.textContent = 'ü§ñ';
          title.textContent = 'Android Camera Access';
          description.textContent = 'Chrome needs permission to access your camera for QR code scanning. This permission will be remembered for future visits.';
          deviceType.textContent = 'Android Chrome Instructions';

          const instructions = deviceInfo.isPWA ? [
            'Tap "Allow" when Chrome asks for camera permission',
            'Permission will be saved for future use in PWA mode',
            'If denied, tap the camera icon in the address bar',
            'Or go to Chrome Settings > Site Settings > Camera'
          ] : [
            'Tap "Allow" when Chrome asks for camera permission',
            'Chrome will remember your choice for future visits',
            'If previously denied, tap the camera icon in address bar',
            'Ensure good lighting for better QR code detection'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        } else {
          icon.textContent = 'üì∑';
          title.textContent = 'Camera Access Required';
          description.textContent = 'Your browser needs permission to access the camera for QR code scanning. This enables quick attendee check-ins.';
          deviceType.textContent = 'Browser Instructions';

          const instructions = [
            'Allow camera access when your browser prompts',
            'Check browser settings if camera access was denied',
            'Refresh the page and try again if needed',
            'Use manual entry if camera issues persist'
          ];

          instructionsList.innerHTML = instructions.map(inst => `<li>${inst}</li>`).join('');
        }

        modal.classList.add('show');
        uiState.isPermissionModalShown = true;

        // Announce to screen readers
        announceToScreenReader(`${title.textContent}. ${description.textContent} Press Enter to enable camera or Escape to use manual entry.`);

        // Focus the primary button for accessibility
        setTimeout(() => {
          document.getElementById('enableCamera').focus();
        }, 300);
      }

      // Hide permission modal
      function hidePermissionModal() {
        const modal = document.getElementById('permissionModal');
        modal.classList.remove('show');
        uiState.isPermissionModalShown = false;
      }

      // Handle permission request from modal
      async function handlePermissionRequest() {
        hidePermissionModal();
        showLoadingState('Requesting camera access...', 'Please allow camera permissions when prompted');

        try {
          await actuallyInitScanner();
        } catch (error) {
          console.error('Permission request failed:', error);
          showErrorState('Permission Denied', 'Camera access was not granted. You can retry or use manual entry.', 'permission');
        }
      }

      // Use manual mode only (bypass camera entirely)
      function useManualMode() {
        hidePermissionModal();
        showManualInput();
      }

      // Show loading state
      function showLoadingState(text = 'Initializing Camera', subtext = 'Please wait while we access your camera...') {
        if (uiState.isLoading) return;

        const loadingEl = document.getElementById('scannerLoading');
        const loadingText = document.getElementById('loadingText');
        const loadingSubtext = document.getElementById('loadingSubtext');

        if (!loadingEl || !loadingText || !loadingSubtext) {
          console.warn('Loading state elements not found');
          return;
        }

        loadingText.textContent = text;
        loadingSubtext.textContent = subtext;
        loadingEl.style.display = 'block';
        loadingEl.classList.add('show');
        uiState.isLoading = true;

        // Announce to screen readers
        announceToScreenReader(`${text}. ${subtext}`);

        // Auto-hide loading after 30 seconds as fallback
        uiState.loadingTimeout = setTimeout(() => {
          if (uiState.isLoading) {
            hideLoadingState();
            showErrorState('Timeout', 'Camera initialization took too long. Please try again.', 'timeout');
          }
        }, 30000);
      }

      // Hide loading state
      function hideLoadingState() {
        const loadingEl = document.getElementById('scannerLoading');
        if (!loadingEl) return;

        loadingEl.style.display = 'none';
        loadingEl.classList.remove('show');
        uiState.isLoading = false;

        if (uiState.loadingTimeout) {
          clearTimeout(uiState.loadingTimeout);
          uiState.loadingTimeout = null;
        }
      }

      // Show error state
      function showErrorState(title, message, errorType = 'generic') {
        hideLoadingState();

        const errorEl = document.getElementById('scannerError');
        const errorIcon = document.getElementById('errorIcon');
        const errorTitle = document.getElementById('errorTitle');
        const errorMessage = document.getElementById('errorMessage');
        const retryBtn = document.getElementById('retryCamera');
        const settingsBtn = document.getElementById('openSettings');

        errorTitle.textContent = title;
        errorMessage.textContent = message;

        // Customize based on error type
        switch (errorType) {
          case 'permission':
            errorIcon.textContent = 'üö´';
            retryBtn.textContent = 'üîÑ Try Again';
            settingsBtn.style.display = 'inline-block';
            break;
          case 'not_found':
            errorIcon.textContent = 'üì∑';
            retryBtn.textContent = 'üîÑ Retry';
            settingsBtn.style.display = 'none';
            break;
          case 'in_use':
            errorIcon.textContent = '‚ö†Ô∏è';
            retryBtn.textContent = 'üîÑ Retry';
            settingsBtn.style.display = 'none';
            break;
          case 'timeout':
            errorIcon.textContent = '‚è∞';
            retryBtn.textContent = 'üîÑ Retry';
            settingsBtn.style.display = 'none';
            break;
          default:
            errorIcon.textContent = '‚ùå';
            retryBtn.textContent = 'üîÑ Retry';
            settingsBtn.style.display = 'none';
        }

        errorEl.classList.add('show');
        uiState.isError = true;

        // Announce to screen readers
        const actions = settingsBtn.style.display !== 'none'
          ? 'Available options: Retry Camera, Manual Entry, or Settings'
          : 'Available options: Retry Camera or Manual Entry';
        announceToScreenReader(`${title}. ${message}. ${actions}. Press Escape to close.`);

        // Focus retry button for accessibility
        setTimeout(() => {
          retryBtn.focus();
        }, 300);
      }

      // Hide error state
      function hideErrorState() {
        const errorEl = document.getElementById('scannerError');
        errorEl.classList.remove('show');
        uiState.isError = false;
      }

      // Show success indicator
      function showSuccessIndicator(duration = 2000) {
        const successEl = document.getElementById('scannerSuccess');
        successEl.classList.add('show');

        // Announce to screen readers
        announceToScreenReader('Camera ready. Scanner is now active and ready to scan QR codes.');

        setTimeout(() => {
          successEl.classList.remove('show');
        }, duration);
      }

      // Retry scanner initialization
      function retryScanner() {
        hideErrorState();
        initScanner();
      }

      // Open camera settings (platform-specific)
      function openCameraSettings() {
        let message = 'To enable camera access:\n\n';

        if (deviceInfo.isIOSSafari) {
          message += 'iOS Safari:\n1. Go to Settings > Safari > Camera\n2. Select "Allow" for this website\n3. Refresh this page';
        } else if (deviceInfo.isAndroidChrome) {
          message += 'Android Chrome:\n1. Tap the camera icon in the address bar\n2. Select "Allow"\n3. Or go to Chrome Settings > Site Settings > Camera';
        } else {
          message += 'Browser Settings:\n1. Look for camera/permissions in browser settings\n2. Allow camera access for this website\n3. Refresh this page';
        }

        alert(message);
      }

      // Enhanced scanner initialization with iOS and Android support
      async function initScanner() {
        try {
          console.log('Initializing scanner...', deviceInfo);

          // Pre-check permissions based on device type
          const permissionResult = await checkCameraPermissions();

          if (permissionResult === 'denied') {
            showPermissionModal();
            return;
          } else if (permissionResult === 'unavailable') {
            showErrorState('No Camera Found', 'No camera was detected on this device. Please use manual entry.', 'not_found');
            return;
          } else if (permissionResult === 'prompt') {
            showPermissionModal();
            return;
          }

          await actuallyInitScanner();

        } catch (error) {
          console.error("Scanner initialization failed:", error);
          showErrorState('Initialization Failed', 'Failed to initialize camera scanner. Please try again or use manual entry.', 'generic');
        }
      }

      // Actual scanner initialization (separated for reuse)
      async function actuallyInitScanner() {
        const initStartTime = performance.now();
        showLoadingState('Starting camera...', 'Initializing QR code scanner');

        try {
          // Initialize performance monitoring if not already done
          if (performanceMonitor.deviceScore === 0) {
            initializePerformanceMonitoring();
          }

          // Initialize Html5QrCode instance
          scanner = new Html5Qrcode("reader");

          // Get device-optimized configuration
          const config = getFullscreenScannerConfig();
          console.log('Scanner config for', deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'generic', ':', config);

          // Device-agnostic camera constraints
          const cameraConstraints = {
            facingMode: "environment"
          };

          // Attempt to start scanner with error handling
          await scanner.start(
            cameraConstraints,
            config,
            onScanSuccess,
            onScanError
          );

          isScanning = true;
          console.log('Scanner started successfully');

          // Measure initialization performance
          measureScanPerformance('scanner_initialization', initStartTime);

          hideLoadingState();
          showSuccessIndicator();

          // Apply device-specific video attributes and memory optimization
          setTimeout(() => {
            const videoElement = document.querySelector('#reader video');
            if (videoElement) {
              // Store reference for resource management
              resourceManager.videoElement = videoElement;

              // Get media stream for proper cleanup
              if (videoElement.srcObject) {
                resourceManager.mediaStream = videoElement.srcObject;
              }

              if (deviceInfo.isIOS) {
                // iOS-specific attributes
                videoElement.setAttribute('playsinline', '');
                videoElement.setAttribute('webkit-playsinline', '');
                videoElement.muted = true;

                // iOS memory optimization
                videoElement.style.objectFit = 'cover';
                videoElement.style.transformOrigin = 'center center';

                console.log('iOS video attributes and optimizations applied');
              } else if (deviceInfo.isAndroid) {
                // Android-specific attributes
                videoElement.setAttribute('playsinline', '');
                videoElement.muted = true;

                // Android Chrome specific optimizations
                if (deviceInfo.isAndroidChrome) {
                  videoElement.style.objectFit = 'cover';
                  videoElement.style.willChange = 'auto'; // Avoid unnecessary GPU layers
                  console.log('Android Chrome video attributes applied');
                }
              }

              // Universal performance optimizations
              videoElement.style.imageRendering = 'optimizeSpeed';
              videoElement.style.backfaceVisibility = 'hidden';

              // Add performance monitoring for video frames
              if (performanceMonitor.isLowPowerMode) {
                videoElement.style.transform = 'scale(0.8)'; // Reduce processing load
              }
            }
          }, 1000);

        } catch (startError) {
          console.error('Scanner start error:', startError);
          handleScannerStartError(startError);
        }
      }

      // Handle scanner start errors with device-specific messaging
      function handleScannerStartError(error) {
        console.error('Scanner start error details:', {
          name: error.name,
          message: error.message,
          code: error.code,
          device: deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'unknown'
        });

        let title, message, errorType;

        // iOS-specific error handling
        if (deviceInfo.isIOSSafari) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = deviceInfo.isPWA
              ? 'Camera access was denied. For PWA mode, you may need to open this page in Safari directly and grant permission.'
              : 'Camera access was denied. Please go to Settings > Safari > Camera to enable access for this website.';
            errorType = 'permission';
          } else if (error.name === 'OverconstrainedError') {
            // iOS-specific: camera constraints too restrictive
            console.log('iOS: Retrying with relaxed constraints');
            retryWithRelaxedConstraints();
            return;
          } else if (error.name === 'NotFoundError') {
            title = 'No Camera Found';
            message = 'This iOS device does not have a camera available for use.';
            errorType = 'not_found';
          } else {
            title = 'iOS Camera Error';
            message = `Camera initialization failed on iOS: ${error.message}`;
            errorType = 'generic';
          }
        }
        // Android-specific error handling
        else if (deviceInfo.isAndroidChrome) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = deviceInfo.isPWA
              ? 'Camera access was denied. Tap the camera icon in the address bar or go to Chrome Settings > Site Settings > Camera to enable access.'
              : 'Camera access was denied. Chrome will remember your choice. Tap the camera icon in the address bar to change permissions.';
            errorType = 'permission';
          } else if (error.name === 'OverconstrainedError') {
            // Android: try with fallback constraints
            console.log('Android: Retrying with relaxed constraints');
            retryWithRelaxedConstraints();
            return;
          } else if (error.name === 'NotFoundError') {
            title = 'No Camera Found';
            message = 'No camera was detected on this Android device.';
            errorType = 'not_found';
          } else if (error.name === 'AbortError') {
            title = 'Camera In Use';
            message = 'Camera is currently being used by another app. Please close other camera apps and try again.';
            errorType = 'in_use';
          } else if (error.name === 'NotReadableError') {
            title = 'Camera Unavailable';
            message = 'Camera is not accessible. It may be in use by another application or browser tab.';
            errorType = 'in_use';
          } else {
            title = 'Android Camera Error';
            message = `Camera initialization failed: ${error.message}`;
            errorType = 'generic';
          }
        }
        // Generic Android handling for non-Chrome browsers
        else if (deviceInfo.isAndroid && !deviceInfo.isChrome) {
          if (error.name === 'NotAllowedError') {
            title = 'Camera Permission Denied';
            message = 'Camera access was denied. For better camera support, consider using Chrome browser. Check your browser settings to enable camera access.';
            errorType = 'permission';
          } else {
            title = 'Camera Error';
            message = `Camera not available on this Android browser: ${error.message}. Consider using Chrome for better compatibility.`;
            errorType = 'generic';
          }
        }
        // General error handling for other platforms
        else {
          switch (error.name) {
            case 'NotAllowedError':
              title = 'Camera Permission Denied';
              message = 'Camera access was denied. Please check your browser settings and allow camera access for this website.';
              errorType = 'permission';
              break;
            case 'NotFoundError':
              title = 'No Camera Found';
              message = 'No camera was detected on this device.';
              errorType = 'not_found';
              break;
            case 'NotReadableError':
              title = 'Camera Unavailable';
              message = 'Camera is already in use by another application. Please close other camera apps and try again.';
              errorType = 'in_use';
              break;
            case 'OverconstrainedError':
              console.log('Generic: Retrying with relaxed constraints');
              retryWithRelaxedConstraints();
              return;
            case 'SecurityError':
              title = 'Security Error';
              message = 'Camera access blocked for security reasons. Please check your browser settings.';
              errorType = 'permission';
              break;
            default:
              title = 'Camera Error';
              message = `Camera initialization failed: ${error.message}`;
              errorType = 'generic';
          }
        }

        showErrorState(title, message, errorType);
      }

      // Handle scanner initialization errors
      function handleScannerInitError(error) {
        console.error('Scanner init error:', error);
        showErrorState('Initialization Failed', 'Failed to initialize camera scanner. Please use manual entry mode.', 'generic');
      }

      // Retry scanner with relaxed constraints (device-agnostic fallback)
      async function retryWithRelaxedConstraints() {
        try {
          console.log('Retrying scanner with relaxed constraints for',
            deviceInfo.isIOS ? 'iOS' : deviceInfo.isAndroid ? 'Android' : 'generic device');

          showLoadingState('Retrying with relaxed settings...', 'Attempting camera initialization with compatibility mode');

          if (scanner) {
            try {
              await scanner.stop();
            } catch (e) {
              console.log('Error stopping scanner during retry:', e);
            }
          }

          scanner = new Html5Qrcode("reader");

          // Device-specific relaxed configurations
          let relaxedConfig;

          if (deviceInfo.isIOS) {
            relaxedConfig = {
              fps: 5,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              videoConstraints: {
                facingMode: "environment"
                // Remove resolution constraints for iOS compatibility
              }
            };
          } else if (deviceInfo.isAndroid) {
            relaxedConfig = {
              fps: deviceInfo.isAndroidChrome ? 10 : 8,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              experimentalFeatures: {
                useBarCodeDetectorIfSupported: false // Disable for stability during retry
              },
              videoConstraints: {
                facingMode: "environment",
                // Minimal constraints for Android compatibility
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            };
          } else {
            // Generic fallback
            relaxedConfig = {
              fps: 8,
              qrbox: { width: 250, height: 250 },
              aspectRatio: 1.0,
              videoConstraints: {
                facingMode: "environment"
              }
            };
          }

          await scanner.start(
            { facingMode: { ideal: "environment" } },
            relaxedConfig,
            onScanSuccess,
            onScanError
          );

          isScanning = true;
          console.log('Scanner started with relaxed constraints');

          hideLoadingState();
          showSuccessIndicator();

        } catch (retryError) {
          console.error('Retry failed:', retryError);

          // Device-specific retry failure messages
          let title = 'Retry Failed';
          let message = 'Camera scanner could not be initialized even with relaxed settings. Please use manual entry.';

          if (deviceInfo.isAndroidChrome && retryError.name === 'OverconstrainedError') {
            title = 'Android Compatibility Issue';
            message = 'This Android device\'s camera doesn\'t support the required settings for QR scanning.';
          } else if (deviceInfo.isIOS && retryError.name === 'OverconstrainedError') {
            title = 'iOS Compatibility Issue';
            message = 'iOS camera constraints not supported on this device. Manual entry is recommended.';
          } else if (retryError.name === 'NotAllowedError') {
            title = 'Permission Still Denied';
            message = 'Camera access is still denied. Please check your browser settings or use manual entry.';
          }

          showErrorState(title, message, 'generic');
        }
      }

      // Stop scanner safely with enhanced resource cleanup
      async function stopScanner() {
        if (scanner && isScanning) {
          const stopStartTime = performance.now();

          try {
            await scanner.stop();
            isScanning = false;

            // Enhanced resource cleanup
            if (resourceManager.mediaStream) {
              resourceManager.mediaStream.getTracks().forEach(track => {
                track.stop();
                console.log(`Stopped ${track.kind} track`);
              });
              resourceManager.mediaStream = null;
            }

            // Clean up video element reference
            if (resourceManager.videoElement) {
              resourceManager.videoElement.srcObject = null;
              resourceManager.videoElement = null;
            }

            // Measure stop performance
            measureScanPerformance('scanner_stop', stopStartTime);

            console.log('Scanner stopped with resource cleanup');
          } catch (error) {
            console.error('Error stopping scanner:', error);
            performanceMonitor.errorCounts.camera++;
            isScanning = false;

            // Force cleanup even if stop failed
            try {
              if (resourceManager.mediaStream) {
                resourceManager.mediaStream.getTracks().forEach(track => track.stop());
                resourceManager.mediaStream = null;
              }
            } catch (cleanupError) {
              console.error('Force cleanup error:', cleanupError);
            }
          }
        }
      }

      // Add visibility change handler for mobile browser background behavior
      document.addEventListener('visibilitychange', async function() {
        if (!scanner) return;

        if (document.hidden) {
          // Page hidden, pause scanner (keeps camera alive, stops scanning)
          console.log('Page backgrounded, pausing scanner (camera stays warm)');

          try {
            // Check scanner state before pausing
            const state = scanner.getState();
            if (state === Html5QrcodeScannerState.SCANNING) {
              scanner.pause(false);  // Stop scanning, keep camera alive
              console.log('Scanner paused successfully');
            }
          } catch (error) {
            console.error('Error pausing scanner:', error);
            // Fallback: full stop if pause fails
            await stopScanner();
          }

        } else {
          // Page visible, resume scanner
          console.log('Page visible, resuming scanner');

          const delay = deviceInfo.isIOS ? 500 : deviceInfo.isAndroid ? 300 : 400;

          setTimeout(async () => {
            try {
              const state = scanner.getState();

              if (state === Html5QrcodeScannerState.PAUSED) {
                // Resume from pause
                scanner.resume();
                console.log('Scanner resumed successfully');
              } else if (!isScanning) {
                // Fallback: reinitialize if needed
                console.log('Scanner not paused, reinitializing...');
                await initScanner();
              }
            } catch (error) {
              console.error('Error resuming scanner:', error);
              // Last resort: full reinit
              await initScanner();
            }
          }, delay);
        }
      });

      // Android-specific: Handle page focus/blur for better camera resource management
      if (deviceInfo.isAndroid) {
        window.addEventListener('blur', function() {
          if (scanner && isScanning) {
            console.log('Android: Window lost focus, pausing scanner');
            // Android Chrome: pause scanner instead of full stop
            setTimeout(() => {
              if (document.hidden && scanner) {
                try {
                  const state = scanner.getState();
                  if (state === Html5QrcodeScannerState.SCANNING) {
                    scanner.pause(false);  // Use pause instead of stop
                    console.log('Android blur: Scanner paused');
                  }
                } catch (error) {
                  console.error('Android blur: Error pausing scanner:', error);
                }
              }
            }, 1000);
          }
        });

        window.addEventListener('focus', function() {
          if (scanner && !isScanning && !document.hidden) {
            console.log('Android: Window gained focus, checking scanner state');
            setTimeout(() => {
              if (!isScanning && !document.hidden) {
                initScanner();
              }
            }, 500);
          }
        });
      }

      // PWA-specific handling for both iOS and Android
      if (deviceInfo.isPWA) {
        // Handle PWA lifecycle events
        window.addEventListener('beforeinstallprompt', function(e) {
          console.log('PWA install prompt available');
        });

        // Handle PWA app state changes
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'PWA_STATE_CHANGE') {
              console.log('PWA state changed:', event.data.state);
              // Restart scanner if needed after PWA state change
              if (event.data.state === 'active' && !isScanning) {
                setTimeout(() => initScanner(), 1000);
              }
            }
          });
        }
      }

      // Enhanced cleanup when page unloads
      window.addEventListener('beforeunload', function() {
        try {
          // Stop scanner
          if (scanner) {
            scanner.stop();
          }

          // Comprehensive resource cleanup
          cleanupResources();

          // Send performance metrics if available
          if (navigator.sendBeacon && performanceMonitor.scanCount > 0) {
            const metrics = getPerformanceMetrics();
            navigator.sendBeacon('/api/performance-metrics', JSON.stringify({
              session: metrics,
              timestamp: Date.now(),
              userAgent: navigator.userAgent,
              deviceScore: performanceMonitor.deviceScore
            }));
          }

        } catch (error) {
          console.log('Enhanced cleanup error:', error);
        }
      });

      /**
       * Extract JWT token from QR code content
       * QR codes contain: https://domain.com/my-ticket#TOKEN
       * We need to extract just the TOKEN part for validation
       */
      function extractTokenFromQR(qrContent) {
        try {
          // Check if it's a my-ticket URL with hash
          if (qrContent.includes('#')) {
            const hashIndex = qrContent.indexOf('#');
            if (hashIndex >= 0) {
              const extracted = qrContent.substring(hashIndex + 1);
              console.log('Token extracted successfully from URL');
              return extracted;
            }
          }

          // If no hash, assume it's already a token
          console.log('Processing QR code content');
          return qrContent;
        } catch (error) {
          console.error('Error extracting token from QR - invalid format');
          return qrContent;
        }
      }

      // Handle successful scan with performance tracking
      async function onScanSuccess(decodedText) {
        // Safety check: ignore scans when scanner is inactive or page is hidden
        if (!isScanning || document.hidden) {
          console.log('Ignoring scan: scanner inactive or page hidden');
          return;
        }

        const scanStartTime = performance.now();

        // Prevent multiple scans
        isScanning = false;

        // Visual feedback: Show green border (QR locked on)
        const scanRegion = document.querySelector('.scan-region');
        if (scanRegion) {
          scanRegion.classList.remove('scanning');
          scanRegion.classList.add('locked');
        }

        // Update scan count for performance monitoring
        performanceMonitor.scanCount++;

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(200);
        }

        // Validate QR code with performance tracking
        try {
          await validateTicket(extractTokenFromQR(decodedText));
          measureScanPerformance('scan_success', scanStartTime);
        } catch (error) {
          performanceMonitor.errorCounts.validation++;
          console.error('Validation error:', error);
        }

        // Resume scanning after adaptive delay
        const resumeDelay = performanceMonitor.isLowPowerMode ? 3000 : 2000;
        setTimeout(() => {
          isScanning = true;

          // Visual feedback: Return to red border (scanning state)
          if (scanRegion) {
            scanRegion.classList.remove('locked');
            scanRegion.classList.add('scanning');
          }
        }, resumeDelay);
      }

      // Handle scan errors (ignore)
      function onScanError(error) {
        // Ignore scan errors
      }

      // CSRF Token Cache (5-minute TTL)
      let cachedCSRFToken = null;
      let csrfTokenExpiry = 0;

      async function getCSRFToken() {
        // Return cached token if still valid
        if (cachedCSRFToken && Date.now() < csrfTokenExpiry) {
          console.log('Using cached CSRF token');
          return cachedCSRFToken;
        }

        // Fetch new token
        try {
          const response = await fetch("/api/admin/csrf-token", {
            credentials: "include"
          });

          if (response.ok) {
            const data = await response.json();

            // Cache for 5 minutes
            cachedCSRFToken = data.token;
            csrfTokenExpiry = Date.now() + (5 * 60 * 1000);

            console.log('CSRF token fetched and cached');
            return cachedCSRFToken;
          }
        } catch (error) {
          console.log("Failed to fetch CSRF token:", error);
        }

        return null;
      }

      // Validate ticket (QR code or JWT wallet token) with caching
      async function validateTicket(token) {
        const validationStartTime = performance.now();

        try {
          // Check cache first for performance
          const cachedResult = getCachedValidationResult(token);
          if (cachedResult) {
            console.log('Using cached validation result');
            showResult(cachedResult.status, cachedResult.title, cachedResult.message);
            measureScanPerformance('validation_cached', validationStartTime);
            return;
          }

          // Detect wallet tokens (JWT format)
          const isWalletToken = token.includes(".") && token.length > 100;

          // Scanner is event-agnostic - no event filtering
          // Get CSRF token for admin operations (cached for 5 minutes)
          let headers = { "Content-Type": "application/json" };
          const csrfToken = await getCSRFToken();
          if (csrfToken) {
            headers["X-CSRF-Token"] = csrfToken;
          }

          const response = await fetch("/api/tickets/validate", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({
              token: token,
              validatedBy: "admin-scanner",
              location: "entrance",
              wallet_source: isWalletToken ? "jwt" : null,
              qr_access_method: isWalletToken ? "wallet" : "qr_code"
              // No event_id - scanner is event-agnostic
            }),
            credentials: "include"
          });

          // Check for rate limiting (429) before parsing JSON
          if (response.status === 429) {
            console.warn('[RATE-LIMIT] 429 response received - too many validation requests');
            const retryAfter = response.headers.get('Retry-After');
            const waitTime = retryAfter ? parseInt(retryAfter) : 60; // Default to 60 seconds if not specified

            stats.failed++;
            stats.sessionRateLimitedIncrement++;
            stats.session++;
            stats.todayIncrement++;
            updateStats();

            showResult(
              "error",
              "‚è±Ô∏è Rate Limit Reached",
              `Too many scans in a short time.\n\nPlease wait ${waitTime} seconds before scanning again.\n\nThis helps prevent system overload.`,
            );

            console.log('[RATE-LIMIT] User notified of rate limit', {
              retryAfter: waitTime,
              failed: stats.failed
            });

            return;
          }

          // Check for scan limit exceeded (410) before parsing JSON
          if (response.status === 410) {
            const data = await response.json();
            console.warn('[SCAN-LIMIT] 410 response received - scan limit exceeded');

            stats.failed++;
            stats.sessionAlreadyScannedIncrement++;  // Count scan-limit failures separately
            stats.session++;
            stats.todayIncrement++;
            updateStats();

            showResult(
              "error",
              "Scan Limit Exceeded",
              data.error || "This ticket has reached its maximum scan limit",
            );

            return;
          }

          const data = await response.json();

          if (data.offline) {
            // Offline check-in
            stats.queued++;
            showResult(
              "queued",
              "Queued for Sync",
              `Check-in saved offline (${stats.queued} in queue)`,
            );
          } else if (data.valid) {
            // Success - categorize based on scan type
            stats.session++;
            stats.todayIncrement++;  // Increment session overlay, not baseline

            // All successful scans (first or rescan) count as valid
            // Backend returns scanType for informational purposes only
            stats.sessionValidIncrement++;

            // Store scan log ID for session tracking
            if (data.scanLogId !== null && data.scanLogId !== undefined) {
              // Enforce maximum session scan log IDs to prevent localStorage overflow
              if (sessionScanLogIds.length >= MAX_SESSION_SCAN_LOGS) {
                sessionScanLogIds.shift(); // Remove oldest entry
                console.warn(`Session scan logs limit reached (${MAX_SESSION_SCAN_LOGS}), removing oldest entry`);
              }
              sessionScanLogIds.push(data.scanLogId);
              console.log(`Stored scan log ID: ${data.scanLogId} (total: ${sessionScanLogIds.length})`);
            }

            // Increment wallet-specific counters
            if (data.ticket && data.ticket.wallet_source) {
              if (data.ticket.wallet_source === 'apple_wallet') {
                stats.appleWalletIncrement++;
              } else if (data.ticket.wallet_source === 'google_wallet' || data.ticket.wallet_source === 'samsung_wallet') {
                stats.googleWalletIncrement++;
              }
            }

            // Detect if this is a test ticket
            const isTestTicket = data.ticket && (
              data.ticket.is_test === true ||
              data.ticket.ticket_id?.startsWith('TEST-') ||
              data.ticket.attendeeName?.includes('Test') ||
              data.ticket.type?.includes('test')
            );

            // Show wallet badge if from wallet
            const walletBadge =
              data.ticket && data.ticket.wallet_source ? "üì± " : "üé´ ";
            const accessMethod =
              data.ticket && data.ticket.qr_access_method === "wallet"
                ? " (Wallet)"
                : "";

            if (data.ticket) {
              const resultTitle = isTestTicket ?
                `üß™ ${walletBadge}Valid Test Ticket!` :
                `${walletBadge}Valid Ticket!`;

              // Read scan counts from validation object
              const scanCount = data.validation?.scan_count ?? 0;
              const maxScans = data.validation?.max_scan_count ?? 0;

              showResult(
                "success",
                resultTitle,
                `${data.ticket.attendee}\n${data.ticket.type}${accessMethod}\nScan ${scanCount}/${maxScans}`,
                isTestTicket,
                data.ticket.ticket_id,
                data.ticket.wallet_source
              );
            } else {
              // Fallback: extract ticket info from top-level response fields
              const ticketId = data.ticketId || data.ticket?.id || extractTokenFromQR(decodedText) || "Unknown";
              const walletSource = data.wallet_source || data.ticket?.wallet_source || null;
              showResult("success", "Valid Ticket!", "Check-in successful", false, ticketId, walletSource);
            }
          } else {
            // Invalid ticket
            stats.invalid++;
            stats.sessionFailedIncrement++;
            stats.session++;
            stats.todayIncrement++;
            showResult(
              "error",
              "Invalid Ticket",
              data.error || "This ticket cannot be validated",
            );
          }

          // Track validation time
          const validationTime = performance.now() - validationStartTime;
          stats.validationTimes.push(validationTime);
          // Keep only last 100 validation times to avoid memory bloat
          if (stats.validationTimes.length > 100) {
            stats.validationTimes.shift();
          }

          // Update stats AFTER validation time is recorded
          // This ensures average time includes the current scan
          updateStats();

          // Measure successful validation performance
          measureScanPerformance('validation_network', validationStartTime);

        } catch (error) {
          console.error("Validation error:", error);
          performanceMonitor.errorCounts.network++;

          // Track failed validation (network/system error)
          stats.failed++;
          stats.sessionFailedIncrement++;
          stats.session++;
          stats.todayIncrement++;

          // Queue for offline sync
          stats.queued++;
          updateStats();
          const result = {
            status: "queued",
            title: "Queued for Sync",
            message: "No connection - check-in saved"
          };
          showResult(result.status, result.title, result.message);

          // Cache the offline result briefly to prevent immediate retries
          setCachedValidationResult(token, result);

          // Measure error performance
          measureScanPerformance('validation_error', validationStartTime);
        }
      }

      // Show validating screen (optimistic UI - instant feedback)
      function showValidatingScreen(token) {
        const modal = document.getElementById("resultModal");
        const content = document.getElementById("resultContent");
        const icon = document.getElementById("resultIcon");
        const titleEl = document.getElementById("resultTitle");
        const detailsEl = document.getElementById("resultDetails");

        // White screen with validating message
        content.className = "result-content validating";
        icon.textContent = "‚è≥";
        titleEl.textContent = "VALIDATING";

        // Show ticket ID from QR code
        const displayToken = token.length > 20 ? token.substring(0, 20) + '...' : token;
        detailsEl.textContent = `Ticket ID: ${displayToken}\n\nVerifying ticket...`;

        // Show modal immediately
        modal.classList.add("show");
      }

      // Show result modal
      function showResult(type, title, details, isTestTicket = false, ticketId = null, walletSource = null) {
        const modal = document.getElementById("resultModal");
        const content = document.getElementById("resultContent");
        const icon = document.getElementById("resultIcon");
        const titleEl = document.getElementById("resultTitle");
        const detailsEl = document.getElementById("resultDetails");

        // Detect if this is a test ticket from details or title
        const isTestScan = isTestTicket || title.includes('TEST') || details.includes('TEST-') || details.includes('üß™');

        // Set content with test mode awareness
        if (type === "success") {
          content.className = `result-content success ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "üß™" : "‚úÖ";
          content.setAttribute("data-testid", "checkin-success");

          // Multi-modal feedback for successful scan
          if (navigator.vibrate) {
            navigator.vibrate(200); // Short success buzz
          }
          audioFeedback.playSuccess(); // Pleasant ascending tone
        } else if (type === "error") {
          content.className = `result-content error ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "üß™‚ùå" : "‚ùå";
          content.setAttribute("data-testid", "validation-error");

          // Multi-modal feedback for error
          if (navigator.vibrate) {
            navigator.vibrate([100, 50, 100]); // Double buzz pattern
          }
          audioFeedback.playError(); // Error tone
        } else if (type === "queued") {
          content.className = `result-content ${isTestScan ? 'test-scan-result' : ''}`;
          icon.textContent = isTestScan ? "üß™üì•" : "üì•";
          content.setAttribute("data-testid", "network-error");

          // Feedback for queued (network issue)
          if (navigator.vibrate) {
            navigator.vibrate([100, 50, 100]); // Same as error
          }
          audioFeedback.playError(); // Error tone (network issue)
        }

        // Update title and details with test mode indicators
        titleEl.textContent = isTestScan && !title.includes('üß™') ? `üß™ ${title}` : title;

        // For success scans, enhance display with prominent attendee name
        if (type === 'success' && details.includes('\n')) {
          const lines = details.split('\n');
          const attendeeName = lines[0];
          const otherDetails = lines.slice(1).join('\n');

          // XSS Fix: Escape user-provided data before injecting into innerHTML
          detailsEl.innerHTML = `
            <div style="font-size: var(--font-size-xl); font-weight: 700; margin-bottom: var(--space-sm); font-family: var(--font-display);">
              ${escapeHtml(attendeeName)}
            </div>
            <div style="opacity: 0.85;">
              ${escapeHtml(otherDetails)}
            </div>
          `;
        } else {
          detailsEl.textContent = details;
        }

        // Add to activity feed
        addToActivityFeed({
          type: type,
          title: title,
          details: details,
          isTestTicket: isTestScan,
          ticketId: ticketId,
          walletSource: walletSource
        });

        // Show modal
        modal.classList.add("show");

        // Start 10-second countdown
        startCountdown();
      }

      // Close result modal
      function closeResult() {
        // Clear countdown timers
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        if (countdownTimeout) {
          clearTimeout(countdownTimeout);
          countdownTimeout = null;
        }

        // Hide countdown element
        const countdownTimer = document.getElementById("countdownTimer");
        if (countdownTimer) {
          countdownTimer.style.display = "none";
        }

        document.getElementById("resultModal").classList.remove("show");

        // Resume visual scanning state (scanner never stopped)
        if (fullscreenScanner && document.getElementById('fullscreenScannerModal').classList.contains('active')) {
          const scanRegion = document.getElementById('fullscreenScanRegion');
          if (scanRegion) {
            scanRegion.classList.remove('locked');
            scanRegion.classList.add('scanning');
          }
          // Ensure scanning flag is set (should already be true)
          isFullscreenScanning = true;
        }
      }

      // Start countdown for result modal auto-close
      function startCountdown() {
        // Clear any existing countdown
        if (countdownInterval) {
          clearInterval(countdownInterval);
        }
        if (countdownTimeout) {
          clearTimeout(countdownTimeout);
        }

        // Reset countdown (12 seconds to display result)
        countdownSeconds = 12;
        const countdownSecondsEl = document.getElementById("countdownSeconds");
        const countdownTimer = document.getElementById("countdownTimer");

        if (countdownSecondsEl && countdownTimer) {
          countdownSecondsEl.textContent = countdownSeconds;
          countdownTimer.style.display = "block";

          // Start countdown interval
          countdownInterval = setInterval(() => {
            countdownSeconds--;
            countdownSecondsEl.textContent = countdownSeconds;

            if (countdownSeconds <= 0) {
              clearInterval(countdownInterval);
              countdownInterval = null;
              closeResult();
            }
          }, 1000);

          // Backup timeout in case interval fails
          countdownTimeout = setTimeout(() => {
            if (countdownInterval) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
            closeResult();
          }, 12000);
        }
      }

      // Full-Screen Scanner Functions
      let fullscreenScanner = null;
      let isFullscreenScanning = false;

      async function openFullscreenScanner() {
        // If the inline scanner is running, stop it to release camera
        // This prevents NotReadableError ("device already in use") on mobile devices
        if (isScanning && scanner) {
          await stopScanner();
        }

        const modal = document.getElementById('fullscreenScannerModal');
        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Show modal
        modal.classList.add('active');

        // Initialize scanner
        try {
          fullscreenScanner = new Html5Qrcode("fullscreenReader");

          const config = getFullscreenScannerConfig();

          await fullscreenScanner.start(
            { facingMode: "environment" },
            config,
            onFullscreenScanSuccess,
            onFullscreenScanFailure
          );

          isFullscreenScanning = true;
          scanRegion.classList.add('scanning');
          console.log('Full-screen scanner started successfully');

        } catch (error) {
          console.error('Failed to start full-screen scanner:', error);
          alert('Failed to access camera. Please check permissions and try again.');
          closeFullscreenScanner();
        }
      }

      async function closeFullscreenScanner() {
        const modal = document.getElementById('fullscreenScannerModal');
        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Stop scanner
        if (fullscreenScanner) {
          try {
            await fullscreenScanner.stop();
            fullscreenScanner.clear();
          } catch (error) {
            console.log('Error stopping scanner:', error);
          }
          fullscreenScanner = null;
        }

        isFullscreenScanning = false;
        scanRegion.classList.remove('scanning', 'locked');
        modal.classList.remove('active');

        // After closing fullscreen, restart the inline scanner if it was running
        if (!isScanning && scanner) {
          try {
            await initScanner();
          } catch (error) {
            console.log('Error restarting inline scanner:', error);
          }
        }
      }

      async function onFullscreenScanSuccess(decodedText) {
        if (!isFullscreenScanning) return;

        // PAUSE scanner to prevent duplicate scans during result display
        // This prevents hitting scan limits by rescanning the same QR code
        isFullscreenScanning = false;

        const scanRegion = document.getElementById('fullscreenScanRegion');

        // Visual feedback: green border (locked on QR)
        scanRegion.classList.remove('scanning');
        scanRegion.classList.add('locked');

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(200);
        }

        // Extract token from QR code
        const token = extractTokenFromQR(decodedText);

        // OPTIMISTIC UI: Show white validating screen IMMEDIATELY
        showValidatingScreen(token);

        // Validate ticket in background - result will update the screen
        try {
          await validateTicket(token);
          // Scanner paused, will resume when result dismisses after 12 seconds

        } catch (error) {
          console.error('Validation error:', error);

          // Show error result
          showResult("error", "Validation Failed", error.message);

          // Resume scanning after error (2 second delay)
          setTimeout(() => {
            isFullscreenScanning = true;
            scanRegion.classList.remove('locked');
            scanRegion.classList.add('scanning');
          }, 2000);
        }
      }

      function onFullscreenScanFailure(error) {
        // Silently handle scan failures (normal during scanning)
        // Only log if it's an actual error, not just "No QR code found"
        if (error && !error.includes && !error.toString().includes('NotFoundException')) {
          console.log('Scan error:', error);
        }
      }

      // Show manual input with backdrop
      function showManualInput() {
        document.getElementById("manualBackdrop").classList.add("show");
        document.getElementById("manualInput").classList.add("show");
        document.getElementById("manualTicketId").focus();
      }

      // Hide manual input and backdrop
      function hideManualInput() {
        document.getElementById("manualBackdrop").classList.remove("show");
        document.getElementById("manualInput").classList.remove("show");
        document.getElementById("manualTicketId").value = "";
      }

      // Clear session data - reset session scan logs and counters
      function clearSessionData() {
        const confirmed = confirm(
          'Clear Session Data?\n\n' +
          'This will:\n' +
          '‚Ä¢ Reset session scan count to 0\n' +
          '‚Ä¢ Clear session scan log history\n' +
          '‚Ä¢ Reset session-specific counters\n\n' +
          'Database records and today\'s total count will NOT be affected.\n\n' +
          'Continue?'
        );

        if (!confirmed) {
          return;
        }

        try {
          // Clear sessionScanLogIds array
          sessionScanLogIds.length = 0;
          console.log('[SESSION-CLEAR] Cleared sessionScanLogIds array');

          // Clear localStorage
          localStorage.removeItem(STATS_STORAGE_KEY);
          localStorage.removeItem(SESSION_SCAN_LOG_IDS_KEY);
          console.log('[SESSION-CLEAR] Cleared localStorage session data');

          // Reset session counters (keep baseline values from server)
          stats.session = 0;
          stats.todayIncrement = 0;
          stats.appleWalletIncrement = 0;
          stats.googleWalletIncrement = 0;
          stats.queued = 0;
          stats.failed = 0;
          stats.invalid = 0;
          stats.validationTimes = [];

          // Reset new session category increments
          stats.sessionValidIncrement = 0;
          stats.sessionFailedIncrement = 0;
          stats.sessionRateLimitedIncrement = 0;
          stats.sessionAlreadyScannedIncrement = 0;

          stats.sessionStart = Date.now();
          stats.lastActivity = Date.now();
          console.log('[SESSION-CLEAR] Reset session counters');

          // Update UI
          updateStats();
          console.log('[SESSION-CLEAR] Updated UI');

          // Show success message
          alert('‚úÖ Session data cleared successfully!\n\nSession count reset to 0.');

          console.log('[SESSION-CLEAR] Session data cleared successfully', {
            sessionScanLogIds: sessionScanLogIds.length,
            sessionCount: stats.session,
            todayIncrement: stats.todayIncrement
          });
        } catch (error) {
          console.error('[SESSION-CLEAR] Failed to clear session data:', error);
          alert('‚ùå Failed to clear session data.\n\nPlease try refreshing the page.');
        }
      }

      // Enhanced keyboard navigation and accessibility
      document.addEventListener('keydown', (e) => {
        // Escape key handling
        if (e.key === 'Escape') {
          if (document.getElementById("permissionModal").classList.contains("show")) {
            e.preventDefault();
            useManualMode(); // Escape from permission modal goes to manual mode
          } else if (document.getElementById("manualInput").classList.contains("show")) {
            e.preventDefault();
            hideManualInput();
          } else if (uiState.isError) {
            e.preventDefault();
            hideErrorState();
          }
        }

        // Enter key handling for permission modal
        if (e.key === 'Enter' && document.getElementById("permissionModal").classList.contains("show")) {
          e.preventDefault();
          handlePermissionRequest();
        }

        // Tab navigation for error state
        if (e.key === 'Tab' && uiState.isError) {
          const errorEl = document.getElementById('scannerError');
          const focusableElements = errorEl.querySelectorAll('button:not([style*="display: none"])');
          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }

        // Spacebar for retry (accessibility)
        if (e.key === ' ' && uiState.isError && document.activeElement.id === 'retryCamera') {
          e.preventDefault();
          retryScanner();
        }
      });

      // Add ARIA live region for screen readers
      const ariaLiveRegion = document.createElement('div');
      ariaLiveRegion.setAttribute('aria-live', 'polite');
      ariaLiveRegion.setAttribute('aria-atomic', 'true');
      ariaLiveRegion.style.position = 'absolute';
      ariaLiveRegion.style.left = '-10000px';
      ariaLiveRegion.style.width = '1px';
      ariaLiveRegion.style.height = '1px';
      ariaLiveRegion.style.overflow = 'hidden';
      document.body.appendChild(ariaLiveRegion);

      // Announce state changes to screen readers
      function announceToScreenReader(message) {
        ariaLiveRegion.textContent = message;
        // Clear after a delay to allow for re-announcement of the same message
        setTimeout(() => {
          ariaLiveRegion.textContent = '';
        }, 1000);
      }

      // Submit manual ticket
      async function submitManualTicket() {
        const ticketId = document.getElementById("manualTicketId").value.trim();

        if (!ticketId) {
          alert("Please enter a ticket ID");
          return;
        }

        hideManualInput();

        // For manual entry, we need to look up the ticket first
        try {
          // Scanner is event-agnostic - no event filtering
          const response = await fetch(
            `/api/tickets?ticket_id=${encodeURIComponent(ticketId)}`,
            {
              credentials: "include"
            }
          );
          const data = await response.json();

          if (data.ticket && data.ticket.qr_token) {
            await validateTicket(data.ticket.qr_token);
          } else {
            showResult("error", "Not Found", "Ticket ID not found");
          }
        } catch (error) {
          showResult("error", "Error", "Failed to lookup ticket");
        }
      }

      // Update statistics display
      function updateStats() {
        // Calculate values
        const todayCount = (stats.todayBaseline || 0) + (stats.todayIncrement || 0);
        const sessionCount = stats.session;
        const totalCount = stats.totalBaseline + stats.session;

        // FIX: Include session increments for accurate real-time display
        const validCount = (stats.validBaseline || 0) + (stats.sessionValidIncrement || 0);
        const failedCount = (stats.failedBaseline || 0) + (stats.sessionFailedIncrement || 0);
        const rateLimitedCount = (stats.rateLimitedBaseline || 0) + (stats.sessionRateLimitedIncrement || 0);
        const alreadyScannedCount = (stats.alreadyScannedBaseline || 0) + (stats.sessionAlreadyScannedIncrement || 0);

        // Calculate average time
        let avgTime = "0ms";
        let avgTimeMilliseconds = 0;
        if (stats.validationTimes && stats.validationTimes.length > 0) {
          const sum = stats.validationTimes.reduce((a, b) => a + b, 0);
          avgTimeMilliseconds = Math.round(sum / stats.validationTimes.length);
          avgTime = `${avgTimeMilliseconds}ms`;
        }

        // Update text content
        document.getElementById("statToday").textContent = todayCount;
        document.getElementById("statSession").textContent = sessionCount;
        document.getElementById("statTotal").textContent = totalCount;
        document.getElementById("statValid").textContent = validCount;
        document.getElementById("statFailed").textContent = failedCount;
        document.getElementById("statRateLimited").textContent = rateLimitedCount;
        document.getElementById("statAlreadyScanned").textContent = alreadyScannedCount;
        document.getElementById("statAvgTime").textContent = avgTime;

        // Update ARIA labels for accessibility
        const sessionStat = document.querySelector('[onclick="viewStatTickets(\'session\')"]');
        const todayStat = document.querySelector('[onclick="viewStatTickets(\'today\')"]');
        const totalStat = document.querySelector('[onclick="viewStatTickets(\'total\')"]');
        const validStat = document.querySelector('[onclick="viewStatTickets(\'valid\')"]');
        const failedStat = document.querySelector('[onclick="viewStatTickets(\'failed\')"]');
        const rateLimitedStat = document.querySelector('[onclick="viewStatTickets(\'rateLimited\')"]');
        const alreadyScannedStat = document.querySelector('[onclick="viewStatTickets(\'alreadyScanned\')"]');
        const avgTimeStat = document.querySelector('.stat-item[role="status"]');

        if (sessionStat) sessionStat.setAttribute('aria-label', `Session check-ins: ${sessionCount}. Click to view details`);
        if (todayStat) todayStat.setAttribute('aria-label', `Today's check-ins: ${todayCount}. Click to view details`);
        if (totalStat) totalStat.setAttribute('aria-label', `Total check-ins: ${totalCount}. Click to view details`);
        if (validStat) validStat.setAttribute('aria-label', `Valid scans: ${validCount}. Click to view details`);
        if (failedStat) failedStat.setAttribute('aria-label', `Failed scans: ${failedCount}. Click to view details`);
        if (rateLimitedStat) rateLimitedStat.setAttribute('aria-label', `Rate limited scans: ${rateLimitedCount}. Click to view details`);
        if (alreadyScannedStat) alreadyScannedStat.setAttribute('aria-label', `Re-scanned tickets: ${alreadyScannedCount}. Click to view details`);
        if (avgTimeStat) avgTimeStat.setAttribute('aria-label', `Average validation time: ${avgTimeMilliseconds} milliseconds`);

        // Persist to localStorage
        persistSessionStats();
      }

      // Open overlay modal with filtered checked-in tickets
      async function viewStatTickets(statType, page = 1) {
        const overlay = document.getElementById('ticketsOverlay');
        const titleEl = document.getElementById('ticketsOverlayTitle');
        const loadingEl = document.getElementById('ticketsLoading');
        const errorEl = document.getElementById('ticketsError');
        const tableContainer = document.getElementById('ticketsTableContainer');
        const emptyEl = document.getElementById('ticketsEmpty');
        const tableBody = document.getElementById('ticketsTableBody');
        const paginationEl = document.getElementById('ticketsPagination');

        // Update pagination state
        currentFilter = statType;
        currentPage = page;

        // Set title based on filter
        const titles = {
          'today': "Today's Check-Ins",
          'session': "Session Check-Ins",
          'total': "All Checked-In Tickets",
          'valid': "Valid Scans",
          'failed': "Failed Scans",
          'rateLimited': "Rate Limited Scans",
          'alreadyScanned': "Re-scanned Tickets"
        };
        titleEl.textContent = titles[statType] || "Checked-In Tickets";

        // Update active state for stat cards
        document.querySelectorAll('.stat-item-clickable').forEach(item => {
          item.classList.remove('active');
        });
        const activeCard = document.querySelector(`.stat-item-clickable[onclick*="${statType}"]`);
        if (activeCard) {
          activeCard.classList.add('active');
        }

        // Show overlay with loading state
        overlay.classList.add('show');
        loadingEl.style.display = 'flex';
        errorEl.style.display = 'none';
        tableContainer.style.display = 'none';
        emptyEl.style.display = 'none';

        // For session filter, query database using scan log IDs
        if (statType === 'session') {
          // Check if we have any scan log IDs
          if (sessionScanLogIds.length === 0) {
            loadingEl.style.display = 'none';
            const emptyParagraph = emptyEl.querySelector('p');
            if (emptyParagraph) {
              emptyParagraph.textContent = "No tickets scanned in this session yet.";
            }
            emptyEl.style.display = 'block';
            paginationEl.style.display = 'none';
            return;
          }

          try {
            // Query database with scan log IDs
            const params = new URLSearchParams();
            params.set('filter', 'session');
            params.set('scanLogIds', sessionScanLogIds.join(','));
            params.set('page', page);
            params.set('limit', 50);

            console.log(`[DEBUG] Querying session scans with ${sessionScanLogIds.length} scan log IDs (page ${page})`);

            const response = await fetch(`/api/admin/checked-in-tickets?${params}`, {
              credentials: 'include'
            });

            if (!response.ok) {
              throw new Error(`Failed to fetch session tickets: ${response.status}`);
            }

            const data = await response.json();
            loadingEl.style.display = 'none';

            if (!data.tickets || data.tickets.length === 0) {
              const emptyParagraph = emptyEl.querySelector('p');
              if (emptyParagraph) {
                emptyParagraph.textContent = "No session tickets found in database.";
              }
              emptyEl.style.display = 'block';
              paginationEl.style.display = 'none';
              return;
            }

            // Render tickets in 4-column format
            tableBody.innerHTML = data.tickets.map(ticket => {
              const scanTime = ticket.scan_time_mt ||
                (timeManager ? timeManager.formatDateTime(ticket.scan_time) : ticket.scan_time);

              return `
                <tr>
                  <td>
                    <a href="/admin/ticket-detail.html?ticketId=${escapeHtml(ticket.ticket_id)}"
                       style="color: #007bff; text-decoration: underline; cursor: pointer;">
                      ${escapeHtml(ticket.ticket_id)}
                    </a>
                  </td>
                  <td>${escapeHtml(ticket.first_name) || 'N/A'}</td>
                  <td>${escapeHtml(ticket.last_name) || 'N/A'}</td>
                  <td>${escapeHtml(scanTime)}</td>
                </tr>
              `;
            }).join('');

            tableContainer.style.display = 'block';
            
            // Update pagination controls for session filter
            if (data.pagination) {
              const prevBtn = document.getElementById('prevPageBtn');
              const nextBtn = document.getElementById('nextPageBtn');
              const paginationInfo = document.getElementById('paginationInfo');

              // Defensive checks for pagination API response structure
              const pagination = data.pagination || {};
              const currentPageNum = pagination.page ?? page ?? 1;
              const totalPages = pagination.totalPages ?? pagination.total_pages ?? 1;
              const totalCount = pagination.totalCount ?? pagination.total_count ?? data.tickets.length;
              const hasPrev = pagination.hasPrev ?? pagination.has_prev ?? (currentPageNum > 1);
              const hasNext = pagination.hasNext ?? pagination.has_next ?? false;

              // Update pagination info text
              paginationInfo.textContent = `Page ${currentPageNum} of ${totalPages} (${totalCount} total)`;

              // Update button states
              prevBtn.disabled = !hasPrev;
              nextBtn.disabled = !hasNext;

              // Show pagination controls
              paginationEl.style.display = 'flex';
            } else {
              paginationEl.style.display = 'none';
            }
            
            return;
          } catch (error) {
            console.error('Failed to load session tickets:', error);
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            const errorMessage = errorEl.querySelector('.error-message');
            if (errorMessage) {
              errorMessage.textContent = 'Failed to load session tickets. Please try again.';
            }
            return;
          }
        }

        try {
          // Scanner is event-agnostic - no event filtering
          // Build query params
          const params = new URLSearchParams();
          params.set('filter', statType);
          params.set('page', page);
          params.set('limit', 50);

          // Debug logging
          console.log('[DEBUG] Fetching checked-in tickets:', {
            statType,
            page,
            url: `/api/admin/checked-in-tickets?${params.toString()}`
          });

          // Fetch tickets from API
          const response = await fetch(`/api/admin/checked-in-tickets?${params}`, {
            credentials: 'include'
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch tickets: ${response.status}`);
          }

          const data = await response.json();

          // Debug logging for response
          console.log('[DEBUG] Checked-in tickets API response:', {
            filter: statType,
            ticketCount: data.tickets?.length || 0,
            totalCount: data.pagination?.total_count || 0,
            hasTickets: !!data.tickets,
            isArray: Array.isArray(data.tickets),
            responseKeys: Object.keys(data)
          });

          loadingEl.style.display = 'none';

          // Merge database tickets with session scans for 'today' and 'total' filters
          // CRITICAL: Only merge session scans on page 1 to prevent pagination breaks
          // - Merging on all pages would cause duplicates (same scan shown on multiple pages)
          // - Session scans are already counted in stat cards (via sessionScanIds)
          // - Backend API now properly paginates session filter, so duplicates are prevented
          // - This merge only adds session scans not yet in the database to page 1
          let allTickets = data.tickets || [];
          const dbTicketCount = allTickets.length; // Track original DB ticket count before merging

          if ((statType === 'today' || statType === 'total') && page === 1) {
            // Get session scans that should be included
            const sessionScans = recentScans
              .filter(scan => scan.type === 'success' && scan.ticketId && scan.ticketId !== '‚Äî')
              .map(scan => {
                const detailsLines = scan.details.split('\n');
                const fullName = detailsLines[0] || '';
                const [firstName, ...lastNameParts] = fullName.split(' ');
                const lastName = lastNameParts.join(' ');

                return {
                  ticket_id: scan.ticketId,
                  first_name: firstName || '‚Äî',
                  last_name: lastName || '‚Äî',
                  wallet_source: scan.walletSource,
                  scan_time: scan.timestamp,
                  scan_time_mt: timeManager ? timeManager.formatDateTime(new Date(scan.timestamp)) : new Date(scan.timestamp).toLocaleString(),
                  fromSession: true // Flag to identify session scans
                };
              });

            // Create a Set of ticket IDs already in database results to avoid duplicates
            const dbTicketIds = new Set(allTickets.map(t => String(t.ticket_id)));

            // Add session scans that aren't already in database results
            sessionScans.forEach(sessionTicket => {
              if (!dbTicketIds.has(String(sessionTicket.ticket_id))) {
                allTickets.push(sessionTicket);
              }
            });

            console.log('[DEBUG] Merged tickets with session scans (page 1 only):', {
              page: page,
              dbTickets: data.tickets?.length || 0,
              sessionScans: sessionScans.length,
              merged: allTickets.length,
              addedScans: allTickets.length - dbTicketCount
            });
          }

          // Calculate how many session scans were actually added (for pagination adjustment)
          const addedSessionScans = allTickets.length - dbTicketCount;

          if (allTickets.length === 0) {
            // Update empty state message based on filter type
            const emptyMessages = {
              'today': "No tickets scanned today.",
              'apple_wallet': "No tickets scanned from Apple Wallet yet.",
              'google_wallet': "No tickets scanned from Google Wallet yet.",
              'wallet': "No tickets scanned from any wallet yet.",
              'total': "No tickets have been scanned yet."
            };
            const emptyParagraph = emptyEl.querySelector('p');
            if (emptyParagraph) {
              emptyParagraph.textContent = emptyMessages[statType] || "No tickets found for this filter.";
            }
            emptyEl.style.display = 'block';
            paginationEl.style.display = 'none';
            return;
          }

          // Render tickets table
          tableBody.innerHTML = allTickets.map(ticket => {
            const scanTime = ticket.scan_time_mt ||
              (timeManager ? timeManager.formatDateTime(ticket.scan_time) : ticket.scan_time);

            // XSS Fix: Escape all API data before rendering
            return `
              <tr>
                <td>
                  <a href="/admin/ticket-detail.html?ticketId=${escapeHtml(ticket.ticket_id)}"
                     style="color: #007bff; text-decoration: underline; cursor: pointer;">
                    ${escapeHtml(ticket.ticket_id)}
                  </a>
                </td>
                <td>${escapeHtml(ticket.first_name) || 'N/A'}</td>
                <td>${escapeHtml(ticket.last_name) || 'N/A'}</td>
                <td>${escapeHtml(scanTime)}</td>
              </tr>
            `;
          }).join('');

          tableContainer.style.display = 'block';

          // Update pagination controls
          if (data.pagination) {
            // Use camelCase field names from API
            totalPages = data.pagination.totalPages;
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const paginationInfo = document.getElementById('paginationInfo');

            // Defensive checks for pagination API response structure
            const pagination = data.pagination || {};
            const currentPageNum = pagination.page ?? page ?? 1;
            totalPages = pagination.totalPages ?? pagination.total_pages ?? 1;
            let totalCount = pagination.totalCount ?? pagination.total_count ?? allTickets.length;

            // CRITICAL: Adjust total count if session scans were added on page 1
            // Backend's total_count only includes database tickets, but we display database + session scans
            if ((statType === 'today' || statType === 'total') && page === 1 && addedSessionScans > 0) {
              totalCount += addedSessionScans;
              console.log('[DEBUG] Adjusted pagination total count:', {
                backendTotal: pagination.totalCount ?? pagination.total_count,
                addedScans: addedSessionScans,
                adjustedTotal: totalCount
              });
            }
            const hasPrev = pagination.hasPrev ?? pagination.has_prev ?? (currentPageNum > 1);
            const hasNext = pagination.hasNext ?? pagination.has_next ?? false;

            // Update pagination info text
            paginationInfo.textContent = `Page ${currentPageNum} of ${totalPages} (${totalCount} total)`;

            // Update button states
            prevBtn.disabled = !hasPrev;
            nextBtn.disabled = !hasNext;

            // Show pagination controls
            paginationEl.style.display = 'flex';
          } else {
            paginationEl.style.display = 'none';
          }
        } catch (error) {
          console.error('Failed to load tickets:', error);
          loadingEl.style.display = 'none';
          errorEl.textContent = 'Failed to load tickets. Please try again.';
          errorEl.style.display = 'block';
        }
      }

      function closeTicketsOverlay() {
        document.getElementById('ticketsOverlay').classList.remove('show');
      }

      function previousPage() {
        if (currentPage > 1) {
          viewStatTickets(currentFilter, currentPage - 1);
        }
      }

      function nextPage() {
        if (currentPage < totalPages) {
          viewStatTickets(currentFilter, currentPage + 1);
        }
      }

      function openTicketDetail(ticketId) {
        if (!ticketId) {
          console.error('No ticket ID provided');
          return;
        }
        // Navigate to ticket detail page with ticketId query parameter
        window.location.href = `/admin/ticket-detail?ticketId=${encodeURIComponent(ticketId)}`;
      }

      // Load statistics
      async function loadStats() {
        try {
          // Scanner is event-agnostic - no event filtering
          const response = await fetch(`/api/admin/scanner-stats`, {
            credentials: "include"
          });
          const data = await response.json();

          // Debug logging to track stats loading
          console.log('üìä Scanner Stats API Response:', {
            today: data.stats?.today,
            total: data.stats?.total,
            valid: data.stats?.valid,
            failed: data.stats?.failed,
            rateLimited: data.stats?.rateLimited,
            alreadyScanned: data.stats?.alreadyScanned,
            timestamp: new Date().toISOString()
          });

          if (data.stats) {
            // Load baselines from server, preserve session increments
            stats.todayBaseline = data.stats.today || 0;
            stats.totalBaseline = data.stats.total || 0;
            stats.validBaseline = data.stats.valid || 0;
            stats.failedBaseline = data.stats.failed || 0;
            stats.rateLimitedBaseline = data.stats.rateLimited || 0;
            stats.alreadyScannedBaseline = data.stats.alreadyScanned || 0;
            // Session increments (todayIncrement, session, etc.) are NOT reset here - they persist!

            // Note: Test mode indicators removed as scanner-stats focuses on scanned tickets only
            // If test mode tracking is needed, it should be added to scanner-stats endpoint

            // Update display (combines baselines + increments)
            updateStats();
          }
        } catch (error) {
          console.error("Failed to load stats:", error);
        }
      }

      // Update scanner test mode indicators
      function updateScannerTestModeIndicators(hasTestData) {
        const testModeIndicator = document.getElementById('scannerTestModeIndicator');
        const statsBar = document.getElementById('statsBar');

        if (hasTestData) {
          // Show test mode indicator
          testModeIndicator.style.display = 'block';
          statsBar.classList.add('scanner-test-stats');
        } else {
          // Hide test mode indicator
          testModeIndicator.style.display = 'none';
          statsBar.classList.remove('scanner-test-stats');
        }
      }

      // Check online status
      function updateOnlineStatus() {
        const indicator = document.getElementById("offlineIndicator");

        if (navigator.onLine) {
          indicator.style.display = "none";

          // Trigger sync if we have queued items
          if (stats.queued > 0 && "serviceWorker" in navigator) {
            navigator.serviceWorker.ready.then((registration) => {
              return registration.sync.register("sync-checkins");
            });
          }
        } else {
          indicator.style.display = "block";
        }
      }

      // Toggle mobile navigation menu
      function toggleMobileMenu(btnEl) {
        if (window.adminMobileNav) {
          const isOpen = window.adminMobileNav.toggleMenu();
          // Sync aria-expanded for accessibility
          if (btnEl && typeof isOpen === 'boolean') {
            btnEl.setAttribute('aria-expanded', String(isOpen));
          }
        }
      }

      // Show menu (placeholder)
      function showMenu() {
        if (confirm("Return to dashboard?")) {
          window.location.href = "/admin/dashboard";
        }
      }

      // Check authentication (mobile sessions last 72 hours)
      async function checkAuth() {
        if (window.AdminAuthGuard) {
          return await window.AdminAuthGuard.verifyAndShow();
        } else {
          console.error("AdminAuthGuard not available");
          window.location.href = "/admin/login";
          return false;
        }
      }

      // Show mobile login UI
      function showMobileLogin() {
        document.body.innerHTML = `
                <div style="
                    height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    background: linear-gradient(135deg, var(--color-blue) 0%, var(--color-red) 100%);
                ">
                    <div style="
                        background: var(--color-surface);
                        padding: 40px;
                        border-radius: 20px;
                        box-shadow: var(--shadow-xl);
                        max-width: 90%;
                        width: 350px;
                    ">
                        <h2 style="color: var(--color-text-primary); margin-bottom: 10px; text-align: center;">
                            üé´ Check-in Staff Login
                        </h2>
                        <p style="color: var(--color-text-secondary); text-align: center; margin-bottom: 30px; font-size: 14px;">
                            Session lasts 72 hours
                        </p>
                        <form id="mobileLoginForm" onsubmit="handleMobileLogin(event)">
                            <input 
                                type="password" 
                                id="staffPassword"
                                placeholder="Enter staff password"
                                required
                                style="
                                    width: 100%;
                                    padding: 15px;
                                    border: 1px solid var(--color-border);
                                    border-radius: 10px;
                                    font-size: 16px;
                                    margin-bottom: 20px;
                                    background: var(--color-background-secondary);
                                    color: var(--color-text-primary);
                                "
                            >
                            <button type="submit" style="
                                width: 100%;
                                padding: 15px;
                                background: var(--color-primary);
                                color: var(--color-text-inverse);
                                border: none;
                                border-radius: 10px;
                                font-size: 18px;
                                font-weight: 600;
                                cursor: pointer;
                            ">
                                Login to Scanner
                            </button>
                            <div id="loginError" style="
                                color: var(--color-error);
                                text-align: center;
                                margin-top: 15px;
                                display: none;
                            "></div>
                        </form>
                    </div>
                </div>
            `;

        // Focus password field
        setTimeout(() => {
          document.getElementById("staffPassword").focus();
        }, 100);
      }

      // Handle mobile login
      async function handleMobileLogin(event) {
        event.preventDefault();

        const password = document.getElementById("staffPassword").value;
        const errorDiv = document.getElementById("loginError");

        try {
          // Get CSRF token first
          const csrfResponse = await fetch("/api/admin/csrf-token", {
            credentials: "include"
          });
          const csrfData = await csrfResponse.json();

          // Attempt login with mobile mode
          const response = await fetch("/api/admin/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": csrfData.token,
            },
            body: JSON.stringify({
              username: "admin",
              password: password,
              mode: "mobile",
              csrfToken: csrfData.token,
            }),
            credentials: "include"
          });

          const data = await response.json();

          if (response.ok) {
            // Login successful, reload page
            location.reload();
          } else {
            errorDiv.textContent = data.error || "Invalid password";
            errorDiv.style.display = "block";
            document.getElementById("staffPassword").value = "";
            document.getElementById("staffPassword").focus();
          }
        } catch (error) {
          errorDiv.textContent = "Connection error. Please try again.";
          errorDiv.style.display = "block";
        }
      }

      // Initialize app
      async function init() {
        // Check authentication
        if (!(await checkAuth())) return;

        // Event selector removed from scanner page per user request
        // Can be re-enabled later by uncommenting this block
        /*
        // Wait for event selector to be available
        const waitForEventSelector = async () => {
          let attempts = 0;
          while (!window.eventSelector && attempts < 20) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
          }
          return window.eventSelector;
        };

        // Initialize event selector
        const eventSelector = await waitForEventSelector();
        if (eventSelector) {
          await eventSelector.init();
          eventSelector.render('event-selector-container');

          // Set up event change listener to reload stats
          eventSelector.onChange(() => {
            // Clear session stats when event changes
            stats.session = 0;
            updateStats();
            loadStats();
          });
        }
        */

        // Register service worker
        if ("serviceWorker" in navigator) {
          try {
            await navigator.serviceWorker.register("/js/sw.js");
            console.log("Service worker registered");
          } catch (error) {
            console.error("Service worker registration failed:", error);
          }
        }

        // Note: Inline scanner removed in commit 358a0f26 - page now uses fullscreen scanner modal only
        // Fullscreen scanner is initialized on-demand when user clicks the camera button

        // Load statistics
        await loadStats();

        // Load today's scans into recent activity feed
        await loadTodaysScans();

        // Monitor online status
        updateOnlineStatus();
        window.addEventListener("online", updateOnlineStatus);
        window.addEventListener("offline", updateOnlineStatus);

        // Refresh stats periodically
        setInterval(loadStats, 30000);
      }

      // Back to Portal function
      function backToPortal() {
        window.location.href = "/admin";
      }

      // Logout function
      async function logout() {
        if (!confirm("Are you sure you want to logout?")) return;

        try {
          const headers = {};

          // Add CSRF token for secure logout
          try {
            const csrfResponse = await fetch("/api/admin/csrf-token", {
              credentials: "same-origin"
            });
            if (csrfResponse.ok) {
              const csrfData = await csrfResponse.json();
              headers["X-CSRF-Token"] = csrfData.token || csrfData.csrfToken;
            }
          } catch (error) {
            console.warn("Could not fetch CSRF token for logout:", error);
          }

          await fetch("/api/admin/login", {
            method: "DELETE",
            headers: headers,
            credentials: "same-origin"
          });
        } finally {
          // Clear client storage
          localStorage.removeItem('adminToken');
          sessionStorage.clear();
          // Redirect
          window.location.href = '/admin/login';
        }
      }

      // Performance debugging interface (available in console)
      window.scannerPerformance = {
        getMetrics: getPerformanceMetrics,
        getDeviceScore: () => performanceMonitor.deviceScore,
        getAdaptiveSettings: () => performanceMonitor.adaptiveSettings,
        getCacheStats: () => ({
          validationCache: networkCache.validationResults.size,
          ticketCache: networkCache.ticketData.size,
          cacheHitRate: performanceMonitor.cacheHits / (performanceMonitor.cacheHits + performanceMonitor.cacheMisses),
          requestQueueLength: networkCache.requestQueue.length
        }),
        getMemoryStats: () => performanceMonitor.memoryUsage.slice(-5),
        getErrorCounts: () => performanceMonitor.errorCounts,
        getScanTimes: () => performanceMonitor.scanTimes.slice(-10),
        isLowPowerMode: () => performanceMonitor.isLowPowerMode,
        getBatteryInfo: () => performanceMonitor.batteryInfo,
        clearCache: () => {
          networkCache.validationResults.clear();
          networkCache.ticketData.clear();
          console.log('Caches cleared');
        },
        forceMemoryCleanup: () => {
          performMemoryCleanup();
          console.log('Memory cleanup forced');
        },
        enableLowPowerMode: () => {
          enableLowPowerMode();
          console.log('Low power mode enabled');
        },
        disableLowPowerMode: () => {
          disableLowPowerMode();
          console.log('Low power mode disabled');
        },
        restartScanner: () => {
          restartScannerWithNewSettings();
          console.log('Scanner restarted with new settings');
        },
        exportMetrics: () => {
          const metrics = {
            session: getPerformanceMetrics(),
            deviceInfo: deviceInfo,
            userAgent: navigator.userAgent,
            timestamp: timeManager ? timeManager.formatDateTime(new Date()) : new Date().toISOString()
          };
          console.log('Performance metrics:', JSON.stringify(metrics, null, 2));
          return metrics;
        }
      };

      // Initialize performance monitoring on load
      document.addEventListener('DOMContentLoaded', function() {
        if (performanceMonitor.deviceScore === 0) {
          initializePerformanceMonitoring();
        }
      });

      // Recent Activity Feed
      const recentScans = [];
      const MAX_RECENT_SCANS = 10;

      // Load today's scans from database on page initialization
      async function loadTodaysScans() {
        try {
          // Scanner is event-agnostic - no event filtering
          const params = new URLSearchParams({
            filter: 'today',
            limit: 50,
            page: 1
          });

          const response = await fetch(`/api/admin/checked-in-tickets?${params}`, {
            credentials: 'include'
          });

          if (!response.ok) {
            console.error('Failed to load today\'s scans');
            return;
          }

          const data = await response.json();

          // Populate recentScans with today's data (most recent first)
          if (data.tickets && Array.isArray(data.tickets)) {
            recentScans.length = 0; // Clear existing
            data.tickets.forEach(ticket => {
              recentScans.push({
                timestamp: new Date(ticket.scan_time).getTime(),
                type: 'success',
                title: `${ticket.first_name || 'Unknown'} ${ticket.last_name || ''}`.trim(),
                details: `${ticket.first_name || 'Unknown'} ${ticket.last_name || ''}\n${ticket.ticket_type}`,
                ticketId: ticket.ticket_id,
                walletSource: ticket.validation_source
              });
            });

            // Limit to MAX_RECENT_SCANS
            if (recentScans.length > MAX_RECENT_SCANS) {
              recentScans.length = MAX_RECENT_SCANS;
            }

            // Render the activity feed
            renderActivityFeed();
          }
        } catch (error) {
          console.error('Failed to load today\'s scans:', error);
        }
      }

      // Pagination state
      let currentPage = 1;
      let currentFilter = 'total';
      let totalPages = 1;

      function addToActivityFeed(scanData) {
        // Add to beginning of array
        recentScans.unshift({
          timestamp: Date.now(),
          type: scanData.type, // 'success', 'error', 'queued'
          title: scanData.title,
          details: scanData.details,
          isTestTicket: scanData.isTestTicket || false,
          ticketId: scanData.ticketId || null,
          walletSource: scanData.walletSource || null
        });

        // Keep only last 10 scans
        if (recentScans.length > MAX_RECENT_SCANS) {
          recentScans.pop();
        }

        // Re-render the feed
        renderActivityFeed();
      }

      function renderActivityFeed() {
        const feedContainer = document.getElementById('activityFeed');
        if (!feedContainer) return;

        if (recentScans.length === 0) {
          feedContainer.innerHTML = '<div class="activity-empty">Waiting for scans...</div>';
          return;
        }

        feedContainer.innerHTML = recentScans.map(scan => {
          // Format timestamp
          const timeAgo = formatTimeAgo(scan.timestamp);

          // Determine icon and status class
          let icon = 'üé´';
          let statusClass = scan.type;

          if (scan.type === 'success') {
            icon = scan.isTestTicket ? 'üß™' : '‚úÖ';
          } else if (scan.type === 'error') {
            icon = scan.isTestTicket ? 'üß™‚ùå' : '‚ùå';
            statusClass = 'error';
          } else if (scan.type === 'queued') {
            icon = 'üì•';
            statusClass = 'pending';
          }

          // Extract attendee name and ticket type from details if available
          const detailsLines = scan.details.split('\n');
          const attendeeName = detailsLines[0] || scan.details;
          const ticketType = detailsLines.length > 1 ? detailsLines[1] : '';

          // XSS Fix: Escape all user-provided data in activity feed
          return `
            <div class="activity-item ${statusClass}" role="article" aria-label="${escapeHtml(scan.title)}">
              <div class="activity-icon" aria-hidden="true">${icon}</div>
              <div class="activity-details">
                <div class="activity-name">${escapeHtml(attendeeName)}</div>
                ${ticketType ? `<div class="activity-ticket-type">${escapeHtml(ticketType)}</div>` : ''}
                <div class="activity-status">${escapeHtml(scan.title)}</div>
              </div>
              <div class="activity-time">
                <time datetime="${new Date(scan.timestamp).toISOString()}">${escapeHtml(timeAgo)}</time>
              </div>
            </div>
          `;
        }).join('');

        // Auto-scroll to top to show newest scan
        feedContainer.scrollTop = 0;
      }

      function formatTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);

        if (seconds < 10) return 'just now';
        if (seconds < 60) return `${seconds}s ago`;

        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;

        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;

        return 'today';
      }

      // Update activity feed every 30 seconds to refresh "time ago" labels
      setInterval(() => {
        if (recentScans.length > 0) {
          renderActivityFeed();
        }
      }, 30000);

      // Close tickets overlay when clicking backdrop
      document.addEventListener('click', (e) => {
        const overlay = document.getElementById('ticketsOverlay');
        if (e.target === overlay) {
          closeTicketsOverlay();
        }
      });

      // Log initial performance setup
      console.log('Scanner Performance Optimization Loaded');
      console.log('Available debugging: window.scannerPerformance');
      console.log('Device detection:', deviceInfo);

      // Start app
      init();
    </script>

    <!-- Mobile Navigation Controller -->
    <script src="/js/admin-mobile-nav.js"></script>
  </body>
</html>
