#!/usr/bin/env node

/**
 * Test Stability Dashboard Viewer
 * 
 * Utility script to view test flakiness and reliability metrics
 * generated by the E2E monitoring system
 */

import { fileURLToPath } from 'url';
import path from 'path';
import { promises as fs } from 'fs';
import { getFlakinessDetector, generateStabilityDashboard } from '../tests/e2e/monitoring/flakiness-detector.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.join(__dirname, '..');

/**
 * Format duration in human-readable format
 */
function formatDuration(ms) {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  return `${(ms / 60000).toFixed(1)}m`;
}

/**
 * Format reliability score as percentage with color coding
 */
function formatReliability(score) {
  const percentage = (score * 100).toFixed(1);
  if (score >= 0.95) return `‚úÖ ${percentage}%`;
  if (score >= 0.85) return `‚ö†Ô∏è  ${percentage}%`;
  return `‚ùå ${percentage}%`;
}

/**
 * Print dashboard summary
 */
function printSummary(dashboard) {
  console.log('\nüìä Test Stability Dashboard Summary');
  console.log('‚ïê'.repeat(50));
  console.log(`Total Tests Monitored: ${dashboard.summary.totalTests}`);
  console.log(`Overall Reliability: ${formatReliability(dashboard.summary.overallReliability)}`);
  console.log(`Flaky Tests: ${dashboard.summary.flakyTests}`);
  console.log(`Performance Regressions: ${dashboard.summary.performanceRegressions}`);
  console.log(`Generated: ${new Date(dashboard.timestamp).toLocaleString()}\n`);
}

/**
 * Print flaky tests report
 */
function printFlakyTests(dashboard) {
  const flakyTests = Object.entries(dashboard.testDetails)
    .filter(([_, details]) => details.flakiness)
    .sort(([,a], [,b]) => (b.flakiness.detections?.length || 0) - (a.flakiness.detections?.length || 0));

  if (flakyTests.length === 0) {
    console.log('‚úÖ No flaky tests detected\n');
    return;
  }

  console.log('üîÑ Flaky Tests Report');
  console.log('‚îÄ'.repeat(50));
  
  flakyTests.forEach(([testKey, details]) => {
    const { flakiness, statistics } = details;
    const recentDetection = flakiness.detections?.[0];
    
    console.log(`\nüî∏ ${testKey}`);
    console.log(`   Reliability: ${formatReliability(statistics.reliabilityScore)}`);
    console.log(`   Failure Rate: ${((statistics.failureCount / statistics.totalRuns) * 100).toFixed(1)}%`);
    console.log(`   Total Runs: ${statistics.totalRuns} (${statistics.retryCount} retries)`);
    
    if (recentDetection?.analysis?.pattern) {
      console.log(`   Primary Issue: ${recentDetection.analysis.pattern.type}`);
      console.log(`   Recommended Action: ${recentDetection.recommended_action}`);
    }
    
    if (flakiness.detections?.length > 1) {
      console.log(`   Detection History: ${flakiness.detections.length} occurrences`);
    }
  });
  
  console.log('');
}

/**
 * Print performance regressions report
 */
function printPerformanceRegressions(dashboard) {
  const performanceIssues = Object.entries(dashboard.testDetails)
    .filter(([_, details]) => details.performance?.regressions?.length > 0)
    .sort(([,a], [,b]) => {
      const aRegression = a.performance.regressions[0]?.analysis?.regressionPercentage || 0;
      const bRegression = b.performance.regressions[0]?.analysis?.regressionPercentage || 0;
      return bRegression - aRegression;
    });

  if (performanceIssues.length === 0) {
    console.log('‚úÖ No performance regressions detected\n');
    return;
  }

  console.log('üìà Performance Regressions Report');
  console.log('‚îÄ'.repeat(50));
  
  performanceIssues.forEach(([testKey, details]) => {
    const regression = details.performance.regressions[0];
    const { statistics } = details;
    
    console.log(`\nüìä ${testKey}`);
    console.log(`   Regression: +${regression.analysis.regressionPercentage.toFixed(1)}% slower`);
    console.log(`   Recent Time: ${formatDuration(regression.analysis.recentMedian)}`);
    console.log(`   Previous Time: ${formatDuration(regression.analysis.olderMedian)}`);
    console.log(`   Avg Duration: ${formatDuration(statistics.averageDuration)}`);
    console.log(`   Severity: ${regression.severity}`);
    console.log(`   Detected: ${new Date(regression.timestamp).toLocaleString()}`);
  });
  
  console.log('');
}

/**
 * Print test trends
 */
function printTrends(dashboard) {
  console.log('üìà Test Reliability Trends (Last 7 Days)');
  console.log('‚îÄ'.repeat(50));

  const trendsToShow = Object.entries(dashboard.trends.reliability)
    .slice(0, 5); // Show top 5 tests

  if (trendsToShow.length === 0) {
    console.log('No trend data available\n');
    return;
  }

  trendsToShow.forEach(([testKey, trend]) => {
    console.log(`\n${testKey}:`);
    trend.forEach(day => {
      if (day.reliability !== null && day.executionCount > 0) {
        const reliabilityDisplay = formatReliability(day.reliability);
        console.log(`   ${day.date}: ${reliabilityDisplay} (${day.executionCount} runs)`);
      }
    });
  });
  
  console.log('');
}

/**
 * Print recommendations
 */
function printRecommendations(dashboard) {
  if (dashboard.recommendations.length === 0) {
    console.log('‚úÖ No recommendations at this time\n');
    return;
  }

  console.log('üí° Recommendations');
  console.log('‚îÄ'.repeat(50));

  const priorityIcons = {
    high: 'üî¥',
    medium: 'üü°', 
    low: 'üü¢'
  };

  dashboard.recommendations.forEach((rec, index) => {
    const icon = priorityIcons[rec.priority] || 'üîµ';
    console.log(`\n${icon} ${index + 1}. ${rec.test === 'multiple' ? 'Multiple Tests' : rec.test}`);
    console.log(`   Issue: ${rec.issue}`);
    console.log(`   Action: ${rec.action.replace(/_/g, ' ')}`);
    console.log(`   Priority: ${rec.priority}`);
    
    if (rec.details && typeof rec.details === 'object') {
      if (rec.details.affectedTests) {
        console.log(`   Affected: ${rec.details.affectedTests.slice(0, 3).join(', ')}${rec.details.affectedTests.length > 3 ? '...' : ''}`);
      }
    }
  });
  
  console.log('');
}

/**
 * Print statistics overview
 */
function printStatistics(dashboard) {
  const tests = Object.entries(dashboard.testDetails);
  
  if (tests.length === 0) {
    console.log('No test statistics available\n');
    return;
  }

  console.log('üìã Test Statistics Overview');
  console.log('‚îÄ'.repeat(50));

  // Overall stats
  const totalExecutions = tests.reduce((sum, [, details]) => sum + details.statistics.totalRuns, 0);
  const totalFailures = tests.reduce((sum, [, details]) => sum + details.statistics.failureCount, 0);
  const totalRetries = tests.reduce((sum, [, details]) => sum + details.statistics.retryCount, 0);

  console.log(`\nTotal Executions: ${totalExecutions}`);
  console.log(`Total Failures: ${totalFailures} (${((totalFailures / totalExecutions) * 100).toFixed(2)}%)`);
  console.log(`Total Retries: ${totalRetries}`);

  // Performance stats
  const avgDurations = tests.map(([, details]) => details.statistics.averageDuration).filter(d => d > 0);
  if (avgDurations.length > 0) {
    const overallAvg = avgDurations.reduce((sum, d) => sum + d, 0) / avgDurations.length;
    const slowestTest = tests.reduce((max, [key, details]) => 
      details.statistics.averageDuration > (max.details?.statistics.averageDuration || 0) 
        ? { key, details } 
        : max, 
      {}
    );

    console.log(`\nAverage Test Duration: ${formatDuration(overallAvg)}`);
    if (slowestTest.key) {
      console.log(`Slowest Test: ${slowestTest.key} (${formatDuration(slowestTest.details.statistics.averageDuration)})`);
    }
  }

  // Health score distribution
  const healthScores = tests.map(([, details]) => details.healthScore).filter(score => score !== undefined);
  if (healthScores.length > 0) {
    const avgHealth = healthScores.reduce((sum, score) => sum + score, 0) / healthScores.length;
    console.log(`\nAverage Health Score: ${formatReliability(avgHealth)}`);
    
    const unhealthyTests = tests.filter(([, details]) => details.healthScore < 0.8);
    if (unhealthyTests.length > 0) {
      console.log(`Tests Needing Attention: ${unhealthyTests.length}`);
    }
  }

  console.log('');
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  const options = {
    generate: args.includes('--generate') || args.includes('-g'),
    summary: args.includes('--summary') || args.includes('-s'),
    flaky: args.includes('--flaky') || args.includes('-f'),
    performance: args.includes('--performance') || args.includes('-p'),
    trends: args.includes('--trends') || args.includes('-t'),
    recommendations: args.includes('--recommendations') || args.includes('-r'),
    stats: args.includes('--stats'),
    help: args.includes('--help') || args.includes('-h')
  };

  if (options.help) {
    console.log(`
Test Stability Dashboard Viewer

Usage: node scripts/view-test-stability.js [options]

Options:
  -g, --generate        Generate fresh dashboard data
  -s, --summary         Show dashboard summary (default)
  -f, --flaky          Show flaky tests report
  -p, --performance    Show performance regressions
  -t, --trends         Show reliability trends
  -r, --recommendations Show recommendations
      --stats          Show test statistics overview
  -h, --help           Show this help message

Examples:
  node scripts/view-test-stability.js
  node scripts/view-test-stability.js --generate --flaky
  node scripts/view-test-stability.js --performance --recommendations
`);
    return;
  }

  console.log('üîç Test Stability Dashboard Viewer\n');

  try {
    let dashboard;
    
    if (options.generate) {
      console.log('‚è≥ Generating fresh dashboard data...');
      dashboard = await generateStabilityDashboard();
      if (dashboard) {
        console.log('‚úÖ Fresh dashboard data generated\n');
      } else {
        console.log('‚ùå Failed to generate dashboard data\n');
        return;
      }
    } else {
      // Try to load existing dashboard data
      const detector = getFlakinessDetector();
      const metrics = await detector.loadMetrics();
      dashboard = metrics.dashboard;
      
      if (!dashboard) {
        console.log('‚ö†Ô∏è  No dashboard data found. Run with --generate to create fresh data.\n');
        return;
      }
      
      const age = Date.now() - dashboard.timestamp;
      const ageHours = Math.floor(age / (1000 * 60 * 60));
      
      if (ageHours > 0) {
        console.log(`üìä Using dashboard data from ${ageHours} hour${ageHours > 1 ? 's' : ''} ago`);
        console.log('   Use --generate for fresh data\n');
      }
    }

    // Determine what to show
    const showAll = !Object.values(options).some(v => v === true) || options.summary;
    
    if (showAll || options.summary) {
      printSummary(dashboard);
    }
    
    if (showAll || options.flaky) {
      printFlakyTests(dashboard);
    }
    
    if (showAll || options.performance) {
      printPerformanceRegressions(dashboard);
    }
    
    if (options.trends) {
      printTrends(dashboard);
    }
    
    if (showAll || options.recommendations) {
      printRecommendations(dashboard);
    }
    
    if (options.stats) {
      printStatistics(dashboard);
    }

    // Show data location
    console.log('üìÅ Monitoring Data Location:');
    console.log(`   ${path.join(projectRoot, '.tmp/e2e-monitoring/')}`);
    console.log('');

  } catch (error) {
    console.error('‚ùå Error:', error.message);
    if (process.env.DEBUG) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { main };