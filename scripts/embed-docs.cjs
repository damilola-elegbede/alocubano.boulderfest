#!/usr/bin/env node

/**
 * Embeds documentation content into a JavaScript module for Vercel deployment
 * This ensures docs are available at runtime without file system access
 *
 * Optimization: Uses checksum-based caching to skip embedding if files haven't changed
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Documentation files to embed
const docsToEmbed = [
  'docs/ADMIN_DESIGN_SYSTEM.md',
  'docs/CONNECTION_MANAGER.md',
  'docs/ENTERPRISE_DATABASE_DEPLOYMENT.md',
  'docs/GOOGLE_DRIVE_INTEGRATION.md',
  'docs/SECRET_VALIDATION.md',
  'docs/THEME_SYSTEM.md',
  'docs/architecture/ENTERPRISE_DATABASE_SYSTEM.md',
  'docs/architecture/MULTI_EVENT_ARCHITECTURE.md',
  'docs/architecture/MULTI_EVENT_IMPLEMENTATION_PLAN.md',
  'docs/architecture/TEST_ISOLATION_ARCHITECTURE.md'
];

const cacheDir = path.join(process.cwd(), '.tmp');
const cacheFile = path.join(cacheDir, 'docs-cache.json');
const outputPath = path.join(process.cwd(), 'api', 'embedded-docs.js');

/**
 * Generate checksum for all documentation files
 */
function generateChecksum() {
  const hash = crypto.createHash('sha256');

  for (const docPath of docsToEmbed) {
    try {
      const fullPath = path.join(process.cwd(), docPath);
      const content = fs.readFileSync(fullPath, 'utf-8');
      hash.update(content);
    } catch (error) {
      // If file doesn't exist, include that in the hash
      hash.update(`MISSING:${docPath}`);
    }
  }

  return hash.digest('hex');
}

/**
 * Check if cache is valid
 */
function isCacheValid() {
  try {
    if (!fs.existsSync(cacheFile) || !fs.existsSync(outputPath)) {
      return false;
    }

    const cache = JSON.parse(fs.readFileSync(cacheFile, 'utf-8'));
    const currentChecksum = generateChecksum();

    return cache.checksum === currentChecksum;
  } catch (error) {
    return false;
  }
}

/**
 * Save cache metadata
 */
function saveCache(checksum) {
  if (!fs.existsSync(cacheDir)) {
    fs.mkdirSync(cacheDir, { recursive: true });
  }

  const cache = {
    checksum,
    timestamp: new Date().toISOString(),
    files: docsToEmbed
  };

  fs.writeFileSync(cacheFile, JSON.stringify(cache, null, 2));
}

// Check cache validity
if (isCacheValid()) {
  console.log('‚úÖ Documentation cache is valid - skipping embedding');
  console.log('üìö Using cached embedded docs');
  process.exit(0);
}

console.log('üîÑ Documentation changed - regenerating embedded docs...');

// Read all documentation files
const docsContent = {};
const docsList = [];

for (const docPath of docsToEmbed) {
  try {
    const fullPath = path.join(process.cwd(), docPath);
    const content = fs.readFileSync(fullPath, 'utf-8');
    const key = docPath.replace('docs/', '');
    docsContent[key] = content;
    docsList.push(key);
    console.log(`‚úÖ Embedded: ${key}`);
  } catch (error) {
    console.error(`‚ùå Failed to read ${docPath}:`, error.message);
  }
}

// Generate the embedded docs module
const moduleContent = `// Auto-generated file - DO NOT EDIT
// Generated by scripts/embed-docs.js

export const embeddedDocs = ${JSON.stringify(docsContent, null, 2)};

export const availableDocs = ${JSON.stringify(docsList, null, 2)};

console.log('üìö Embedded docs loaded:', Object.keys(embeddedDocs).length, 'files');
`;

// Write to api directory
fs.writeFileSync(outputPath, moduleContent);

// Save cache
const checksum = generateChecksum();
saveCache(checksum);

console.log(`\n‚úÖ Generated ${outputPath}`);
console.log(`üìö Embedded ${Object.keys(docsContent).length} documentation files`);
console.log(`üóÇÔ∏è  Cache saved: ${cacheFile}`);