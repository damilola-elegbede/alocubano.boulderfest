/**
 * Comprehensive API Integration Tests
 * Tests complete request flow with proper service initialization
 * 
 * Updated to use new simplified test helpers (Phase 2.6)
 */

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import request from "supertest";
import express from "express";
import nock from "nock";
import { setupIntegrationTest, teardownTest } from "../helpers/index.js";

describe("Comprehensive API Integration", () => {
  let app;
  let setup;

  beforeAll(async () => {
    // Use new simplified setup
    setup = await setupIntegrationTest('complete-test');

    // Set up additional test environment variables
    process.env.BREVO_API_KEY = "xkeysib-test123";
    process.env.BREVO_NEWSLETTER_LIST_ID = "123";
    process.env.BREVO_WEBHOOK_SECRET = "webhook_secret_123";
    process.env.NODE_ENV = "test";

    // Create Express app with proper service initialization
    app = express();
    app.use(express.json());
    app.use(express.raw({ type: "application/json" }));

    // Import handlers after services are ready
    const [subscribeHandler, webhookHandler] = await Promise.all([
      import("../../api/email/subscribe.js"),
      import("../../api/email/brevo-webhook.js"),
    ]);

    app.post("/api/email/subscribe", subscribeHandler.default);
    app.post("/api/email/brevo-webhook", webhookHandler.default);

    console.log("ðŸŽ¯ Comprehensive API integration test setup complete");
  }, 45000);

  afterAll(async () => {
    await teardownTest(setup);
  });

  describe("Email Subscription API with Real Database", () => {
    it("should handle complete subscription flow", async () => {
      // Mock Brevo API for subscription
      nock("https://api.brevo.com")
        .post("/v3/contacts", (body) => {
          expect(body.email).toBe("integration@example.com");
          expect(body.attributes.FIRSTNAME).toBe("Integration");
          expect(body.attributes.LASTNAME).toBe("Test");
          return true;
        })
        .reply(201, {
          id: 555777,
          email: "integration@example.com",
        });

      const response = await request(app).post("/api/email/subscribe").send({
        email: "integration@example.com",
        firstName: "Integration",
        lastName: "Test",
        source: "integration_test",
        consentToMarketing: true,
      });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toContain("Successfully subscribed");
      expect(response.body.subscriber.email).toBe("integration@example.com");

      // Verify subscriber was actually created in database
      const db = setup.client;
      const result = await db.execute(
        "SELECT * FROM email_subscribers WHERE email = ?",
        ["integration@example.com"],
      );

      expect(result.rows).toHaveLength(1);
      const subscriber = result.rows[0];
      expect(subscriber.email).toBe("integration@example.com");
      expect(subscriber.first_name).toBe("Integration");
      expect(subscriber.last_name).toBe("Test");
      expect(subscriber.status).toBe("active");

      nock.cleanAll();
    });

    it("should handle duplicate subscription attempts", async () => {
      const email = "duplicate@example.com";

      // First subscription
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(201, { id: 666888, email });

      const firstResponse = await request(app)
        .post("/api/email/subscribe")
        .send({
          email,
          firstName: "Duplicate",
          lastName: "Test",
          consentToMarketing: true,
        });

      expect(firstResponse.status).toBe(201);

      // Second subscription should fail
      const secondResponse = await request(app)
        .post("/api/email/subscribe")
        .send({
          email,
          firstName: "Another",
          lastName: "Person",
          consentToMarketing: true,
        });

      expect(secondResponse.status).toBe(409);
      expect(secondResponse.body.error).toContain("already subscribed");

      nock.cleanAll();
    });

    it("should validate email format", async () => {
      const invalidEmails = [
        "notanemail",
        "@example.com",
        "test@",
        "invalid..email@example.com",
      ];

      for (const email of invalidEmails) {
        const response = await request(app).post("/api/email/subscribe").send({
          email,
          firstName: "Test",
          consentToMarketing: true,
        });

        expect(response.status).toBe(400);
        expect(response.body.error).toContain("valid email");
      }
    });

    it("should require marketing consent", async () => {
      const response = await request(app).post("/api/email/subscribe").send({
        email: "consent@example.com",
        firstName: "Test",
        // Missing consentToMarketing
      });

      expect(response.status).toBe(400);
      expect(response.body.error).toContain("Marketing consent is required");
    });

    it("should handle Brevo service failures gracefully", async () => {
      // Mock Brevo API failure
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(500, { message: "Internal Server Error" });

      const response = await request(app).post("/api/email/subscribe").send({
        email: "service-error@example.com",
        firstName: "Service",
        lastName: "Error",
        consentToMarketing: true,
      });

      expect(response.status).toBe(503);
      expect(response.body.error).toContain("temporarily unavailable");

      nock.cleanAll();
    });
  });

  describe("Webhook Processing with Database Integration", () => {
    const createValidSignature = (payload) => {
      const crypto = require("crypto");
      return crypto
        .createHmac("sha256", process.env.BREVO_WEBHOOK_SECRET)
        .update(JSON.stringify(payload))
        .digest("hex");
    };

    it("should process delivery webhook for existing subscriber", async () => {
      const email = "webhook-delivery@example.com";

      // First create subscriber
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(201, { id: 777999, email });

      await request(app).post("/api/email/subscribe").send({
        email,
        firstName: "Webhook",
        lastName: "Delivery",
        consentToMarketing: true,
      });

      // Process delivery webhook
      const webhookPayload = {
        event: "delivered",
        email,
        date: new Date().toISOString(),
        message_id: "delivery_123",
        subject: "Welcome Email",
      };

      const signature = createValidSignature(webhookPayload);

      const response = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(webhookPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", signature);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe("Email delivery recorded");

      // Verify event was logged in database
      const db = setup.client;
      const eventResult = await db.execute(
        `SELECT ee.* FROM email_events ee
         JOIN email_subscribers es ON ee.subscriber_id = es.id
         WHERE es.email = ? AND ee.event_type = ?`,
        [email, "delivered"],
      );

      expect(eventResult.rows).toHaveLength(1);
      const event = eventResult.rows[0];
      expect(event.event_type).toBe("delivered");

      nock.cleanAll();
    });

    it("should handle unsubscribe webhook", async () => {
      const email = "webhook-unsubscribe@example.com";

      // Create subscriber
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(201, { id: 888111, email });

      await request(app).post("/api/email/subscribe").send({
        email,
        firstName: "Webhook",
        lastName: "Unsubscribe",
        consentToMarketing: true,
      });

      // Process unsubscribe webhook
      const webhookPayload = {
        event: "unsubscribed",
        email,
        date: new Date().toISOString(),
      };

      const signature = createValidSignature(webhookPayload);

      const response = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(webhookPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", signature);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe("Unsubscribe processed");

      // Verify subscriber status was updated
      const db = setup.client;
      const result = await db.execute(
        "SELECT status FROM email_subscribers WHERE email = ?",
        [email],
      );

      expect(result.rows[0].status).toBe("unsubscribed");

      nock.cleanAll();
    });

    it("should handle bounce webhook", async () => {
      const email = "webhook-bounce@example.com";

      // Create subscriber
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(201, { id: 999222, email });

      await request(app).post("/api/email/subscribe").send({
        email,
        firstName: "Webhook",
        lastName: "Bounce",
        consentToMarketing: true,
      });

      // Process bounce webhook
      const webhookPayload = {
        event: "hard_bounce",
        email,
        date: new Date().toISOString(),
        reason: "mailbox_not_found",
      };

      const signature = createValidSignature(webhookPayload);

      const response = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(webhookPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", signature);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe(
        "Hard bounce processed, contact marked as bounced",
      );

      // Verify subscriber status was updated
      const db = setup.client;
      const result = await db.execute(
        "SELECT status FROM email_subscribers WHERE email = ?",
        [email],
      );

      expect(result.rows[0].status).toBe("bounced");

      nock.cleanAll();
    });

    it("should reject webhooks with invalid signatures", async () => {
      const webhookPayload = {
        event: "delivered",
        email: "invalid-signature@example.com",
        date: new Date().toISOString(),
      };

      const response = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(webhookPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", "invalid_signature");

      expect(response.status).toBe(401);
      expect(response.body.error).toBe("Invalid signature");
    });

    it("should handle webhooks for unknown subscribers", async () => {
      const webhookPayload = {
        event: "delivered",
        email: "unknown-subscriber@example.com",
        date: new Date().toISOString(),
      };

      const signature = createValidSignature(webhookPayload);

      const response = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(webhookPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", signature);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe(
        "Webhook processed (subscriber not found)",
      );
    });
  });

  describe("End-to-End Integration Flow", () => {
    it("should handle complete subscription and webhook lifecycle", async () => {
      const email = "lifecycle@example.com";

      // Step 1: Subscribe user
      nock("https://api.brevo.com")
        .post("/v3/contacts")
        .reply(201, { id: 111333, email });

      const subscribeResponse = await request(app)
        .post("/api/email/subscribe")
        .send({
          email,
          firstName: "Lifecycle",
          lastName: "Test",
          consentToMarketing: true,
        });

      expect(subscribeResponse.status).toBe(201);
      expect(subscribeResponse.body.success).toBe(true);

      // Step 2: Process delivery webhook
      const deliveryPayload = {
        event: "delivered",
        email,
        date: new Date().toISOString(),
        message_id: "lifecycle_delivered",
      };

      const deliverySignature = createValidSignature(deliveryPayload);

      const deliveryResponse = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(deliveryPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", deliverySignature);

      expect(deliveryResponse.status).toBe(200);
      expect(deliveryResponse.body.message).toBe("Email delivery recorded");

      // Step 3: Process open webhook
      const openPayload = {
        event: "opened",
        email,
        date: new Date().toISOString(),
      };

      const openSignature = createValidSignature(openPayload);

      const openResponse = await request(app)
        .post("/api/email/brevo-webhook")
        .send(JSON.stringify(openPayload))
        .set("Content-Type", "application/json")
        .set("x-brevo-signature", openSignature);

      expect(openResponse.status).toBe(200);
      expect(openResponse.body.message).toBe("Email open recorded");

      // Step 4: Verify complete lifecycle in database
      const db = setup.client;

      // Check subscriber exists and is active
      const subscriberResult = await db.execute(
        "SELECT * FROM email_subscribers WHERE email = ?",
        [email],
      );

      expect(subscriberResult.rows).toHaveLength(1);
      expect(subscriberResult.rows[0].status).toBe("active");

      // Check events were recorded
      const eventsResult = await db.execute(
        `SELECT ee.event_type FROM email_events ee
         JOIN email_subscribers es ON ee.subscriber_id = es.id
         WHERE es.email = ?
         ORDER BY ee.occurred_at`,
        [email],
      );

      expect(eventsResult.rows).toHaveLength(3); // subscribed, delivered, opened
      expect(eventsResult.rows[0].event_type).toBe("subscribed");
      expect(eventsResult.rows[1].event_type).toBe("delivered");
      expect(eventsResult.rows[2].event_type).toBe("opened");

      nock.cleanAll();
    });
  });

  describe("Performance and Reliability", () => {
    it("should handle concurrent subscription requests", async () => {
      const baseEmail = "concurrent-test";
      const requestCount = 5;

      // Setup Brevo mocks for concurrent requests
      for (let i = 0; i < requestCount; i++) {
        nock("https://api.brevo.com")
          .post("/v3/contacts")
          .reply(201, {
            id: 444000 + i,
            email: `${baseEmail}${i}@example.com`,
          });
      }

      const requests = Array(requestCount)
        .fill()
        .map((_, i) =>
          request(app)
            .post("/api/email/subscribe")
            .send({
              email: `${baseEmail}${i}@example.com`,
              firstName: `Concurrent${i}`,
              lastName: "Test",
              consentToMarketing: true,
            }),
        );

      const responses = await Promise.all(requests);

      responses.forEach((response, index) => {
        expect(response.status).toBe(201);
        expect(response.body.success).toBe(true);
        expect(response.body.subscriber.email).toBe(
          `${baseEmail}${index}@example.com`,
        );
      });

      // Verify all subscribers were created
      const db = setup.client;
      const result = await db.execute(
        "SELECT COUNT(*) as count FROM email_subscribers WHERE email LIKE ?",
        [`${baseEmail}%@example.com`],
      );

      expect(result.rows[0].count).toBe(requestCount);

      nock.cleanAll();
    });

    it("should maintain data consistency under load", async () => {
      const db = setup.client;

      // Get initial counts
      const initialStats = await db.execute(`
        SELECT 
          COUNT(*) as total_subscribers,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_subscribers
        FROM email_subscribers
      `);

      const initialTotal = initialStats.rows[0].total_subscribers;
      const initialActive = initialStats.rows[0].active_subscribers;

      // Create multiple subscribers
      const testEmails = Array(3)
        .fill()
        .map((_, i) => `load-test${i}@example.com`);

      for (let i = 0; i < testEmails.length; i++) {
        nock("https://api.brevo.com")
          .post("/v3/contacts")
          .reply(201, { id: 777000 + i, email: testEmails[i] });
      }

      const subscribeRequests = testEmails.map((email) =>
        request(app).post("/api/email/subscribe").send({
          email,
          firstName: "Load",
          lastName: "Test",
          consentToMarketing: true,
        }),
      );

      await Promise.all(subscribeRequests);

      // Verify final counts
      const finalStats = await db.execute(`
        SELECT 
          COUNT(*) as total_subscribers,
          COUNT(CASE WHEN status = 'active' THEN 1 END) as active_subscribers
        FROM email_subscribers
      `);

      const finalTotal = finalStats.rows[0].total_subscribers;
      const finalActive = finalStats.rows[0].active_subscribers;

      expect(finalTotal).toBe(initialTotal + testEmails.length);
      expect(finalActive).toBe(initialActive + testEmails.length);

      nock.cleanAll();
    });
  });
});