name: "ğŸ§ª Unit Tests"

on:
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened, ready_for_review]
  push:
    branches: [main, develop]
  workflow_dispatch:

concurrency:
  group: unit-tests-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

env:
  NODE_ENV: test
  CI: true
  NODE_OPTIONS: "--max-old-space-size=4096"

jobs:
  test:
    name: "ğŸ§ª Unit Tests (Node ${{ matrix.node-version }})"
    runs-on: ubuntu-latest
    timeout-minutes: 15

    strategy:
      fail-fast: false
      matrix:
        node-version: ['20.x', '22.x']

    env:
      DATABASE_URL: ":memory:"
      PHASE3_PERFORMANCE_TARGET_MS: 2000
      VITEST_TEST_TIMEOUT: 10000
      VITEST_HOOK_TIMEOUT: 15000
      VITEST_SETUP_TIMEOUT: 15000
      VITEST_CLEANUP_TIMEOUT: 10000
      # Critical API secrets configuration - required for services to initialize
      QR_SECRET_KEY: 'test-qr-secret-key-minimum-32-characters-long-for-security-compliance'
      ADMIN_SECRET: 'test-admin-jwt-secret-minimum-32-characters-for-security'
      WALLET_AUTH_SECRET: 'test-wallet-auth-secret-key-for-testing-purposes-32-chars'
      APPLE_PASS_KEY: 'dGVzdC1hcHBsZS1wYXNzLWtleQ=='
      INTERNAL_API_KEY: ${{ secrets.INTERNAL_API_KEY || 'test-internal-api-key-32-chars-min' }}
      TEST_ADMIN_PASSWORD: 'test-admin-password-123'
      ADMIN_PASSWORD: '$2b$10$test.bcrypt.hash.for.testing.purposes.only'

    steps:
      - name: "ğŸ“¥ Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "ğŸ”§ Setup Node.js ${{ matrix.node-version }}"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: "ğŸ“¦ Cache node_modules"
        id: cache-modules
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ matrix.node-version }}-unit-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ matrix.node-version }}-unit-

      - name: "ğŸ“¦ Install Dependencies"
        if: steps.cache-modules.outputs.cache-hit != 'true'
        env:
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1'
          NGROK_SKIP_DOWNLOAD: '1'
          PUPPETEER_SKIP_DOWNLOAD: '1'
          SKIP_HEAVYWEIGHT_DOWNLOADS: '1'
        run: |
          echo "ğŸ“¦ Installing minimal dependencies for unit tests..."

          # Install with npm ci, skipping optional deps
          npm ci --prefer-offline --no-audit --no-fund

          # Only install the specific LibSQL binary we need
          if [ "$RUNNER_OS" = "Linux" ]; then
            if [ ! -d "node_modules/@libsql/linux-x64-gnu" ]; then
              echo "ğŸ”§ Installing LibSQL Linux binary..."
              npm install @libsql/linux-x64-gnu@0.5.22 --no-save --no-audit
            fi
          fi

          echo "âœ… Minimal dependencies installed"

      - name: "ğŸ”„ Verify Cached Dependencies"
        if: steps.cache-modules.outputs.cache-hit == 'true'
        run: |
          echo "ğŸ“¦ Using cached dependencies"
          # Quick verification that critical packages exist
          if [ ! -d "node_modules/@libsql" ]; then
            echo "âš ï¸ Cache corrupted, reinstalling..."
            npm ci --prefer-offline --no-audit --no-fund
          else
            echo "âœ… Cached dependencies verified"
          fi

      - name: "ğŸ§¹ Optimize for Unit Tests"
        run: |
          echo "ğŸ§¹ Removing unnecessary heavyweight dependencies..."
          # Remove packages not needed for unit tests (saves ~77MB)
          rm -rf node_modules/playwright* 2>/dev/null || true
          rm -rf node_modules/lighthouse* 2>/dev/null || true
          rm -rf node_modules/ngrok* 2>/dev/null || true
          rm -rf node_modules/vercel 2>/dev/null || true
          rm -rf node_modules/@axe-core 2>/dev/null || true
          rm -rf node_modules/puppeteer* 2>/dev/null || true
          echo "ğŸ¯ Optimized for unit tests"

      - name: "ğŸ§ª Run Unit Tests"
        id: test
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Running Unit Test Suite"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Expected: 800+ unit tests"
          echo "ğŸ¯ Performance Target: <2 seconds"
          echo "ğŸ’¾ Database: In-memory SQLite"
          echo "â±ï¸  Timeout: 15 minutes (CI buffer)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          start_time=$(date +%s%3N)
          # Run tests with colors disabled for CI parsing
          CI=true npm test -- --reporter=verbose --no-color 2>&1 | tee unit-test-output.log
          test_exit_code=${PIPESTATUS[0]}
          end_time=$(date +%s%3N)
          duration=$((end_time - start_time))

          # Extract test counts - Fix: Calculate total_tests correctly
          passing_tests=$(grep -E "Tests.*passed" unit-test-output.log | sed -E "s/.*Tests[[:space:]]+([0-9]+)[[:space:]]+passed.*/\1/" | head -1 || echo "0")
          failing_tests=$(grep -E "Tests.*failed" unit-test-output.log | sed -E "s/.*Tests[[:space:]]+([0-9]+)[[:space:]]+failed.*/\1/" | head -1 || echo "0")
          total_tests=$((passing_tests + failing_tests))

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š Unit Test Results"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Tests Passed: $passing_tests"
          echo "âŒ Tests Failed: $failing_tests"
          echo "ğŸ“ˆ Total Tests: $total_tests"
          echo "â±ï¸  Duration: ${duration}ms"

          if [ "$duration" -lt "$PHASE3_PERFORMANCE_TARGET_MS" ]; then
            echo "ğŸ† EXCELLENT: Unit tests completed within 2-second target!"
          else
            echo "âš ï¸  WARNING: Unit tests exceeded 2-second target"
          fi

          exit $test_exit_code

      - name: "ğŸ“¤ Upload Test Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results-node-${{ matrix.node-version }}
          path: unit-test-output.log
          retention-days: 7

      - name: "ğŸ“Š Report to PR"
        if: github.event_name == 'pull_request' && always()
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const output = fs.readFileSync('unit-test-output.log', 'utf8');
            const nodeVersion = '${{ matrix.node-version }}';
            const status = '${{ job.status }}';

            const statusIcon = status === 'success' ? 'âœ…' : 'âŒ';
            const statusText = status === 'success' ? 'PASSED' : 'FAILED';

            const comment = `## ${statusIcon} Unit Tests ${statusText} (Node ${nodeVersion})

            <details>
            <summary>View Test Output</summary>

            \`\`\`
            ${output.slice(-3000)}
            \`\`\`

            </details>
            `;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes(`Unit Tests`) &&
              comment.body.includes(`Node ${nodeVersion}`)
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }