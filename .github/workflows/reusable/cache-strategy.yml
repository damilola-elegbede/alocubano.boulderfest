---
name: 💾 Reusable Cache Strategy

# Unified caching approach for CI/CD workflows
# Implements intelligent cache layering, restoration fallbacks, and performance optimization
# Supports multiple cache types: npm, browsers, build artifacts, test results

on:
  workflow_call:
    inputs:
      cache-type:
        description: 'Type of cache to manage'
        required: true
        type: string  # npm, playwright, build, test-results, database, custom
      cache-key-base:
        description: 'Base key for cache identification'
        required: true
        type: string
      cache-paths:
        description: 'Paths to cache (JSON array or newline-separated string)'
        required: true
        type: string
      node-version:
        description: 'Node.js version for cache key'
        required: false
        type: string
        default: '20'
      cache-strategy:
        description: 'Cache strategy level'
        required: false
        type: string
        default: 'aggressive'  # minimal, standard, aggressive, persistent
      cache-compression:
        description: 'Enable cache compression'
        required: false
        type: boolean
        default: true
      fallback-enabled:
        description: 'Enable fallback cache restoration'
        required: false
        type: boolean
        default: true
      custom-restore-keys:
        description: 'Custom restore keys (JSON array)'
        required: false
        type: string
        default: '[]'
      max-cache-size:
        description: 'Maximum cache size in MB'
        required: false
        type: string
        default: '500'
      retention-days:
        description: 'Cache retention in days'
        required: false
        type: string
        default: '7'
    outputs:
      cache-hit:
        description: 'Whether primary cache was hit'
        value: ${{ jobs.cache-manager.outputs.cache-hit }}
      cache-restored:
        description: 'Whether any cache was restored'
        value: ${{ jobs.cache-manager.outputs.cache-restored }}
      cache-key:
        description: 'Final cache key used'
        value: ${{ jobs.cache-manager.outputs.cache-key }}
      cache-size:
        description: 'Size of cached data'
        value: ${{ jobs.cache-manager.outputs.cache-size }}
      fallback-used:
        description: 'Whether fallback cache was used'
        value: ${{ jobs.cache-manager.outputs.fallback-used }}

env:
  CACHE_COMPRESSION_LEVEL: ${{ inputs.cache-compression && 'fast' || 'none' }}
  
jobs:
  cache-manager:
    name: 💾 Cache Manager (${{ inputs.cache-type }})
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      cache-hit: ${{ steps.primary-cache.outputs.cache-hit }}
      cache-restored: ${{ steps.cache-status.outputs.cache-restored }}
      cache-key: ${{ steps.cache-status.outputs.cache-key }}
      cache-size: ${{ steps.cache-status.outputs.cache-size }}
      fallback-used: ${{ steps.cache-status.outputs.fallback-used }}
    
    steps:
      - name: ⏱️ Initialize Cache Operation
        run: |
          echo "🚀 Starting cache operation for: ${{ inputs.cache-type }}"
          echo "Cache strategy: ${{ inputs.cache-strategy }}"
          echo "Base key: ${{ inputs.cache-key-base }}"
          echo "Max size: ${{ inputs.max-cache-size }}MB"

      - name: 🔧 Generate Cache Keys
        id: cache-keys
        run: |
          # Generate unique cache key based on type and inputs
          TIMESTAMP=$(date +%Y%m%d)
          HASH_INPUT="${{ inputs.cache-key-base }}-${{ github.repository }}-${{ inputs.node-version }}"
          HASH_SUFFIX=$(echo "$HASH_INPUT" | sha256sum | cut -c1-8)
          
          case "${{ inputs.cache-type }}" in
            "npm")
              PRIMARY_KEY="npm-${{ inputs.cache-strategy }}-${{ runner.os }}-node${{ inputs.node-version }}-${{ inputs.cache-key-base }}-v3"
              FALLBACK_KEYS='[
                "npm-${{ inputs.cache-strategy }}-${{ runner.os }}-node${{ inputs.node-version }}-",
                "npm-${{ inputs.cache-strategy }}-${{ runner.os }}-",
                "npm-standard-${{ runner.os }}-node${{ inputs.node-version }}-"
              ]'
              ;;
            "playwright")
              PRIMARY_KEY="playwright-${{ inputs.cache-strategy }}-${{ runner.os }}-${{ inputs.cache-key-base }}-v4"
              FALLBACK_KEYS='[
                "playwright-${{ inputs.cache-strategy }}-${{ runner.os }}-",
                "playwright-standard-${{ runner.os }}-v4"
              ]'
              ;;
            "build")
              PRIMARY_KEY="build-${{ inputs.cache-strategy }}-${{ runner.os }}-${{ inputs.cache-key-base }}-${HASH_SUFFIX}-v2"
              FALLBACK_KEYS='[
                "build-${{ inputs.cache-strategy }}-${{ runner.os }}-",
                "build-standard-${{ runner.os }}-"
              ]'
              ;;
            "test-results")
              PRIMARY_KEY="test-results-${{ runner.os }}-${{ inputs.cache-key-base }}-${TIMESTAMP}-v1"
              FALLBACK_KEYS='[
                "test-results-${{ runner.os }}-${{ inputs.cache-key-base }}-",
                "test-results-${{ runner.os }}-"
              ]'
              ;;
            "database")
              PRIMARY_KEY="database-${{ inputs.cache-strategy }}-${{ inputs.cache-key-base }}-${HASH_SUFFIX}-v1"
              FALLBACK_KEYS='[
                "database-${{ inputs.cache-strategy }}-",
                "database-standard-"
              ]'
              ;;
            "custom")
              PRIMARY_KEY="custom-${{ inputs.cache-strategy }}-${{ inputs.cache-key-base }}-${HASH_SUFFIX}-v1"
              FALLBACK_KEYS='${{ inputs.custom-restore-keys }}'
              ;;
            *)
              echo "❌ Unsupported cache type: ${{ inputs.cache-type }}"
              exit 1
              ;;
          esac
          
          echo "primary-key=$PRIMARY_KEY" >> $GITHUB_OUTPUT
          echo "fallback-keys=$FALLBACK_KEYS" >> $GITHUB_OUTPUT
          echo "🔑 Primary key: $PRIMARY_KEY"

      - name: 📏 Validate Cache Paths
        id: path-validation
        run: |
          # Validate and normalize cache paths
          PATHS_INPUT='${{ inputs.cache-paths }}'
          
          # Handle both JSON array and newline-separated formats
          if [[ "$PATHS_INPUT" == \[* ]]; then
            # JSON array format
            echo "$PATHS_INPUT" | jq -r '.[]' > /tmp/cache_paths.txt
          else
            # Newline-separated format
            echo "$PATHS_INPUT" > /tmp/cache_paths.txt
          fi
          
          # Validate paths exist or can be created
          VALID_PATHS=""
          TOTAL_SIZE=0
          
          while IFS= read -r path; do
            if [ -n "$path" ] && [ "$path" != "null" ]; then
              # Create directory if it doesn't exist (for future caching)
              mkdir -p "$(dirname "$path")" || true
              
              if [ -e "$path" ]; then
                # Calculate size if path exists
                SIZE=$(du -sm "$path" 2>/dev/null | cut -f1 || echo "0")
                TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
                echo "📁 Found: $path (${SIZE}MB)"
              else
                echo "📁 Prepared: $path (for future cache)"
              fi
              
              if [ -n "$VALID_PATHS" ]; then
                VALID_PATHS="$VALID_PATHS"$'\n'"$path"
              else
                VALID_PATHS="$path"
              fi
            fi
          done < /tmp/cache_paths.txt
          
          # Check against max cache size
          if [ $TOTAL_SIZE -gt ${{ inputs.max-cache-size }} ]; then
            echo "⚠️ Warning: Cache size (${TOTAL_SIZE}MB) exceeds limit (${{ inputs.max-cache-size }}MB)"
            echo "Consider increasing max-cache-size or reducing cached paths"
          fi
          
          echo "valid-paths<<EOF" >> $GITHUB_OUTPUT
          echo "$VALID_PATHS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "total-size=$TOTAL_SIZE" >> $GITHUB_OUTPUT
          echo "📊 Total cache size: ${TOTAL_SIZE}MB"

      - name: 💾 Primary Cache Operation
        id: primary-cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.path-validation.outputs.valid-paths }}
          key: ${{ steps.cache-keys.outputs.primary-key }}
          restore-keys: ${{ fromJson(steps.cache-keys.outputs.fallback-keys) }}
          enableCrossOsArchive: false
          fail-on-cache-miss: false
          lookup-only: false
          save-always: ${{ inputs.cache-strategy == 'persistent' }}

      - name: 🔄 Fallback Cache Strategy
        id: fallback-cache
        if: steps.primary-cache.outputs.cache-hit != 'true' && inputs.fallback-enabled == true
        run: |
          echo "🔄 Primary cache miss, attempting fallback restoration..."
          
          # Try each fallback key progressively
          FALLBACK_KEYS='${{ steps.cache-keys.outputs.fallback-keys }}'
          FALLBACK_USED="false"
          
          echo "$FALLBACK_KEYS" | jq -r '.[]' | while read -r fallback_key; do
            if [ -n "$fallback_key" ] && [ "$fallback_key" != "null" ]; then
              echo "🔍 Trying fallback key: $fallback_key"
              # Note: Individual fallback attempts would need separate cache actions
              # This is a placeholder for logging
            fi
          done
          
          echo "fallback-attempted=true" >> $GITHUB_OUTPUT

      - name: 🏗️ Cache Preparation (on miss)
        if: steps.primary-cache.outputs.cache-hit != 'true'
        run: |
          echo "🏗️ Preparing directories for future caching..."
          
          # Create all necessary directories
          while IFS= read -r path; do
            if [ -n "$path" ]; then
              mkdir -p "$(dirname "$path")" || true
              # Create empty marker for directories
              if [[ "$path" == */ ]]; then
                mkdir -p "$path"
                touch "$path/.cache-marker"
              fi
            fi
          done <<< "${{ steps.path-validation.outputs.valid-paths }}"
          
          echo "✅ Cache directories prepared"

      - name: 📊 Cache Performance Analysis
        id: cache-status
        run: |
          CACHE_HIT="${{ steps.primary-cache.outputs.cache-hit }}"
          CACHE_KEY="${{ steps.cache-keys.outputs.primary-key }}"
          CACHE_SIZE="${{ steps.path-validation.outputs.total-size }}"
          
          # Determine if any cache was restored
          if [ "$CACHE_HIT" == "true" ]; then
            CACHE_RESTORED="true"
            FALLBACK_USED="false"
            echo "✅ Primary cache hit: $CACHE_KEY"
          else
            CACHE_RESTORED="false"
            FALLBACK_USED="${{ steps.fallback-cache.outputs.fallback-attempted || 'false' }}"
            echo "❌ Cache miss: $CACHE_KEY"
          fi
          
          # Output results
          echo "cache-hit=$CACHE_HIT" >> $GITHUB_OUTPUT
          echo "cache-restored=$CACHE_RESTORED" >> $GITHUB_OUTPUT
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "cache-size=${CACHE_SIZE}MB" >> $GITHUB_OUTPUT
          echo "fallback-used=$FALLBACK_USED" >> $GITHUB_OUTPUT
          
          # Performance impact calculation
          if [ "$CACHE_HIT" == "true" ]; then
            case "${{ inputs.cache-type }}" in
              "npm")
                TIME_SAVED="3-5"
                ;;
              "playwright")
                TIME_SAVED="2-4"
                ;;
              "build")
                TIME_SAVED="1-3"
                ;;
              "test-results")
                TIME_SAVED="0.5-1"
                ;;
              *)
                TIME_SAVED="1-2"
                ;;
            esac
            echo "⚡ Estimated time saved: ${TIME_SAVED} minutes"
          fi

      - name: 🧹 Cache Maintenance
        if: inputs.cache-strategy == 'aggressive' || inputs.cache-strategy == 'persistent'
        run: |
          echo "🧹 Performing cache maintenance..."
          
          # Clean up old cache markers
          find . -name ".cache-marker" -type f -delete 2>/dev/null || true
          
          # Log cache statistics for monitoring
          echo "📊 Cache Statistics:"
          echo "  Type: ${{ inputs.cache-type }}"
          echo "  Strategy: ${{ inputs.cache-strategy }}"
          echo "  Hit: ${{ steps.primary-cache.outputs.cache-hit }}"
          echo "  Size: ${{ steps.path-validation.outputs.total-size }}MB"
          echo "  Key: ${{ steps.cache-keys.outputs.primary-key }}"

      - name: 📋 Generate Cache Report
        run: |
          echo "# 💾 Cache Strategy Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Cache Type | ${{ inputs.cache-type }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Strategy | ${{ inputs.cache-strategy }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cache Hit | ${{ steps.primary-cache.outputs.cache-hit && '✅ Yes' || '❌ No' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cache Size | ${{ steps.path-validation.outputs.total-size }}MB |" >> $GITHUB_STEP_SUMMARY
          echo "| Max Size | ${{ inputs.max-cache-size }}MB |" >> $GITHUB_STEP_SUMMARY
          echo "| Compression | ${{ inputs.cache-compression && '✅ Enabled' || '❌ Disabled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Fallback | ${{ inputs.fallback-enabled && '✅ Enabled' || '❌ Disabled' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.primary-cache.outputs.cache-hit }}" == "true" ]; then
            echo "**✅ Cache Performance**: Successfully restored from cache" >> $GITHUB_STEP_SUMMARY
          else
            echo "**⚠️ Cache Performance**: No cache hit, will build fresh cache" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cache Key**: \`${{ steps.cache-keys.outputs.primary-key }}\`" >> $GITHUB_STEP_SUMMARY